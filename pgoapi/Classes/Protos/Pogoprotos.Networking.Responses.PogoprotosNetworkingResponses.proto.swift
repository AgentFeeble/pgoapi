// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "POGOProtos.Networking.Responses.proto"
// Syntax "Proto3"

import Foundation
import ProtocolBuffers

public extension Pogoprotos.Networking.Responses {
  public struct PogoprotosNetworkingResponsesRoot {
    public static let `default` = PogoprotosNetworkingResponsesRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(registry: extensionRegistry)
      Pogoprotos.Data.Battle.PogoprotosDataBattleRoot.default.registerAllExtensions(registry: extensionRegistry)
      Pogoprotos.Data.Capture.PogoprotosDataCaptureRoot.default.registerAllExtensions(registry: extensionRegistry)
      Pogoprotos.Enums.PogoprotosEnumsRoot.default.registerAllExtensions(registry: extensionRegistry)
      Pogoprotos.Data.PogoprotosDataRoot.default.registerAllExtensions(registry: extensionRegistry)
      Pogoprotos.Settings.Master.PogoprotosSettingsMasterRoot.default.registerAllExtensions(registry: extensionRegistry)
      Pogoprotos.Settings.PogoprotosSettingsRoot.default.registerAllExtensions(registry: extensionRegistry)
      Pogoprotos.Map.Pokemon.PogoprotosMapPokemonRoot.default.registerAllExtensions(registry: extensionRegistry)
      Pogoprotos.Data.Player.PogoprotosDataPlayerRoot.default.registerAllExtensions(registry: extensionRegistry)
      Pogoprotos.Data.Gym.PogoprotosDataGymRoot.default.registerAllExtensions(registry: extensionRegistry)
      Pogoprotos.Map.Fort.PogoprotosMapFortRoot.default.registerAllExtensions(registry: extensionRegistry)
      Pogoprotos.Inventory.Item.PogoprotosInventoryItemRoot.default.registerAllExtensions(registry: extensionRegistry)
      Pogoprotos.Inventory.PogoprotosInventoryRoot.default.registerAllExtensions(registry: extensionRegistry)
      Pogoprotos.Map.PogoprotosMapRoot.default.registerAllExtensions(registry: extensionRegistry)
      Pogoprotos.Data.Logs.PogoprotosDataLogsRoot.default.registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
  }

  final public class AddFortModifierResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.AddFortModifierResponse, rhs: Pogoprotos.Networking.Responses.AddFortModifierResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasFortDetails == rhs.hasFortDetails) && (!lhs.hasFortDetails || lhs.fortDetails == rhs.fortDetails)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case noResultSet = 0
        case success = 1
        case fortAlreadyHasModifier = 2
        case tooFarAway = 3
        case noItemInInventory = 4
        public func toString() -> String {
          switch self {
          case .noResultSet: return "NO_RESULT_SET"
          case .success: return "SUCCESS"
          case .fortAlreadyHasModifier: return "FORT_ALREADY_HAS_MODIFIER"
          case .tooFarAway: return "TOO_FAR_AWAY"
          case .noItemInInventory: return "NO_ITEM_IN_INVENTORY"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Result {
          switch str {
          case "NO_RESULT_SET":  return .noResultSet
          case "SUCCESS":  return .success
          case "FORT_ALREADY_HAS_MODIFIER":  return .fortAlreadyHasModifier
          case "TOO_FAR_AWAY":  return .tooFarAway
          case "NO_ITEM_IN_INVENTORY":  return .noItemInInventory
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .noResultSet: return ".noResultSet"
          case .success: return ".success"
          case .fortAlreadyHasModifier: return ".fortAlreadyHasModifier"
          case .tooFarAway: return ".tooFarAway"
          case .noItemInInventory: return ".noItemInInventory"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.AddFortModifierResponse.Result = Pogoprotos.Networking.Responses.AddFortModifierResponse.Result.noResultSet
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var fortDetails:Pogoprotos.Networking.Responses.FortDetailsResponse!
    public fileprivate(set) var hasFortDetails:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasFortDetails {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:fortDetails)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasFortDetails {
          if let varSizefortDetails = fortDetails?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizefortDetails
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
      return Pogoprotos.Networking.Responses.AddFortModifierResponse.classBuilder() as! Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.AddFortModifierResponse) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasFortDetails {
        jsonMap["fortDetails"] = try fortDetails.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasFortDetails {
        output += "\(indent) fortDetails {\n"
        if let outDescFortDetails = fortDetails {
          output += try outDescFortDetails.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasFortDetails {
                if let hashValuefortDetails = fortDetails?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuefortDetails
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.AddFortModifierResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.AddFortModifierResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.AddFortModifierResponse = Pogoprotos.Networking.Responses.AddFortModifierResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.AddFortModifierResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.AddFortModifierResponse.Result) -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .noResultSet
           return self
        }
      public var hasFortDetails:Bool {
           get {
               return builderResult.hasFortDetails
           }
      }
      public var fortDetails:Pogoprotos.Networking.Responses.FortDetailsResponse! {
           get {
               if fortDetailsBuilder_ != nil {
                  builderResult.fortDetails = fortDetailsBuilder_.getMessage()
               }
               return builderResult.fortDetails
           }
           set (value) {
               builderResult.hasFortDetails = true
               builderResult.fortDetails = value
           }
      }
      fileprivate var fortDetailsBuilder_:Pogoprotos.Networking.Responses.FortDetailsResponse.Builder! {
           didSet {
              builderResult.hasFortDetails = true
           }
      }
      public func getFortDetailsBuilder() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        if fortDetailsBuilder_ == nil {
           fortDetailsBuilder_ = Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
           builderResult.fortDetails = fortDetailsBuilder_.getMessage()
           if fortDetails != nil {
              try! fortDetailsBuilder_.mergeFrom(other: fortDetails)
           }
        }
        return fortDetailsBuilder_
      }
      @discardableResult
      public func setFortDetails(_ value:Pogoprotos.Networking.Responses.FortDetailsResponse!) -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        self.fortDetails = value
        return self
      }
      @discardableResult
      public func mergeFortDetails(value:Pogoprotos.Networking.Responses.FortDetailsResponse) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        if builderResult.hasFortDetails {
          builderResult.fortDetails = try Pogoprotos.Networking.Responses.FortDetailsResponse.builderWithPrototype(prototype:builderResult.fortDetails).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.fortDetails = value
        }
        builderResult.hasFortDetails = true
        return self
      }
      @discardableResult
      public func clearFortDetails() -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        fortDetailsBuilder_ = nil
        builderResult.hasFortDetails = false
        builderResult.fortDetails = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.AddFortModifierResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        return try Pogoprotos.Networking.Responses.AddFortModifierResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
        let returnMe:Pogoprotos.Networking.Responses.AddFortModifierResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.AddFortModifierResponse) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        if other == Pogoprotos.Networking.Responses.AddFortModifierResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasFortDetails) {
            try mergeFortDetails(value: other.fortDetails)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.AddFortModifierResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Networking.Responses.FortDetailsResponse.Builder = Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
            if hasFortDetails {
              try subBuilder.mergeFrom(other: fortDetails)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            fortDetails = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.AddFortModifierResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueFortDetails = jsonMap["fortDetails"] as? Dictionary<String,Any> {
          resultDecodedBuilder.fortDetails = try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder.decodeToBuilder(jsonMap:jsonValueFortDetails).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class AttackGymResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.AttackGymResponse, rhs: Pogoprotos.Networking.Responses.AttackGymResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasBattleLog == rhs.hasBattleLog) && (!lhs.hasBattleLog || lhs.battleLog == rhs.battleLog)
      fieldCheck = fieldCheck && (lhs.hasBattleId == rhs.hasBattleId) && (!lhs.hasBattleId || lhs.battleId == rhs.battleId)
      fieldCheck = fieldCheck && (lhs.hasActiveDefender == rhs.hasActiveDefender) && (!lhs.hasActiveDefender || lhs.activeDefender == rhs.activeDefender)
      fieldCheck = fieldCheck && (lhs.hasActiveAttacker == rhs.hasActiveAttacker) && (!lhs.hasActiveAttacker || lhs.activeAttacker == rhs.activeAttacker)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case errorInvalidAttackActions = 2
        case errorNotInRange = 3
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .errorInvalidAttackActions: return "ERROR_INVALID_ATTACK_ACTIONS"
          case .errorNotInRange: return "ERROR_NOT_IN_RANGE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "ERROR_INVALID_ATTACK_ACTIONS":  return .errorInvalidAttackActions
          case "ERROR_NOT_IN_RANGE":  return .errorNotInRange
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .errorInvalidAttackActions: return ".errorInvalidAttackActions"
          case .errorNotInRange: return ".errorNotInRange"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.AttackGymResponse.Result = Pogoprotos.Networking.Responses.AttackGymResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var battleLog:Pogoprotos.Data.Battle.BattleLog!
    public fileprivate(set) var hasBattleLog:Bool = false
    public fileprivate(set) var battleId:String = ""
    public fileprivate(set) var hasBattleId:Bool = false

    public fileprivate(set) var activeDefender:Pogoprotos.Data.Battle.BattlePokemonInfo!
    public fileprivate(set) var hasActiveDefender:Bool = false
    public fileprivate(set) var activeAttacker:Pogoprotos.Data.Battle.BattlePokemonInfo!
    public fileprivate(set) var hasActiveAttacker:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasBattleLog {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:battleLog)
      }
      if hasBattleId {
        try codedOutputStream.writeString(fieldNumber: 3, value:battleId)
      }
      if hasActiveDefender {
        try codedOutputStream.writeMessage(fieldNumber: 4, value:activeDefender)
      }
      if hasActiveAttacker {
        try codedOutputStream.writeMessage(fieldNumber: 5, value:activeAttacker)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasBattleLog {
          if let varSizebattleLog = battleLog?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizebattleLog
          }
      }
      if hasBattleId {
        serialize_size += battleId.computeStringSize(fieldNumber: 3)
      }
      if hasActiveDefender {
          if let varSizeactiveDefender = activeDefender?.computeMessageSize(fieldNumber: 4) {
              serialize_size += varSizeactiveDefender
          }
      }
      if hasActiveAttacker {
          if let varSizeactiveAttacker = activeAttacker?.computeMessageSize(fieldNumber: 5) {
              serialize_size += varSizeactiveAttacker
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
      return Pogoprotos.Networking.Responses.AttackGymResponse.classBuilder() as! Pogoprotos.Networking.Responses.AttackGymResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.AttackGymResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.AttackGymResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.AttackGymResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.AttackGymResponse) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasBattleLog {
        jsonMap["battleLog"] = try battleLog.encode()
      }
      if hasBattleId {
        jsonMap["battleId"] = battleId
      }
      if hasActiveDefender {
        jsonMap["activeDefender"] = try activeDefender.encode()
      }
      if hasActiveAttacker {
        jsonMap["activeAttacker"] = try activeAttacker.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasBattleLog {
        output += "\(indent) battleLog {\n"
        if let outDescBattleLog = battleLog {
          output += try outDescBattleLog.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasBattleId {
        output += "\(indent) battleId: \(battleId) \n"
      }
      if hasActiveDefender {
        output += "\(indent) activeDefender {\n"
        if let outDescActiveDefender = activeDefender {
          output += try outDescActiveDefender.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasActiveAttacker {
        output += "\(indent) activeAttacker {\n"
        if let outDescActiveAttacker = activeAttacker {
          output += try outDescActiveAttacker.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasBattleLog {
                if let hashValuebattleLog = battleLog?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuebattleLog
                }
            }
            if hasBattleId {
               hashCode = (hashCode &* 31) &+ battleId.hashValue
            }
            if hasActiveDefender {
                if let hashValueactiveDefender = activeDefender?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueactiveDefender
                }
            }
            if hasActiveAttacker {
                if let hashValueactiveAttacker = activeAttacker?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueactiveAttacker
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.AttackGymResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.AttackGymResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.AttackGymResponse = Pogoprotos.Networking.Responses.AttackGymResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.AttackGymResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.AttackGymResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.AttackGymResponse.Result) -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasBattleLog:Bool {
           get {
               return builderResult.hasBattleLog
           }
      }
      public var battleLog:Pogoprotos.Data.Battle.BattleLog! {
           get {
               if battleLogBuilder_ != nil {
                  builderResult.battleLog = battleLogBuilder_.getMessage()
               }
               return builderResult.battleLog
           }
           set (value) {
               builderResult.hasBattleLog = true
               builderResult.battleLog = value
           }
      }
      fileprivate var battleLogBuilder_:Pogoprotos.Data.Battle.BattleLog.Builder! {
           didSet {
              builderResult.hasBattleLog = true
           }
      }
      public func getBattleLogBuilder() -> Pogoprotos.Data.Battle.BattleLog.Builder {
        if battleLogBuilder_ == nil {
           battleLogBuilder_ = Pogoprotos.Data.Battle.BattleLog.Builder()
           builderResult.battleLog = battleLogBuilder_.getMessage()
           if battleLog != nil {
              try! battleLogBuilder_.mergeFrom(other: battleLog)
           }
        }
        return battleLogBuilder_
      }
      @discardableResult
      public func setBattleLog(_ value:Pogoprotos.Data.Battle.BattleLog!) -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        self.battleLog = value
        return self
      }
      @discardableResult
      public func mergeBattleLog(value:Pogoprotos.Data.Battle.BattleLog) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        if builderResult.hasBattleLog {
          builderResult.battleLog = try Pogoprotos.Data.Battle.BattleLog.builderWithPrototype(prototype:builderResult.battleLog).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.battleLog = value
        }
        builderResult.hasBattleLog = true
        return self
      }
      @discardableResult
      public func clearBattleLog() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        battleLogBuilder_ = nil
        builderResult.hasBattleLog = false
        builderResult.battleLog = nil
        return self
      }
      public var hasBattleId:Bool {
           get {
                return builderResult.hasBattleId
           }
      }
      public var battleId:String {
           get {
                return builderResult.battleId
           }
           set (value) {
               builderResult.hasBattleId = true
               builderResult.battleId = value
           }
      }
      @discardableResult
      public func setBattleId(_ value:String) -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        self.battleId = value
        return self
      }
      @discardableResult
      public func clearBattleId() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder{
           builderResult.hasBattleId = false
           builderResult.battleId = ""
           return self
      }
      public var hasActiveDefender:Bool {
           get {
               return builderResult.hasActiveDefender
           }
      }
      public var activeDefender:Pogoprotos.Data.Battle.BattlePokemonInfo! {
           get {
               if activeDefenderBuilder_ != nil {
                  builderResult.activeDefender = activeDefenderBuilder_.getMessage()
               }
               return builderResult.activeDefender
           }
           set (value) {
               builderResult.hasActiveDefender = true
               builderResult.activeDefender = value
           }
      }
      fileprivate var activeDefenderBuilder_:Pogoprotos.Data.Battle.BattlePokemonInfo.Builder! {
           didSet {
              builderResult.hasActiveDefender = true
           }
      }
      public func getActiveDefenderBuilder() -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        if activeDefenderBuilder_ == nil {
           activeDefenderBuilder_ = Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
           builderResult.activeDefender = activeDefenderBuilder_.getMessage()
           if activeDefender != nil {
              try! activeDefenderBuilder_.mergeFrom(other: activeDefender)
           }
        }
        return activeDefenderBuilder_
      }
      @discardableResult
      public func setActiveDefender(_ value:Pogoprotos.Data.Battle.BattlePokemonInfo!) -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        self.activeDefender = value
        return self
      }
      @discardableResult
      public func mergeActiveDefender(value:Pogoprotos.Data.Battle.BattlePokemonInfo) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        if builderResult.hasActiveDefender {
          builderResult.activeDefender = try Pogoprotos.Data.Battle.BattlePokemonInfo.builderWithPrototype(prototype:builderResult.activeDefender).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.activeDefender = value
        }
        builderResult.hasActiveDefender = true
        return self
      }
      @discardableResult
      public func clearActiveDefender() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        activeDefenderBuilder_ = nil
        builderResult.hasActiveDefender = false
        builderResult.activeDefender = nil
        return self
      }
      public var hasActiveAttacker:Bool {
           get {
               return builderResult.hasActiveAttacker
           }
      }
      public var activeAttacker:Pogoprotos.Data.Battle.BattlePokemonInfo! {
           get {
               if activeAttackerBuilder_ != nil {
                  builderResult.activeAttacker = activeAttackerBuilder_.getMessage()
               }
               return builderResult.activeAttacker
           }
           set (value) {
               builderResult.hasActiveAttacker = true
               builderResult.activeAttacker = value
           }
      }
      fileprivate var activeAttackerBuilder_:Pogoprotos.Data.Battle.BattlePokemonInfo.Builder! {
           didSet {
              builderResult.hasActiveAttacker = true
           }
      }
      public func getActiveAttackerBuilder() -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        if activeAttackerBuilder_ == nil {
           activeAttackerBuilder_ = Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
           builderResult.activeAttacker = activeAttackerBuilder_.getMessage()
           if activeAttacker != nil {
              try! activeAttackerBuilder_.mergeFrom(other: activeAttacker)
           }
        }
        return activeAttackerBuilder_
      }
      @discardableResult
      public func setActiveAttacker(_ value:Pogoprotos.Data.Battle.BattlePokemonInfo!) -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        self.activeAttacker = value
        return self
      }
      @discardableResult
      public func mergeActiveAttacker(value:Pogoprotos.Data.Battle.BattlePokemonInfo) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        if builderResult.hasActiveAttacker {
          builderResult.activeAttacker = try Pogoprotos.Data.Battle.BattlePokemonInfo.builderWithPrototype(prototype:builderResult.activeAttacker).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.activeAttacker = value
        }
        builderResult.hasActiveAttacker = true
        return self
      }
      @discardableResult
      public func clearActiveAttacker() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        activeAttackerBuilder_ = nil
        builderResult.hasActiveAttacker = false
        builderResult.activeAttacker = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.AttackGymResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        return try Pogoprotos.Networking.Responses.AttackGymResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.AttackGymResponse {
        let returnMe:Pogoprotos.Networking.Responses.AttackGymResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.AttackGymResponse) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        if other == Pogoprotos.Networking.Responses.AttackGymResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasBattleLog) {
            try mergeBattleLog(value: other.battleLog)
        }
        if other.hasBattleId {
             battleId = other.battleId
        }
        if (other.hasActiveDefender) {
            try mergeActiveDefender(value: other.activeDefender)
        }
        if (other.hasActiveAttacker) {
            try mergeActiveAttacker(value: other.activeAttacker)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.AttackGymResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.Battle.BattleLog.Builder = Pogoprotos.Data.Battle.BattleLog.Builder()
            if hasBattleLog {
              try subBuilder.mergeFrom(other: battleLog)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            battleLog = subBuilder.buildPartial()

          case 26:
            battleId = try codedInputStream.readString()

          case 34:
            let subBuilder:Pogoprotos.Data.Battle.BattlePokemonInfo.Builder = Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
            if hasActiveDefender {
              try subBuilder.mergeFrom(other: activeDefender)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            activeDefender = subBuilder.buildPartial()

          case 42:
            let subBuilder:Pogoprotos.Data.Battle.BattlePokemonInfo.Builder = Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
            if hasActiveAttacker {
              try subBuilder.mergeFrom(other: activeAttacker)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            activeAttacker = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.AttackGymResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.AttackGymResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueBattleLog = jsonMap["battleLog"] as? Dictionary<String,Any> {
          resultDecodedBuilder.battleLog = try Pogoprotos.Data.Battle.BattleLog.Builder.decodeToBuilder(jsonMap:jsonValueBattleLog).build()

        }
        if let jsonValueBattleId = jsonMap["battleId"] as? String {
          resultDecodedBuilder.battleId = jsonValueBattleId
        }
        if let jsonValueActiveDefender = jsonMap["activeDefender"] as? Dictionary<String,Any> {
          resultDecodedBuilder.activeDefender = try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder.decodeToBuilder(jsonMap:jsonValueActiveDefender).build()

        }
        if let jsonValueActiveAttacker = jsonMap["activeAttacker"] as? Dictionary<String,Any> {
          resultDecodedBuilder.activeAttacker = try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder.decodeToBuilder(jsonMap:jsonValueActiveAttacker).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class CatchPokemonResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.CatchPokemonResponse, rhs: Pogoprotos.Networking.Responses.CatchPokemonResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
      fieldCheck = fieldCheck && (lhs.hasMissPercent == rhs.hasMissPercent) && (!lhs.hasMissPercent || lhs.missPercent == rhs.missPercent)
      fieldCheck = fieldCheck && (lhs.hasCapturedPokemonId == rhs.hasCapturedPokemonId) && (!lhs.hasCapturedPokemonId || lhs.capturedPokemonId == rhs.capturedPokemonId)
      fieldCheck = fieldCheck && (lhs.hasCaptureAward == rhs.hasCaptureAward) && (!lhs.hasCaptureAward || lhs.captureAward == rhs.captureAward)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum CatchStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case catchError = 0
        case catchSuccess = 1
        case catchEscape = 2
        case catchFlee = 3
        case catchMissed = 4
        public func toString() -> String {
          switch self {
          case .catchError: return "CATCH_ERROR"
          case .catchSuccess: return "CATCH_SUCCESS"
          case .catchEscape: return "CATCH_ESCAPE"
          case .catchFlee: return "CATCH_FLEE"
          case .catchMissed: return "CATCH_MISSED"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.CatchStatus {
          switch str {
          case "CATCH_ERROR":  return .catchError
          case "CATCH_SUCCESS":  return .catchSuccess
          case "CATCH_ESCAPE":  return .catchEscape
          case "CATCH_FLEE":  return .catchFlee
          case "CATCH_MISSED":  return .catchMissed
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .catchError: return ".catchError"
          case .catchSuccess: return ".catchSuccess"
          case .catchEscape: return ".catchEscape"
          case .catchFlee: return ".catchFlee"
          case .catchMissed: return ".catchMissed"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var status:Pogoprotos.Networking.Responses.CatchPokemonResponse.CatchStatus = Pogoprotos.Networking.Responses.CatchPokemonResponse.CatchStatus.catchError
    public fileprivate(set) var hasStatus:Bool = false
    public fileprivate(set) var missPercent:Double = Double(0)
    public fileprivate(set) var hasMissPercent:Bool = false

    public fileprivate(set) var capturedPokemonId:UInt64 = UInt64(0)
    public fileprivate(set) var hasCapturedPokemonId:Bool = false

    public fileprivate(set) var captureAward:Pogoprotos.Data.Capture.CaptureAward!
    public fileprivate(set) var hasCaptureAward:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasStatus {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:status.rawValue)
      }
      if hasMissPercent {
        try codedOutputStream.writeDouble(fieldNumber: 2, value:missPercent)
      }
      if hasCapturedPokemonId {
        try codedOutputStream.writeFixed64(fieldNumber: 3, value:capturedPokemonId)
      }
      if hasCaptureAward {
        try codedOutputStream.writeMessage(fieldNumber: 4, value:captureAward)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasMissPercent {
        serialize_size += missPercent.computeDoubleSize(fieldNumber: 2)
      }
      if hasCapturedPokemonId {
        serialize_size += capturedPokemonId.computeFixed64Size(fieldNumber: 3)
      }
      if hasCaptureAward {
          if let varSizecaptureAward = captureAward?.computeMessageSize(fieldNumber: 4) {
              serialize_size += varSizecaptureAward
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.CatchPokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.CatchPokemonResponse) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      if hasMissPercent {
        jsonMap["missPercent"] = Double(missPercent)
      }
      if hasCapturedPokemonId {
        jsonMap["capturedPokemonId"] = "\(capturedPokemonId)"
      }
      if hasCaptureAward {
        jsonMap["captureAward"] = try captureAward.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      if hasMissPercent {
        output += "\(indent) missPercent: \(missPercent) \n"
      }
      if hasCapturedPokemonId {
        output += "\(indent) capturedPokemonId: \(capturedPokemonId) \n"
      }
      if hasCaptureAward {
        output += "\(indent) captureAward {\n"
        if let outDescCaptureAward = captureAward {
          output += try outDescCaptureAward.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            if hasMissPercent {
               hashCode = (hashCode &* 31) &+ missPercent.hashValue
            }
            if hasCapturedPokemonId {
               hashCode = (hashCode &* 31) &+ capturedPokemonId.hashValue
            }
            if hasCaptureAward {
                if let hashValuecaptureAward = captureAward?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecaptureAward
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.CatchPokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.CatchPokemonResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.CatchPokemonResponse = Pogoprotos.Networking.Responses.CatchPokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Networking.Responses.CatchPokemonResponse.CatchStatus {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
      @discardableResult
        public func setStatus(_ value:Pogoprotos.Networking.Responses.CatchPokemonResponse.CatchStatus) -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
          self.status = value
          return self
        }
      @discardableResult
        public func clearStatus() -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .catchError
           return self
        }
      public var hasMissPercent:Bool {
           get {
                return builderResult.hasMissPercent
           }
      }
      public var missPercent:Double {
           get {
                return builderResult.missPercent
           }
           set (value) {
               builderResult.hasMissPercent = true
               builderResult.missPercent = value
           }
      }
      @discardableResult
      public func setMissPercent(_ value:Double) -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        self.missPercent = value
        return self
      }
      @discardableResult
      public func clearMissPercent() -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder{
           builderResult.hasMissPercent = false
           builderResult.missPercent = Double(0)
           return self
      }
      public var hasCapturedPokemonId:Bool {
           get {
                return builderResult.hasCapturedPokemonId
           }
      }
      public var capturedPokemonId:UInt64 {
           get {
                return builderResult.capturedPokemonId
           }
           set (value) {
               builderResult.hasCapturedPokemonId = true
               builderResult.capturedPokemonId = value
           }
      }
      @discardableResult
      public func setCapturedPokemonId(_ value:UInt64) -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        self.capturedPokemonId = value
        return self
      }
      @discardableResult
      public func clearCapturedPokemonId() -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder{
           builderResult.hasCapturedPokemonId = false
           builderResult.capturedPokemonId = UInt64(0)
           return self
      }
      public var hasCaptureAward:Bool {
           get {
               return builderResult.hasCaptureAward
           }
      }
      public var captureAward:Pogoprotos.Data.Capture.CaptureAward! {
           get {
               if captureAwardBuilder_ != nil {
                  builderResult.captureAward = captureAwardBuilder_.getMessage()
               }
               return builderResult.captureAward
           }
           set (value) {
               builderResult.hasCaptureAward = true
               builderResult.captureAward = value
           }
      }
      fileprivate var captureAwardBuilder_:Pogoprotos.Data.Capture.CaptureAward.Builder! {
           didSet {
              builderResult.hasCaptureAward = true
           }
      }
      public func getCaptureAwardBuilder() -> Pogoprotos.Data.Capture.CaptureAward.Builder {
        if captureAwardBuilder_ == nil {
           captureAwardBuilder_ = Pogoprotos.Data.Capture.CaptureAward.Builder()
           builderResult.captureAward = captureAwardBuilder_.getMessage()
           if captureAward != nil {
              try! captureAwardBuilder_.mergeFrom(other: captureAward)
           }
        }
        return captureAwardBuilder_
      }
      @discardableResult
      public func setCaptureAward(_ value:Pogoprotos.Data.Capture.CaptureAward!) -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        self.captureAward = value
        return self
      }
      @discardableResult
      public func mergeCaptureAward(value:Pogoprotos.Data.Capture.CaptureAward) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        if builderResult.hasCaptureAward {
          builderResult.captureAward = try Pogoprotos.Data.Capture.CaptureAward.builderWithPrototype(prototype:builderResult.captureAward).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.captureAward = value
        }
        builderResult.hasCaptureAward = true
        return self
      }
      @discardableResult
      public func clearCaptureAward() -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        captureAwardBuilder_ = nil
        builderResult.hasCaptureAward = false
        builderResult.captureAward = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.CatchPokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.CatchPokemonResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.CatchPokemonResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.CatchPokemonResponse) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.CatchPokemonResponse() {
         return self
        }
        if other.hasStatus {
             status = other.status
        }
        if other.hasMissPercent {
             missPercent = other.missPercent
        }
        if other.hasCapturedPokemonId {
             capturedPokemonId = other.capturedPokemonId
        }
        if (other.hasCaptureAward) {
            try mergeCaptureAward(value: other.captureAward)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntstatus = try codedInputStream.readEnum()
            if let enumsstatus = Pogoprotos.Networking.Responses.CatchPokemonResponse.CatchStatus(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntstatus))
            }

          case 17:
            missPercent = try codedInputStream.readDouble()

          case 25:
            capturedPokemonId = try codedInputStream.readFixed64()

          case 34:
            let subBuilder:Pogoprotos.Data.Capture.CaptureAward.Builder = Pogoprotos.Data.Capture.CaptureAward.Builder()
            if hasCaptureAward {
              try subBuilder.mergeFrom(other: captureAward)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            captureAward = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder()
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Networking.Responses.CatchPokemonResponse.CatchStatus.fromString(str: jsonValueStatus)
        }
        if let jsonValueMissPercent = jsonMap["missPercent"] as? Double {
          resultDecodedBuilder.missPercent = Double(jsonValueMissPercent)
        }
        if let jsonValueCapturedPokemonId = jsonMap["capturedPokemonId"] as? String {
          resultDecodedBuilder.capturedPokemonId = UInt64(jsonValueCapturedPokemonId)!
        }
        if let jsonValueCaptureAward = jsonMap["captureAward"] as? Dictionary<String,Any> {
          resultDecodedBuilder.captureAward = try Pogoprotos.Data.Capture.CaptureAward.Builder.decodeToBuilder(jsonMap:jsonValueCaptureAward).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class CheckAwardedBadgesResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse, rhs: Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
      fieldCheck = fieldCheck && (lhs.awardedBadges == rhs.awardedBadges)
      fieldCheck = fieldCheck && (lhs.awardedBadgeLevels == rhs.awardedBadgeLevels)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var success:Bool = false
    public fileprivate(set) var hasSuccess:Bool = false

    private var awardedBadgesMemoizedSerializedSize:Int32 = 0
    public fileprivate(set) var awardedBadges:Array<Pogoprotos.Enums.BadgeType> = Array<Pogoprotos.Enums.BadgeType>()
    public fileprivate(set) var awardedBadgeLevels:Array<Int32> = Array<Int32>()
    private var awardedBadgeLevelsMemoizedSerializedSize:Int32 = -1
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasSuccess {
        try codedOutputStream.writeBool(fieldNumber: 1, value:success)
      }
      if !awardedBadges.isEmpty {
        try codedOutputStream.writeRawVarint32(value: 18)
        try codedOutputStream.writeRawVarint32(value: awardedBadgesMemoizedSerializedSize)
      }
      for oneValueOfawardedBadges in awardedBadges {
          try codedOutputStream.writeEnumNoTag(value: oneValueOfawardedBadges.rawValue)
      }
      if !awardedBadgeLevels.isEmpty {
        try codedOutputStream.writeRawVarint32(value: 26)
        try codedOutputStream.writeRawVarint32(value: awardedBadgeLevelsMemoizedSerializedSize)
        for oneValueawardedBadgeLevels in awardedBadgeLevels {
          try codedOutputStream.writeInt32NoTag(value: oneValueawardedBadgeLevels)
        }
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(fieldNumber: 1)
      }
      var dataSizeawardedBadges:Int32 = 0
      for oneValueOfawardedBadges in awardedBadges {
          dataSizeawardedBadges += oneValueOfawardedBadges.rawValue.computeEnumSizeNoTag()
      }
      serialize_size += dataSizeawardedBadges
      if !awardedBadges.isEmpty {
        serialize_size += 1
        serialize_size += dataSizeawardedBadges.computeRawVarint32Size()
      }
      awardedBadgesMemoizedSerializedSize = dataSizeawardedBadges
      var dataSizeAwardedBadgeLevels:Int32 = 0
      for oneValueawardedBadgeLevels in awardedBadgeLevels {
          dataSizeAwardedBadgeLevels += oneValueawardedBadgeLevels.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeAwardedBadgeLevels
      if !awardedBadgeLevels.isEmpty {
        serialize_size += 1
        serialize_size += dataSizeAwardedBadgeLevels.computeInt32SizeNoTag()
      }
      awardedBadgeLevelsMemoizedSerializedSize = dataSizeAwardedBadgeLevels
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
      return Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.classBuilder() as! Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if !awardedBadges.isEmpty {
        var jsonArrayAwardedBadges:Array<String> = []
          for oneValueAwardedBadges in awardedBadges {
            jsonArrayAwardedBadges.append(oneValueAwardedBadges.toString())
          }
        jsonMap["awardedBadges"] = jsonArrayAwardedBadges
      }
      if !awardedBadgeLevels.isEmpty {
        var jsonArrayAwardedBadgeLevels:Array<Int> = []
          for oneValueAwardedBadgeLevels in awardedBadgeLevels {
            jsonArrayAwardedBadgeLevels.append(Int(oneValueAwardedBadgeLevels))
          }
        jsonMap["awardedBadgeLevels"] = jsonArrayAwardedBadgeLevels
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      var awardedBadgesElementIndex:Int = 0
      for oneValueOfawardedBadges in awardedBadges {
          output += "\(indent) awardedBadges[\(awardedBadgesElementIndex)]: \(oneValueOfawardedBadges.description)\n"
          awardedBadgesElementIndex += 1
      }
      var awardedBadgeLevelsElementIndex:Int = 0
      for oneValueAwardedBadgeLevels in awardedBadgeLevels  {
          output += "\(indent) awardedBadgeLevels[\(awardedBadgeLevelsElementIndex)]: \(oneValueAwardedBadgeLevels)\n"
          awardedBadgeLevelsElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            for oneValueOfawardedBadges in awardedBadges {
                hashCode = (hashCode &* 31) &+ Int(oneValueOfawardedBadges.rawValue)
            }
            for oneValueAwardedBadgeLevels in awardedBadgeLevels {
                hashCode = (hashCode &* 31) &+ oneValueAwardedBadgeLevels.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse = Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      @discardableResult
      public func setSuccess(_ value:Bool) -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        self.success = value
        return self
      }
      @discardableResult
      public func clearSuccess() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var awardedBadges:Array<Pogoprotos.Enums.BadgeType> {
          get {
              return builderResult.awardedBadges
          }
          set (value) {
              builderResult.awardedBadges = value
          }
      }
      @discardableResult
      public func setAwardedBadges(_ value:Array<Pogoprotos.Enums.BadgeType>) -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        self.awardedBadges = value
        return self
      }
      @discardableResult
      public func clearAwardedBadges() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        builderResult.awardedBadges.removeAll(keepingCapacity: false)
        return self
      }
      public var awardedBadgeLevels:Array<Int32> {
           get {
               return builderResult.awardedBadgeLevels
           }
           set (array) {
               builderResult.awardedBadgeLevels = array
           }
      }
      @discardableResult
      public func setAwardedBadgeLevels(_ value:Array<Int32>) -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        self.awardedBadgeLevels = value
        return self
      }
      @discardableResult
      public func clearAwardedBadgeLevels() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
         builderResult.awardedBadgeLevels.removeAll(keepingCapacity: false)
         return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
        let returnMe:Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        if other == Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if !other.awardedBadges.isEmpty {
           builderResult.awardedBadges += other.awardedBadges
        }
        if !other.awardedBadgeLevels.isEmpty {
            builderResult.awardedBadgeLevels += other.awardedBadgeLevels
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try codedInputStream.readBool()

          case 18:
            let length = Int(try codedInputStream.readRawVarint32())
            let oldLimit = try codedInputStream.pushLimit(byteLimit: length)
            while codedInputStream.bytesUntilLimit() > 0 {
            let valueIntawardedBadges = try codedInputStream.readEnum()
            if let enumsawardedBadges = Pogoprotos.Enums.BadgeType(rawValue:valueIntawardedBadges) {
                 builderResult.awardedBadges.append(enumsawardedBadges)
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntawardedBadges))
            }
            }
            codedInputStream.popLimit(oldLimit: oldLimit)

          case 26:
            let length = Int(try codedInputStream.readRawVarint32())
            let limit = try codedInputStream.pushLimit(byteLimit: length)
            while (codedInputStream.bytesUntilLimit() > 0) {
              builderResult.awardedBadgeLevels.append(try codedInputStream.readInt32())
            }
            codedInputStream.popLimit(oldLimit: limit)

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValueAwardedBadges = jsonMap["awardedBadges"] as? Array<String> {
          var jsonArrayAwardedBadges:Array<Pogoprotos.Enums.BadgeType> = []
          for oneValueAwardedBadges in jsonValueAwardedBadges {
            let enumFromStringAwardedBadges = try Pogoprotos.Enums.BadgeType.fromString(str: oneValueAwardedBadges)
            jsonArrayAwardedBadges.append(enumFromStringAwardedBadges)
          }
          resultDecodedBuilder.awardedBadges = jsonArrayAwardedBadges
        }
        if let jsonValueAwardedBadgeLevels = jsonMap["awardedBadgeLevels"] as? Array<Int> {
          var jsonArrayAwardedBadgeLevels:Array<Int32> = []
          for oneValueAwardedBadgeLevels in jsonValueAwardedBadgeLevels {
            jsonArrayAwardedBadgeLevels.append(Int32(oneValueAwardedBadgeLevels))
          }
          resultDecodedBuilder.awardedBadgeLevels = jsonArrayAwardedBadgeLevels
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class CheckChallengeResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.CheckChallengeResponse, rhs: Pogoprotos.Networking.Responses.CheckChallengeResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasShowChallenge == rhs.hasShowChallenge) && (!lhs.hasShowChallenge || lhs.showChallenge == rhs.showChallenge)
      fieldCheck = fieldCheck && (lhs.hasChallengeUrl == rhs.hasChallengeUrl) && (!lhs.hasChallengeUrl || lhs.challengeUrl == rhs.challengeUrl)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var showChallenge:Bool = false
    public fileprivate(set) var hasShowChallenge:Bool = false

    public fileprivate(set) var challengeUrl:String = ""
    public fileprivate(set) var hasChallengeUrl:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasShowChallenge {
        try codedOutputStream.writeBool(fieldNumber: 1, value:showChallenge)
      }
      if hasChallengeUrl {
        try codedOutputStream.writeString(fieldNumber: 2, value:challengeUrl)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasShowChallenge {
        serialize_size += showChallenge.computeBoolSize(fieldNumber: 1)
      }
      if hasChallengeUrl {
        serialize_size += challengeUrl.computeStringSize(fieldNumber: 2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder {
      return Pogoprotos.Networking.Responses.CheckChallengeResponse.classBuilder() as! Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder {
      return try Pogoprotos.Networking.Responses.CheckChallengeResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.CheckChallengeResponse) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder {
      return try Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasShowChallenge {
        jsonMap["showChallenge"] = showChallenge
      }
      if hasChallengeUrl {
        jsonMap["challengeUrl"] = challengeUrl
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse {
      return try Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse {
      return try Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasShowChallenge {
        output += "\(indent) showChallenge: \(showChallenge) \n"
      }
      if hasChallengeUrl {
        output += "\(indent) challengeUrl: \(challengeUrl) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasShowChallenge {
               hashCode = (hashCode &* 31) &+ showChallenge.hashValue
            }
            if hasChallengeUrl {
               hashCode = (hashCode &* 31) &+ challengeUrl.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.CheckChallengeResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.CheckChallengeResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.CheckChallengeResponse = Pogoprotos.Networking.Responses.CheckChallengeResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.CheckChallengeResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasShowChallenge:Bool {
           get {
                return builderResult.hasShowChallenge
           }
      }
      public var showChallenge:Bool {
           get {
                return builderResult.showChallenge
           }
           set (value) {
               builderResult.hasShowChallenge = true
               builderResult.showChallenge = value
           }
      }
      @discardableResult
      public func setShowChallenge(_ value:Bool) -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder {
        self.showChallenge = value
        return self
      }
      @discardableResult
      public func clearShowChallenge() -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder{
           builderResult.hasShowChallenge = false
           builderResult.showChallenge = false
           return self
      }
      public var hasChallengeUrl:Bool {
           get {
                return builderResult.hasChallengeUrl
           }
      }
      public var challengeUrl:String {
           get {
                return builderResult.challengeUrl
           }
           set (value) {
               builderResult.hasChallengeUrl = true
               builderResult.challengeUrl = value
           }
      }
      @discardableResult
      public func setChallengeUrl(_ value:String) -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder {
        self.challengeUrl = value
        return self
      }
      @discardableResult
      public func clearChallengeUrl() -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder{
           builderResult.hasChallengeUrl = false
           builderResult.challengeUrl = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.CheckChallengeResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder {
        return try Pogoprotos.Networking.Responses.CheckChallengeResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.CheckChallengeResponse {
        let returnMe:Pogoprotos.Networking.Responses.CheckChallengeResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.CheckChallengeResponse) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder {
        if other == Pogoprotos.Networking.Responses.CheckChallengeResponse() {
         return self
        }
        if other.hasShowChallenge {
             showChallenge = other.showChallenge
        }
        if other.hasChallengeUrl {
             challengeUrl = other.challengeUrl
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            showChallenge = try codedInputStream.readBool()

          case 18:
            challengeUrl = try codedInputStream.readString()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder()
        if let jsonValueShowChallenge = jsonMap["showChallenge"] as? Bool {
          resultDecodedBuilder.showChallenge = jsonValueShowChallenge
        }
        if let jsonValueChallengeUrl = jsonMap["challengeUrl"] as? String {
          resultDecodedBuilder.challengeUrl = jsonValueChallengeUrl
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class CheckCodenameAvailableResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse, rhs: Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasCodename == rhs.hasCodename) && (!lhs.hasCodename || lhs.codename == rhs.codename)
      fieldCheck = fieldCheck && (lhs.hasUserMessage == rhs.hasUserMessage) && (!lhs.hasUserMessage || lhs.userMessage == rhs.userMessage)
      fieldCheck = fieldCheck && (lhs.hasIsAssignable == rhs.hasIsAssignable) && (!lhs.hasIsAssignable || lhs.isAssignable == rhs.isAssignable)
      fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Status:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case codenameNotAvailable = 2
        case codenameNotValid = 3
        case currentOwner = 4
        case codenameChangeNotAllowed = 5
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .codenameNotAvailable: return "CODENAME_NOT_AVAILABLE"
          case .codenameNotValid: return "CODENAME_NOT_VALID"
          case .currentOwner: return "CURRENT_OWNER"
          case .codenameChangeNotAllowed: return "CODENAME_CHANGE_NOT_ALLOWED"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Status {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "CODENAME_NOT_AVAILABLE":  return .codenameNotAvailable
          case "CODENAME_NOT_VALID":  return .codenameNotValid
          case "CURRENT_OWNER":  return .currentOwner
          case "CODENAME_CHANGE_NOT_ALLOWED":  return .codenameChangeNotAllowed
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .codenameNotAvailable: return ".codenameNotAvailable"
          case .codenameNotValid: return ".codenameNotValid"
          case .currentOwner: return ".currentOwner"
          case .codenameChangeNotAllowed: return ".codenameChangeNotAllowed"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var codename:String = ""
    public fileprivate(set) var hasCodename:Bool = false

    public fileprivate(set) var userMessage:String = ""
    public fileprivate(set) var hasUserMessage:Bool = false

    public fileprivate(set) var isAssignable:Bool = false
    public fileprivate(set) var hasIsAssignable:Bool = false

    public fileprivate(set) var status:Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Status = Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Status.unset
    public fileprivate(set) var hasStatus:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasCodename {
        try codedOutputStream.writeString(fieldNumber: 1, value:codename)
      }
      if hasUserMessage {
        try codedOutputStream.writeString(fieldNumber: 2, value:userMessage)
      }
      if hasIsAssignable {
        try codedOutputStream.writeBool(fieldNumber: 3, value:isAssignable)
      }
      if hasStatus {
        try codedOutputStream.writeEnum(fieldNumber: 4, value:status.rawValue)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasCodename {
        serialize_size += codename.computeStringSize(fieldNumber: 1)
      }
      if hasUserMessage {
        serialize_size += userMessage.computeStringSize(fieldNumber: 2)
      }
      if hasIsAssignable {
        serialize_size += isAssignable.computeBoolSize(fieldNumber: 3)
      }
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(fieldNumber: 4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
      return Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.classBuilder() as! Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasCodename {
        jsonMap["codename"] = codename
      }
      if hasUserMessage {
        jsonMap["userMessage"] = userMessage
      }
      if hasIsAssignable {
        jsonMap["isAssignable"] = isAssignable
      }
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasCodename {
        output += "\(indent) codename: \(codename) \n"
      }
      if hasUserMessage {
        output += "\(indent) userMessage: \(userMessage) \n"
      }
      if hasIsAssignable {
        output += "\(indent) isAssignable: \(isAssignable) \n"
      }
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasCodename {
               hashCode = (hashCode &* 31) &+ codename.hashValue
            }
            if hasUserMessage {
               hashCode = (hashCode &* 31) &+ userMessage.hashValue
            }
            if hasIsAssignable {
               hashCode = (hashCode &* 31) &+ isAssignable.hashValue
            }
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse = Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasCodename:Bool {
           get {
                return builderResult.hasCodename
           }
      }
      public var codename:String {
           get {
                return builderResult.codename
           }
           set (value) {
               builderResult.hasCodename = true
               builderResult.codename = value
           }
      }
      @discardableResult
      public func setCodename(_ value:String) -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        self.codename = value
        return self
      }
      @discardableResult
      public func clearCodename() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder{
           builderResult.hasCodename = false
           builderResult.codename = ""
           return self
      }
      public var hasUserMessage:Bool {
           get {
                return builderResult.hasUserMessage
           }
      }
      public var userMessage:String {
           get {
                return builderResult.userMessage
           }
           set (value) {
               builderResult.hasUserMessage = true
               builderResult.userMessage = value
           }
      }
      @discardableResult
      public func setUserMessage(_ value:String) -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        self.userMessage = value
        return self
      }
      @discardableResult
      public func clearUserMessage() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder{
           builderResult.hasUserMessage = false
           builderResult.userMessage = ""
           return self
      }
      public var hasIsAssignable:Bool {
           get {
                return builderResult.hasIsAssignable
           }
      }
      public var isAssignable:Bool {
           get {
                return builderResult.isAssignable
           }
           set (value) {
               builderResult.hasIsAssignable = true
               builderResult.isAssignable = value
           }
      }
      @discardableResult
      public func setIsAssignable(_ value:Bool) -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        self.isAssignable = value
        return self
      }
      @discardableResult
      public func clearIsAssignable() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder{
           builderResult.hasIsAssignable = false
           builderResult.isAssignable = false
           return self
      }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Status {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
      @discardableResult
        public func setStatus(_ value:Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Status) -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
          self.status = value
          return self
        }
      @discardableResult
        public func clearStatus() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .unset
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
        let returnMe:Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        if other == Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse() {
         return self
        }
        if other.hasCodename {
             codename = other.codename
        }
        if other.hasUserMessage {
             userMessage = other.userMessage
        }
        if other.hasIsAssignable {
             isAssignable = other.isAssignable
        }
        if other.hasStatus {
             status = other.status
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            codename = try codedInputStream.readString()

          case 18:
            userMessage = try codedInputStream.readString()

          case 24:
            isAssignable = try codedInputStream.readBool()

          case 32:
            let valueIntstatus = try codedInputStream.readEnum()
            if let enumsstatus = Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Status(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntstatus))
            }

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder()
        if let jsonValueCodename = jsonMap["codename"] as? String {
          resultDecodedBuilder.codename = jsonValueCodename
        }
        if let jsonValueUserMessage = jsonMap["userMessage"] as? String {
          resultDecodedBuilder.userMessage = jsonValueUserMessage
        }
        if let jsonValueIsAssignable = jsonMap["isAssignable"] as? Bool {
          resultDecodedBuilder.isAssignable = jsonValueIsAssignable
        }
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Status.fromString(str: jsonValueStatus)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class ClaimCodenameResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.ClaimCodenameResponse, rhs: Pogoprotos.Networking.Responses.ClaimCodenameResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasCodename == rhs.hasCodename) && (!lhs.hasCodename || lhs.codename == rhs.codename)
      fieldCheck = fieldCheck && (lhs.hasUserMessage == rhs.hasUserMessage) && (!lhs.hasUserMessage || lhs.userMessage == rhs.userMessage)
      fieldCheck = fieldCheck && (lhs.hasIsAssignable == rhs.hasIsAssignable) && (!lhs.hasIsAssignable || lhs.isAssignable == rhs.isAssignable)
      fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
      fieldCheck = fieldCheck && (lhs.hasUpdatedPlayer == rhs.hasUpdatedPlayer) && (!lhs.hasUpdatedPlayer || lhs.updatedPlayer == rhs.updatedPlayer)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Status:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case codenameNotAvailable = 2
        case codenameNotValid = 3
        case currentOwner = 4
        case codenameChangeNotAllowed = 5
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .codenameNotAvailable: return "CODENAME_NOT_AVAILABLE"
          case .codenameNotValid: return "CODENAME_NOT_VALID"
          case .currentOwner: return "CURRENT_OWNER"
          case .codenameChangeNotAllowed: return "CODENAME_CHANGE_NOT_ALLOWED"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Status {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "CODENAME_NOT_AVAILABLE":  return .codenameNotAvailable
          case "CODENAME_NOT_VALID":  return .codenameNotValid
          case "CURRENT_OWNER":  return .currentOwner
          case "CODENAME_CHANGE_NOT_ALLOWED":  return .codenameChangeNotAllowed
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .codenameNotAvailable: return ".codenameNotAvailable"
          case .codenameNotValid: return ".codenameNotValid"
          case .currentOwner: return ".currentOwner"
          case .codenameChangeNotAllowed: return ".codenameChangeNotAllowed"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var codename:String = ""
    public fileprivate(set) var hasCodename:Bool = false

    public fileprivate(set) var userMessage:String = ""
    public fileprivate(set) var hasUserMessage:Bool = false

    public fileprivate(set) var isAssignable:Bool = false
    public fileprivate(set) var hasIsAssignable:Bool = false

    public fileprivate(set) var status:Pogoprotos.Networking.Responses.ClaimCodenameResponse.Status = Pogoprotos.Networking.Responses.ClaimCodenameResponse.Status.unset
    public fileprivate(set) var hasStatus:Bool = false
    public fileprivate(set) var updatedPlayer:Pogoprotos.Data.PlayerData!
    public fileprivate(set) var hasUpdatedPlayer:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasCodename {
        try codedOutputStream.writeString(fieldNumber: 1, value:codename)
      }
      if hasUserMessage {
        try codedOutputStream.writeString(fieldNumber: 2, value:userMessage)
      }
      if hasIsAssignable {
        try codedOutputStream.writeBool(fieldNumber: 3, value:isAssignable)
      }
      if hasStatus {
        try codedOutputStream.writeEnum(fieldNumber: 4, value:status.rawValue)
      }
      if hasUpdatedPlayer {
        try codedOutputStream.writeMessage(fieldNumber: 5, value:updatedPlayer)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasCodename {
        serialize_size += codename.computeStringSize(fieldNumber: 1)
      }
      if hasUserMessage {
        serialize_size += userMessage.computeStringSize(fieldNumber: 2)
      }
      if hasIsAssignable {
        serialize_size += isAssignable.computeBoolSize(fieldNumber: 3)
      }
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(fieldNumber: 4)
      }
      if hasUpdatedPlayer {
          if let varSizeupdatedPlayer = updatedPlayer?.computeMessageSize(fieldNumber: 5) {
              serialize_size += varSizeupdatedPlayer
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
      return Pogoprotos.Networking.Responses.ClaimCodenameResponse.classBuilder() as! Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.ClaimCodenameResponse) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasCodename {
        jsonMap["codename"] = codename
      }
      if hasUserMessage {
        jsonMap["userMessage"] = userMessage
      }
      if hasIsAssignable {
        jsonMap["isAssignable"] = isAssignable
      }
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      if hasUpdatedPlayer {
        jsonMap["updatedPlayer"] = try updatedPlayer.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasCodename {
        output += "\(indent) codename: \(codename) \n"
      }
      if hasUserMessage {
        output += "\(indent) userMessage: \(userMessage) \n"
      }
      if hasIsAssignable {
        output += "\(indent) isAssignable: \(isAssignable) \n"
      }
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      if hasUpdatedPlayer {
        output += "\(indent) updatedPlayer {\n"
        if let outDescUpdatedPlayer = updatedPlayer {
          output += try outDescUpdatedPlayer.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasCodename {
               hashCode = (hashCode &* 31) &+ codename.hashValue
            }
            if hasUserMessage {
               hashCode = (hashCode &* 31) &+ userMessage.hashValue
            }
            if hasIsAssignable {
               hashCode = (hashCode &* 31) &+ isAssignable.hashValue
            }
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            if hasUpdatedPlayer {
                if let hashValueupdatedPlayer = updatedPlayer?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueupdatedPlayer
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.ClaimCodenameResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.ClaimCodenameResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.ClaimCodenameResponse = Pogoprotos.Networking.Responses.ClaimCodenameResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasCodename:Bool {
           get {
                return builderResult.hasCodename
           }
      }
      public var codename:String {
           get {
                return builderResult.codename
           }
           set (value) {
               builderResult.hasCodename = true
               builderResult.codename = value
           }
      }
      @discardableResult
      public func setCodename(_ value:String) -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        self.codename = value
        return self
      }
      @discardableResult
      public func clearCodename() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder{
           builderResult.hasCodename = false
           builderResult.codename = ""
           return self
      }
      public var hasUserMessage:Bool {
           get {
                return builderResult.hasUserMessage
           }
      }
      public var userMessage:String {
           get {
                return builderResult.userMessage
           }
           set (value) {
               builderResult.hasUserMessage = true
               builderResult.userMessage = value
           }
      }
      @discardableResult
      public func setUserMessage(_ value:String) -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        self.userMessage = value
        return self
      }
      @discardableResult
      public func clearUserMessage() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder{
           builderResult.hasUserMessage = false
           builderResult.userMessage = ""
           return self
      }
      public var hasIsAssignable:Bool {
           get {
                return builderResult.hasIsAssignable
           }
      }
      public var isAssignable:Bool {
           get {
                return builderResult.isAssignable
           }
           set (value) {
               builderResult.hasIsAssignable = true
               builderResult.isAssignable = value
           }
      }
      @discardableResult
      public func setIsAssignable(_ value:Bool) -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        self.isAssignable = value
        return self
      }
      @discardableResult
      public func clearIsAssignable() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder{
           builderResult.hasIsAssignable = false
           builderResult.isAssignable = false
           return self
      }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Networking.Responses.ClaimCodenameResponse.Status {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
      @discardableResult
        public func setStatus(_ value:Pogoprotos.Networking.Responses.ClaimCodenameResponse.Status) -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
          self.status = value
          return self
        }
      @discardableResult
        public func clearStatus() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .unset
           return self
        }
      public var hasUpdatedPlayer:Bool {
           get {
               return builderResult.hasUpdatedPlayer
           }
      }
      public var updatedPlayer:Pogoprotos.Data.PlayerData! {
           get {
               if updatedPlayerBuilder_ != nil {
                  builderResult.updatedPlayer = updatedPlayerBuilder_.getMessage()
               }
               return builderResult.updatedPlayer
           }
           set (value) {
               builderResult.hasUpdatedPlayer = true
               builderResult.updatedPlayer = value
           }
      }
      fileprivate var updatedPlayerBuilder_:Pogoprotos.Data.PlayerData.Builder! {
           didSet {
              builderResult.hasUpdatedPlayer = true
           }
      }
      public func getUpdatedPlayerBuilder() -> Pogoprotos.Data.PlayerData.Builder {
        if updatedPlayerBuilder_ == nil {
           updatedPlayerBuilder_ = Pogoprotos.Data.PlayerData.Builder()
           builderResult.updatedPlayer = updatedPlayerBuilder_.getMessage()
           if updatedPlayer != nil {
              try! updatedPlayerBuilder_.mergeFrom(other: updatedPlayer)
           }
        }
        return updatedPlayerBuilder_
      }
      @discardableResult
      public func setUpdatedPlayer(_ value:Pogoprotos.Data.PlayerData!) -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        self.updatedPlayer = value
        return self
      }
      @discardableResult
      public func mergeUpdatedPlayer(value:Pogoprotos.Data.PlayerData) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        if builderResult.hasUpdatedPlayer {
          builderResult.updatedPlayer = try Pogoprotos.Data.PlayerData.builderWithPrototype(prototype:builderResult.updatedPlayer).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.updatedPlayer = value
        }
        builderResult.hasUpdatedPlayer = true
        return self
      }
      @discardableResult
      public func clearUpdatedPlayer() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        updatedPlayerBuilder_ = nil
        builderResult.hasUpdatedPlayer = false
        builderResult.updatedPlayer = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.ClaimCodenameResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
        let returnMe:Pogoprotos.Networking.Responses.ClaimCodenameResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.ClaimCodenameResponse) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        if other == Pogoprotos.Networking.Responses.ClaimCodenameResponse() {
         return self
        }
        if other.hasCodename {
             codename = other.codename
        }
        if other.hasUserMessage {
             userMessage = other.userMessage
        }
        if other.hasIsAssignable {
             isAssignable = other.isAssignable
        }
        if other.hasStatus {
             status = other.status
        }
        if (other.hasUpdatedPlayer) {
            try mergeUpdatedPlayer(value: other.updatedPlayer)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            codename = try codedInputStream.readString()

          case 18:
            userMessage = try codedInputStream.readString()

          case 24:
            isAssignable = try codedInputStream.readBool()

          case 32:
            let valueIntstatus = try codedInputStream.readEnum()
            if let enumsstatus = Pogoprotos.Networking.Responses.ClaimCodenameResponse.Status(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntstatus))
            }

          case 42:
            let subBuilder:Pogoprotos.Data.PlayerData.Builder = Pogoprotos.Data.PlayerData.Builder()
            if hasUpdatedPlayer {
              try subBuilder.mergeFrom(other: updatedPlayer)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            updatedPlayer = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder()
        if let jsonValueCodename = jsonMap["codename"] as? String {
          resultDecodedBuilder.codename = jsonValueCodename
        }
        if let jsonValueUserMessage = jsonMap["userMessage"] as? String {
          resultDecodedBuilder.userMessage = jsonValueUserMessage
        }
        if let jsonValueIsAssignable = jsonMap["isAssignable"] as? Bool {
          resultDecodedBuilder.isAssignable = jsonValueIsAssignable
        }
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Status.fromString(str: jsonValueStatus)
        }
        if let jsonValueUpdatedPlayer = jsonMap["updatedPlayer"] as? Dictionary<String,Any> {
          resultDecodedBuilder.updatedPlayer = try Pogoprotos.Data.PlayerData.Builder.decodeToBuilder(jsonMap:jsonValueUpdatedPlayer).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class CollectDailyBonusResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.CollectDailyBonusResponse, rhs: Pogoprotos.Networking.Responses.CollectDailyBonusResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case failure = 2
        case tooSoon = 3
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .failure: return "FAILURE"
          case .tooSoon: return "TOO_SOON"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "FAILURE":  return .failure
          case "TOO_SOON":  return .tooSoon
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .failure: return ".failure"
          case .tooSoon: return ".tooSoon"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Result = Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
      return Pogoprotos.Networking.Responses.CollectDailyBonusResponse.classBuilder() as! Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.CollectDailyBonusResponse) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.CollectDailyBonusResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.CollectDailyBonusResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.CollectDailyBonusResponse = Pogoprotos.Networking.Responses.CollectDailyBonusResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Result) -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.CollectDailyBonusResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
        return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
        let returnMe:Pogoprotos.Networking.Responses.CollectDailyBonusResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.CollectDailyBonusResponse) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
        if other == Pogoprotos.Networking.Responses.CollectDailyBonusResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Result.fromString(str: jsonValueResult)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class CollectDailyDefenderBonusResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse, rhs: Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.currencyType == rhs.currencyType)
      fieldCheck = fieldCheck && (lhs.currencyAwarded == rhs.currencyAwarded)
      fieldCheck = fieldCheck && (lhs.hasDefendersCount == rhs.hasDefendersCount) && (!lhs.hasDefendersCount || lhs.defendersCount == rhs.defendersCount)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case failure = 2
        case tooSoon = 3
        case noDefenders = 4
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .failure: return "FAILURE"
          case .tooSoon: return "TOO_SOON"
          case .noDefenders: return "NO_DEFENDERS"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "FAILURE":  return .failure
          case "TOO_SOON":  return .tooSoon
          case "NO_DEFENDERS":  return .noDefenders
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .failure: return ".failure"
          case .tooSoon: return ".tooSoon"
          case .noDefenders: return ".noDefenders"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Result = Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var currencyType:Array<String> = Array<String>()
    public fileprivate(set) var currencyAwarded:Array<Int32> = Array<Int32>()
    private var currencyAwardedMemoizedSerializedSize:Int32 = -1
    public fileprivate(set) var defendersCount:Int32 = Int32(0)
    public fileprivate(set) var hasDefendersCount:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if !currencyType.isEmpty {
        for oneValuecurrencyType in currencyType {
          try codedOutputStream.writeString(fieldNumber: 2, value:oneValuecurrencyType)
        }
      }
      if !currencyAwarded.isEmpty {
        try codedOutputStream.writeRawVarint32(value: 26)
        try codedOutputStream.writeRawVarint32(value: currencyAwardedMemoizedSerializedSize)
        for oneValuecurrencyAwarded in currencyAwarded {
          try codedOutputStream.writeInt32NoTag(value: oneValuecurrencyAwarded)
        }
      }
      if hasDefendersCount {
        try codedOutputStream.writeInt32(fieldNumber: 4, value:defendersCount)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      var dataSizeCurrencyType:Int32 = 0
      for oneValuecurrencyType in currencyType {
          dataSizeCurrencyType += oneValuecurrencyType.computeStringSizeNoTag()
      }
      serialize_size += dataSizeCurrencyType
      serialize_size += 1 * Int32(currencyType.count)
      var dataSizeCurrencyAwarded:Int32 = 0
      for oneValuecurrencyAwarded in currencyAwarded {
          dataSizeCurrencyAwarded += oneValuecurrencyAwarded.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeCurrencyAwarded
      if !currencyAwarded.isEmpty {
        serialize_size += 1
        serialize_size += dataSizeCurrencyAwarded.computeInt32SizeNoTag()
      }
      currencyAwardedMemoizedSerializedSize = dataSizeCurrencyAwarded
      if hasDefendersCount {
        serialize_size += defendersCount.computeInt32Size(fieldNumber: 4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
      return Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.classBuilder() as! Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if !currencyType.isEmpty {
        var jsonArrayCurrencyType:Array<String> = []
          for oneValueCurrencyType in currencyType {
            jsonArrayCurrencyType.append(oneValueCurrencyType)
          }
        jsonMap["currencyType"] = jsonArrayCurrencyType
      }
      if !currencyAwarded.isEmpty {
        var jsonArrayCurrencyAwarded:Array<Int> = []
          for oneValueCurrencyAwarded in currencyAwarded {
            jsonArrayCurrencyAwarded.append(Int(oneValueCurrencyAwarded))
          }
        jsonMap["currencyAwarded"] = jsonArrayCurrencyAwarded
      }
      if hasDefendersCount {
        jsonMap["defendersCount"] = Int(defendersCount)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      var currencyTypeElementIndex:Int = 0
      for oneValueCurrencyType in currencyType  {
          output += "\(indent) currencyType[\(currencyTypeElementIndex)]: \(oneValueCurrencyType)\n"
          currencyTypeElementIndex += 1
      }
      var currencyAwardedElementIndex:Int = 0
      for oneValueCurrencyAwarded in currencyAwarded  {
          output += "\(indent) currencyAwarded[\(currencyAwardedElementIndex)]: \(oneValueCurrencyAwarded)\n"
          currencyAwardedElementIndex += 1
      }
      if hasDefendersCount {
        output += "\(indent) defendersCount: \(defendersCount) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            for oneValueCurrencyType in currencyType {
                hashCode = (hashCode &* 31) &+ oneValueCurrencyType.hashValue
            }
            for oneValueCurrencyAwarded in currencyAwarded {
                hashCode = (hashCode &* 31) &+ oneValueCurrencyAwarded.hashValue
            }
            if hasDefendersCount {
               hashCode = (hashCode &* 31) &+ defendersCount.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse = Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Result) -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var currencyType:Array<String> {
           get {
               return builderResult.currencyType
           }
           set (array) {
               builderResult.currencyType = array
           }
      }
      @discardableResult
      public func setCurrencyType(_ value:Array<String>) -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        self.currencyType = value
        return self
      }
      @discardableResult
      public func clearCurrencyType() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
         builderResult.currencyType.removeAll(keepingCapacity: false)
         return self
      }
      public var currencyAwarded:Array<Int32> {
           get {
               return builderResult.currencyAwarded
           }
           set (array) {
               builderResult.currencyAwarded = array
           }
      }
      @discardableResult
      public func setCurrencyAwarded(_ value:Array<Int32>) -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        self.currencyAwarded = value
        return self
      }
      @discardableResult
      public func clearCurrencyAwarded() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
         builderResult.currencyAwarded.removeAll(keepingCapacity: false)
         return self
      }
      public var hasDefendersCount:Bool {
           get {
                return builderResult.hasDefendersCount
           }
      }
      public var defendersCount:Int32 {
           get {
                return builderResult.defendersCount
           }
           set (value) {
               builderResult.hasDefendersCount = true
               builderResult.defendersCount = value
           }
      }
      @discardableResult
      public func setDefendersCount(_ value:Int32) -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        self.defendersCount = value
        return self
      }
      @discardableResult
      public func clearDefendersCount() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder{
           builderResult.hasDefendersCount = false
           builderResult.defendersCount = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
        let returnMe:Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        if other == Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if !other.currencyType.isEmpty {
            builderResult.currencyType += other.currencyType
        }
        if !other.currencyAwarded.isEmpty {
            builderResult.currencyAwarded += other.currencyAwarded
        }
        if other.hasDefendersCount {
             defendersCount = other.defendersCount
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            currencyType += [try codedInputStream.readString()]

          case 26:
            let length = Int(try codedInputStream.readRawVarint32())
            let limit = try codedInputStream.pushLimit(byteLimit: length)
            while (codedInputStream.bytesUntilLimit() > 0) {
              builderResult.currencyAwarded.append(try codedInputStream.readInt32())
            }
            codedInputStream.popLimit(oldLimit: limit)

          case 32:
            defendersCount = try codedInputStream.readInt32()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueCurrencyType = jsonMap["currencyType"] as? Array<String> {
          var jsonArrayCurrencyType:Array<String> = []
          for oneValueCurrencyType in jsonValueCurrencyType {
            jsonArrayCurrencyType.append(oneValueCurrencyType)
          }
          resultDecodedBuilder.currencyType = jsonArrayCurrencyType
        }
        if let jsonValueCurrencyAwarded = jsonMap["currencyAwarded"] as? Array<Int> {
          var jsonArrayCurrencyAwarded:Array<Int32> = []
          for oneValueCurrencyAwarded in jsonValueCurrencyAwarded {
            jsonArrayCurrencyAwarded.append(Int32(oneValueCurrencyAwarded))
          }
          resultDecodedBuilder.currencyAwarded = jsonArrayCurrencyAwarded
        }
        if let jsonValueDefendersCount = jsonMap["defendersCount"] as? Int {
          resultDecodedBuilder.defendersCount = Int32(jsonValueDefendersCount)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class DiskEncounterResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.DiskEncounterResponse, rhs: Pogoprotos.Networking.Responses.DiskEncounterResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasPokemonData == rhs.hasPokemonData) && (!lhs.hasPokemonData || lhs.pokemonData == rhs.pokemonData)
      fieldCheck = fieldCheck && (lhs.hasCaptureProbability == rhs.hasCaptureProbability) && (!lhs.hasCaptureProbability || lhs.captureProbability == rhs.captureProbability)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unknown = 0
        case success = 1
        case notAvailable = 2
        case notInRange = 3
        case encounterAlreadyFinished = 4
        case pokemonInventoryFull = 5
        public func toString() -> String {
          switch self {
          case .unknown: return "UNKNOWN"
          case .success: return "SUCCESS"
          case .notAvailable: return "NOT_AVAILABLE"
          case .notInRange: return "NOT_IN_RANGE"
          case .encounterAlreadyFinished: return "ENCOUNTER_ALREADY_FINISHED"
          case .pokemonInventoryFull: return "POKEMON_INVENTORY_FULL"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Result {
          switch str {
          case "UNKNOWN":  return .unknown
          case "SUCCESS":  return .success
          case "NOT_AVAILABLE":  return .notAvailable
          case "NOT_IN_RANGE":  return .notInRange
          case "ENCOUNTER_ALREADY_FINISHED":  return .encounterAlreadyFinished
          case "POKEMON_INVENTORY_FULL":  return .pokemonInventoryFull
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unknown: return ".unknown"
          case .success: return ".success"
          case .notAvailable: return ".notAvailable"
          case .notInRange: return ".notInRange"
          case .encounterAlreadyFinished: return ".encounterAlreadyFinished"
          case .pokemonInventoryFull: return ".pokemonInventoryFull"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.DiskEncounterResponse.Result = Pogoprotos.Networking.Responses.DiskEncounterResponse.Result.unknown
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var pokemonData:Pogoprotos.Data.PokemonData!
    public fileprivate(set) var hasPokemonData:Bool = false
    public fileprivate(set) var captureProbability:Pogoprotos.Data.Capture.CaptureProbability!
    public fileprivate(set) var hasCaptureProbability:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasPokemonData {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:pokemonData)
      }
      if hasCaptureProbability {
        try codedOutputStream.writeMessage(fieldNumber: 3, value:captureProbability)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasPokemonData {
          if let varSizepokemonData = pokemonData?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizepokemonData
          }
      }
      if hasCaptureProbability {
          if let varSizecaptureProbability = captureProbability?.computeMessageSize(fieldNumber: 3) {
              serialize_size += varSizecaptureProbability
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
      return Pogoprotos.Networking.Responses.DiskEncounterResponse.classBuilder() as! Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.DiskEncounterResponse) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasPokemonData {
        jsonMap["pokemonData"] = try pokemonData.encode()
      }
      if hasCaptureProbability {
        jsonMap["captureProbability"] = try captureProbability.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasPokemonData {
        output += "\(indent) pokemonData {\n"
        if let outDescPokemonData = pokemonData {
          output += try outDescPokemonData.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasCaptureProbability {
        output += "\(indent) captureProbability {\n"
        if let outDescCaptureProbability = captureProbability {
          output += try outDescCaptureProbability.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasPokemonData {
                if let hashValuepokemonData = pokemonData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepokemonData
                }
            }
            if hasCaptureProbability {
                if let hashValuecaptureProbability = captureProbability?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecaptureProbability
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.DiskEncounterResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.DiskEncounterResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.DiskEncounterResponse = Pogoprotos.Networking.Responses.DiskEncounterResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.DiskEncounterResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.DiskEncounterResponse.Result) -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unknown
           return self
        }
      public var hasPokemonData:Bool {
           get {
               return builderResult.hasPokemonData
           }
      }
      public var pokemonData:Pogoprotos.Data.PokemonData! {
           get {
               if pokemonDataBuilder_ != nil {
                  builderResult.pokemonData = pokemonDataBuilder_.getMessage()
               }
               return builderResult.pokemonData
           }
           set (value) {
               builderResult.hasPokemonData = true
               builderResult.pokemonData = value
           }
      }
      fileprivate var pokemonDataBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasPokemonData = true
           }
      }
      public func getPokemonDataBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if pokemonDataBuilder_ == nil {
           pokemonDataBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.pokemonData = pokemonDataBuilder_.getMessage()
           if pokemonData != nil {
              try! pokemonDataBuilder_.mergeFrom(other: pokemonData)
           }
        }
        return pokemonDataBuilder_
      }
      @discardableResult
      public func setPokemonData(_ value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        self.pokemonData = value
        return self
      }
      @discardableResult
      public func mergePokemonData(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        if builderResult.hasPokemonData {
          builderResult.pokemonData = try Pogoprotos.Data.PokemonData.builderWithPrototype(prototype:builderResult.pokemonData).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.pokemonData = value
        }
        builderResult.hasPokemonData = true
        return self
      }
      @discardableResult
      public func clearPokemonData() -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        pokemonDataBuilder_ = nil
        builderResult.hasPokemonData = false
        builderResult.pokemonData = nil
        return self
      }
      public var hasCaptureProbability:Bool {
           get {
               return builderResult.hasCaptureProbability
           }
      }
      public var captureProbability:Pogoprotos.Data.Capture.CaptureProbability! {
           get {
               if captureProbabilityBuilder_ != nil {
                  builderResult.captureProbability = captureProbabilityBuilder_.getMessage()
               }
               return builderResult.captureProbability
           }
           set (value) {
               builderResult.hasCaptureProbability = true
               builderResult.captureProbability = value
           }
      }
      fileprivate var captureProbabilityBuilder_:Pogoprotos.Data.Capture.CaptureProbability.Builder! {
           didSet {
              builderResult.hasCaptureProbability = true
           }
      }
      public func getCaptureProbabilityBuilder() -> Pogoprotos.Data.Capture.CaptureProbability.Builder {
        if captureProbabilityBuilder_ == nil {
           captureProbabilityBuilder_ = Pogoprotos.Data.Capture.CaptureProbability.Builder()
           builderResult.captureProbability = captureProbabilityBuilder_.getMessage()
           if captureProbability != nil {
              try! captureProbabilityBuilder_.mergeFrom(other: captureProbability)
           }
        }
        return captureProbabilityBuilder_
      }
      @discardableResult
      public func setCaptureProbability(_ value:Pogoprotos.Data.Capture.CaptureProbability!) -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        self.captureProbability = value
        return self
      }
      @discardableResult
      public func mergeCaptureProbability(value:Pogoprotos.Data.Capture.CaptureProbability) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        if builderResult.hasCaptureProbability {
          builderResult.captureProbability = try Pogoprotos.Data.Capture.CaptureProbability.builderWithPrototype(prototype:builderResult.captureProbability).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.captureProbability = value
        }
        builderResult.hasCaptureProbability = true
        return self
      }
      @discardableResult
      public func clearCaptureProbability() -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        captureProbabilityBuilder_ = nil
        builderResult.hasCaptureProbability = false
        builderResult.captureProbability = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.DiskEncounterResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        return try Pogoprotos.Networking.Responses.DiskEncounterResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
        let returnMe:Pogoprotos.Networking.Responses.DiskEncounterResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.DiskEncounterResponse) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        if other == Pogoprotos.Networking.Responses.DiskEncounterResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasPokemonData) {
            try mergePokemonData(value: other.pokemonData)
        }
        if (other.hasCaptureProbability) {
            try mergeCaptureProbability(value: other.captureProbability)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.DiskEncounterResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasPokemonData {
              try subBuilder.mergeFrom(other: pokemonData)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            pokemonData = subBuilder.buildPartial()

          case 26:
            let subBuilder:Pogoprotos.Data.Capture.CaptureProbability.Builder = Pogoprotos.Data.Capture.CaptureProbability.Builder()
            if hasCaptureProbability {
              try subBuilder.mergeFrom(other: captureProbability)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            captureProbability = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.DiskEncounterResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValuePokemonData = jsonMap["pokemonData"] as? Dictionary<String,Any> {
          resultDecodedBuilder.pokemonData = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonMap:jsonValuePokemonData).build()

        }
        if let jsonValueCaptureProbability = jsonMap["captureProbability"] as? Dictionary<String,Any> {
          resultDecodedBuilder.captureProbability = try Pogoprotos.Data.Capture.CaptureProbability.Builder.decodeToBuilder(jsonMap:jsonValueCaptureProbability).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class DownloadItemTemplatesResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse, rhs: Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
      fieldCheck = fieldCheck && (lhs.itemTemplates == rhs.itemTemplates)
      fieldCheck = fieldCheck && (lhs.hasTimestampMs == rhs.hasTimestampMs) && (!lhs.hasTimestampMs || lhs.timestampMs == rhs.timestampMs)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



    //Nested type declaration start

      final public class ItemTemplate : GeneratedMessage {

        public static func == (lhs: Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate, rhs: Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate) -> Bool {
          if (lhs === rhs) {
            return true
          }
          var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
          fieldCheck = fieldCheck && (lhs.hasTemplateId == rhs.hasTemplateId) && (!lhs.hasTemplateId || lhs.templateId == rhs.templateId)
          fieldCheck = fieldCheck && (lhs.hasPokemonSettings == rhs.hasPokemonSettings) && (!lhs.hasPokemonSettings || lhs.pokemonSettings == rhs.pokemonSettings)
          fieldCheck = fieldCheck && (lhs.hasItemSettings == rhs.hasItemSettings) && (!lhs.hasItemSettings || lhs.itemSettings == rhs.itemSettings)
          fieldCheck = fieldCheck && (lhs.hasMoveSettings == rhs.hasMoveSettings) && (!lhs.hasMoveSettings || lhs.moveSettings == rhs.moveSettings)
          fieldCheck = fieldCheck && (lhs.hasMoveSequenceSettings == rhs.hasMoveSequenceSettings) && (!lhs.hasMoveSequenceSettings || lhs.moveSequenceSettings == rhs.moveSequenceSettings)
          fieldCheck = fieldCheck && (lhs.hasTypeEffective == rhs.hasTypeEffective) && (!lhs.hasTypeEffective || lhs.typeEffective == rhs.typeEffective)
          fieldCheck = fieldCheck && (lhs.hasBadgeSettings == rhs.hasBadgeSettings) && (!lhs.hasBadgeSettings || lhs.badgeSettings == rhs.badgeSettings)
          fieldCheck = fieldCheck && (lhs.hasCamera == rhs.hasCamera) && (!lhs.hasCamera || lhs.camera == rhs.camera)
          fieldCheck = fieldCheck && (lhs.hasPlayerLevel == rhs.hasPlayerLevel) && (!lhs.hasPlayerLevel || lhs.playerLevel == rhs.playerLevel)
          fieldCheck = fieldCheck && (lhs.hasGymLevel == rhs.hasGymLevel) && (!lhs.hasGymLevel || lhs.gymLevel == rhs.gymLevel)
          fieldCheck = fieldCheck && (lhs.hasBattleSettings == rhs.hasBattleSettings) && (!lhs.hasBattleSettings || lhs.battleSettings == rhs.battleSettings)
          fieldCheck = fieldCheck && (lhs.hasEncounterSettings == rhs.hasEncounterSettings) && (!lhs.hasEncounterSettings || lhs.encounterSettings == rhs.encounterSettings)
          fieldCheck = fieldCheck && (lhs.hasIapItemDisplay == rhs.hasIapItemDisplay) && (!lhs.hasIapItemDisplay || lhs.iapItemDisplay == rhs.iapItemDisplay)
          fieldCheck = fieldCheck && (lhs.hasIapSettings == rhs.hasIapSettings) && (!lhs.hasIapSettings || lhs.iapSettings == rhs.iapSettings)
          fieldCheck = fieldCheck && (lhs.hasPokemonUpgrades == rhs.hasPokemonUpgrades) && (!lhs.hasPokemonUpgrades || lhs.pokemonUpgrades == rhs.pokemonUpgrades)
          fieldCheck = fieldCheck && (lhs.hasEquippedBadges == rhs.hasEquippedBadges) && (!lhs.hasEquippedBadges || lhs.equippedBadges == rhs.equippedBadges)
          fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
          return fieldCheck
        }

        public fileprivate(set) var templateId:String = ""
        public fileprivate(set) var hasTemplateId:Bool = false

        public fileprivate(set) var pokemonSettings:Pogoprotos.Settings.Master.PokemonSettings!
        public fileprivate(set) var hasPokemonSettings:Bool = false
        public fileprivate(set) var itemSettings:Pogoprotos.Settings.Master.ItemSettings!
        public fileprivate(set) var hasItemSettings:Bool = false
        public fileprivate(set) var moveSettings:Pogoprotos.Settings.Master.MoveSettings!
        public fileprivate(set) var hasMoveSettings:Bool = false
        public fileprivate(set) var moveSequenceSettings:Pogoprotos.Settings.Master.MoveSequenceSettings!
        public fileprivate(set) var hasMoveSequenceSettings:Bool = false
        public fileprivate(set) var typeEffective:Pogoprotos.Settings.Master.TypeEffectiveSettings!
        public fileprivate(set) var hasTypeEffective:Bool = false
        public fileprivate(set) var badgeSettings:Pogoprotos.Settings.Master.BadgeSettings!
        public fileprivate(set) var hasBadgeSettings:Bool = false
        public fileprivate(set) var camera:Pogoprotos.Settings.Master.CameraSettings!
        public fileprivate(set) var hasCamera:Bool = false
        public fileprivate(set) var playerLevel:Pogoprotos.Settings.Master.PlayerLevelSettings!
        public fileprivate(set) var hasPlayerLevel:Bool = false
        public fileprivate(set) var gymLevel:Pogoprotos.Settings.Master.GymLevelSettings!
        public fileprivate(set) var hasGymLevel:Bool = false
        public fileprivate(set) var battleSettings:Pogoprotos.Settings.Master.GymBattleSettings!
        public fileprivate(set) var hasBattleSettings:Bool = false
        public fileprivate(set) var encounterSettings:Pogoprotos.Settings.Master.EncounterSettings!
        public fileprivate(set) var hasEncounterSettings:Bool = false
        public fileprivate(set) var iapItemDisplay:Pogoprotos.Settings.Master.IapItemDisplay!
        public fileprivate(set) var hasIapItemDisplay:Bool = false
        public fileprivate(set) var iapSettings:Pogoprotos.Settings.Master.IapSettings!
        public fileprivate(set) var hasIapSettings:Bool = false
        public fileprivate(set) var pokemonUpgrades:Pogoprotos.Settings.Master.PokemonUpgradeSettings!
        public fileprivate(set) var hasPokemonUpgrades:Bool = false
        public fileprivate(set) var equippedBadges:Pogoprotos.Settings.Master.EquippedBadgeSettings!
        public fileprivate(set) var hasEquippedBadges:Bool = false
        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
          if hasTemplateId {
            try codedOutputStream.writeString(fieldNumber: 1, value:templateId)
          }
          if hasPokemonSettings {
            try codedOutputStream.writeMessage(fieldNumber: 2, value:pokemonSettings)
          }
          if hasItemSettings {
            try codedOutputStream.writeMessage(fieldNumber: 3, value:itemSettings)
          }
          if hasMoveSettings {
            try codedOutputStream.writeMessage(fieldNumber: 4, value:moveSettings)
          }
          if hasMoveSequenceSettings {
            try codedOutputStream.writeMessage(fieldNumber: 5, value:moveSequenceSettings)
          }
          if hasTypeEffective {
            try codedOutputStream.writeMessage(fieldNumber: 8, value:typeEffective)
          }
          if hasBadgeSettings {
            try codedOutputStream.writeMessage(fieldNumber: 10, value:badgeSettings)
          }
          if hasCamera {
            try codedOutputStream.writeMessage(fieldNumber: 11, value:camera)
          }
          if hasPlayerLevel {
            try codedOutputStream.writeMessage(fieldNumber: 12, value:playerLevel)
          }
          if hasGymLevel {
            try codedOutputStream.writeMessage(fieldNumber: 13, value:gymLevel)
          }
          if hasBattleSettings {
            try codedOutputStream.writeMessage(fieldNumber: 14, value:battleSettings)
          }
          if hasEncounterSettings {
            try codedOutputStream.writeMessage(fieldNumber: 15, value:encounterSettings)
          }
          if hasIapItemDisplay {
            try codedOutputStream.writeMessage(fieldNumber: 16, value:iapItemDisplay)
          }
          if hasIapSettings {
            try codedOutputStream.writeMessage(fieldNumber: 17, value:iapSettings)
          }
          if hasPokemonUpgrades {
            try codedOutputStream.writeMessage(fieldNumber: 18, value:pokemonUpgrades)
          }
          if hasEquippedBadges {
            try codedOutputStream.writeMessage(fieldNumber: 19, value:equippedBadges)
          }
          try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasTemplateId {
            serialize_size += templateId.computeStringSize(fieldNumber: 1)
          }
          if hasPokemonSettings {
              if let varSizepokemonSettings = pokemonSettings?.computeMessageSize(fieldNumber: 2) {
                  serialize_size += varSizepokemonSettings
              }
          }
          if hasItemSettings {
              if let varSizeitemSettings = itemSettings?.computeMessageSize(fieldNumber: 3) {
                  serialize_size += varSizeitemSettings
              }
          }
          if hasMoveSettings {
              if let varSizemoveSettings = moveSettings?.computeMessageSize(fieldNumber: 4) {
                  serialize_size += varSizemoveSettings
              }
          }
          if hasMoveSequenceSettings {
              if let varSizemoveSequenceSettings = moveSequenceSettings?.computeMessageSize(fieldNumber: 5) {
                  serialize_size += varSizemoveSequenceSettings
              }
          }
          if hasTypeEffective {
              if let varSizetypeEffective = typeEffective?.computeMessageSize(fieldNumber: 8) {
                  serialize_size += varSizetypeEffective
              }
          }
          if hasBadgeSettings {
              if let varSizebadgeSettings = badgeSettings?.computeMessageSize(fieldNumber: 10) {
                  serialize_size += varSizebadgeSettings
              }
          }
          if hasCamera {
              if let varSizecamera = camera?.computeMessageSize(fieldNumber: 11) {
                  serialize_size += varSizecamera
              }
          }
          if hasPlayerLevel {
              if let varSizeplayerLevel = playerLevel?.computeMessageSize(fieldNumber: 12) {
                  serialize_size += varSizeplayerLevel
              }
          }
          if hasGymLevel {
              if let varSizegymLevel = gymLevel?.computeMessageSize(fieldNumber: 13) {
                  serialize_size += varSizegymLevel
              }
          }
          if hasBattleSettings {
              if let varSizebattleSettings = battleSettings?.computeMessageSize(fieldNumber: 14) {
                  serialize_size += varSizebattleSettings
              }
          }
          if hasEncounterSettings {
              if let varSizeencounterSettings = encounterSettings?.computeMessageSize(fieldNumber: 15) {
                  serialize_size += varSizeencounterSettings
              }
          }
          if hasIapItemDisplay {
              if let varSizeiapItemDisplay = iapItemDisplay?.computeMessageSize(fieldNumber: 16) {
                  serialize_size += varSizeiapItemDisplay
              }
          }
          if hasIapSettings {
              if let varSizeiapSettings = iapSettings?.computeMessageSize(fieldNumber: 17) {
                  serialize_size += varSizeiapSettings
              }
          }
          if hasPokemonUpgrades {
              if let varSizepokemonUpgrades = pokemonUpgrades?.computeMessageSize(fieldNumber: 18) {
                  serialize_size += varSizepokemonUpgrades
              }
          }
          if hasEquippedBadges {
              if let varSizeequippedBadges = equippedBadges?.computeMessageSize(fieldNumber: 19) {
                  serialize_size += varSizeequippedBadges
              }
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func getBuilder() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
          return Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.classBuilder() as! Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder
        }
        public func getBuilder() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
          return classBuilder() as! Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
          return Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
          return Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder()
        }
        public func toBuilder() throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
          guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
          if hasTemplateId {
            jsonMap["templateId"] = templateId
          }
          if hasPokemonSettings {
            jsonMap["pokemonSettings"] = try pokemonSettings.encode()
          }
          if hasItemSettings {
            jsonMap["itemSettings"] = try itemSettings.encode()
          }
          if hasMoveSettings {
            jsonMap["moveSettings"] = try moveSettings.encode()
          }
          if hasMoveSequenceSettings {
            jsonMap["moveSequenceSettings"] = try moveSequenceSettings.encode()
          }
          if hasTypeEffective {
            jsonMap["typeEffective"] = try typeEffective.encode()
          }
          if hasBadgeSettings {
            jsonMap["badgeSettings"] = try badgeSettings.encode()
          }
          if hasCamera {
            jsonMap["camera"] = try camera.encode()
          }
          if hasPlayerLevel {
            jsonMap["playerLevel"] = try playerLevel.encode()
          }
          if hasGymLevel {
            jsonMap["gymLevel"] = try gymLevel.encode()
          }
          if hasBattleSettings {
            jsonMap["battleSettings"] = try battleSettings.encode()
          }
          if hasEncounterSettings {
            jsonMap["encounterSettings"] = try encounterSettings.encode()
          }
          if hasIapItemDisplay {
            jsonMap["iapItemDisplay"] = try iapItemDisplay.encode()
          }
          if hasIapSettings {
            jsonMap["iapSettings"] = try iapSettings.encode()
          }
          if hasPokemonUpgrades {
            jsonMap["pokemonUpgrades"] = try pokemonUpgrades.encode()
          }
          if hasEquippedBadges {
            jsonMap["equippedBadges"] = try equippedBadges.encode()
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasTemplateId {
            output += "\(indent) templateId: \(templateId) \n"
          }
          if hasPokemonSettings {
            output += "\(indent) pokemonSettings {\n"
            if let outDescPokemonSettings = pokemonSettings {
              output += try outDescPokemonSettings.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasItemSettings {
            output += "\(indent) itemSettings {\n"
            if let outDescItemSettings = itemSettings {
              output += try outDescItemSettings.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasMoveSettings {
            output += "\(indent) moveSettings {\n"
            if let outDescMoveSettings = moveSettings {
              output += try outDescMoveSettings.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasMoveSequenceSettings {
            output += "\(indent) moveSequenceSettings {\n"
            if let outDescMoveSequenceSettings = moveSequenceSettings {
              output += try outDescMoveSequenceSettings.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasTypeEffective {
            output += "\(indent) typeEffective {\n"
            if let outDescTypeEffective = typeEffective {
              output += try outDescTypeEffective.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasBadgeSettings {
            output += "\(indent) badgeSettings {\n"
            if let outDescBadgeSettings = badgeSettings {
              output += try outDescBadgeSettings.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasCamera {
            output += "\(indent) camera {\n"
            if let outDescCamera = camera {
              output += try outDescCamera.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasPlayerLevel {
            output += "\(indent) playerLevel {\n"
            if let outDescPlayerLevel = playerLevel {
              output += try outDescPlayerLevel.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasGymLevel {
            output += "\(indent) gymLevel {\n"
            if let outDescGymLevel = gymLevel {
              output += try outDescGymLevel.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasBattleSettings {
            output += "\(indent) battleSettings {\n"
            if let outDescBattleSettings = battleSettings {
              output += try outDescBattleSettings.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasEncounterSettings {
            output += "\(indent) encounterSettings {\n"
            if let outDescEncounterSettings = encounterSettings {
              output += try outDescEncounterSettings.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasIapItemDisplay {
            output += "\(indent) iapItemDisplay {\n"
            if let outDescIapItemDisplay = iapItemDisplay {
              output += try outDescIapItemDisplay.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasIapSettings {
            output += "\(indent) iapSettings {\n"
            if let outDescIapSettings = iapSettings {
              output += try outDescIapSettings.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasPokemonUpgrades {
            output += "\(indent) pokemonUpgrades {\n"
            if let outDescPokemonUpgrades = pokemonUpgrades {
              output += try outDescPokemonUpgrades.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasEquippedBadges {
            output += "\(indent) equippedBadges {\n"
            if let outDescEquippedBadges = equippedBadges {
              output += try outDescEquippedBadges.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          output += unknownFields.getDescription(indent: indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTemplateId {
                   hashCode = (hashCode &* 31) &+ templateId.hashValue
                }
                if hasPokemonSettings {
                    if let hashValuepokemonSettings = pokemonSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuepokemonSettings
                    }
                }
                if hasItemSettings {
                    if let hashValueitemSettings = itemSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueitemSettings
                    }
                }
                if hasMoveSettings {
                    if let hashValuemoveSettings = moveSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemoveSettings
                    }
                }
                if hasMoveSequenceSettings {
                    if let hashValuemoveSequenceSettings = moveSequenceSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemoveSequenceSettings
                    }
                }
                if hasTypeEffective {
                    if let hashValuetypeEffective = typeEffective?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetypeEffective
                    }
                }
                if hasBadgeSettings {
                    if let hashValuebadgeSettings = badgeSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuebadgeSettings
                    }
                }
                if hasCamera {
                    if let hashValuecamera = camera?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecamera
                    }
                }
                if hasPlayerLevel {
                    if let hashValueplayerLevel = playerLevel?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueplayerLevel
                    }
                }
                if hasGymLevel {
                    if let hashValuegymLevel = gymLevel?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegymLevel
                    }
                }
                if hasBattleSettings {
                    if let hashValuebattleSettings = battleSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuebattleSettings
                    }
                }
                if hasEncounterSettings {
                    if let hashValueencounterSettings = encounterSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueencounterSettings
                    }
                }
                if hasIapItemDisplay {
                    if let hashValueiapItemDisplay = iapItemDisplay?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueiapItemDisplay
                    }
                }
                if hasIapSettings {
                    if let hashValueiapSettings = iapSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueiapSettings
                    }
                }
                if hasPokemonUpgrades {
                    if let hashValuepokemonUpgrades = pokemonUpgrades?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuepokemonUpgrades
                    }
                }
                if hasEquippedBadges {
                    if let hashValueequippedBadges = equippedBadges?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueequippedBadges
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate"
        }
        override public func className() -> String {
            return "Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          fileprivate var builderResult:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate = Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate()
          public func getMessage() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasTemplateId:Bool {
               get {
                    return builderResult.hasTemplateId
               }
          }
          public var templateId:String {
               get {
                    return builderResult.templateId
               }
               set (value) {
                   builderResult.hasTemplateId = true
                   builderResult.templateId = value
               }
          }
          @discardableResult
          public func setTemplateId(_ value:String) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.templateId = value
            return self
          }
          @discardableResult
          public func clearTemplateId() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder{
               builderResult.hasTemplateId = false
               builderResult.templateId = ""
               return self
          }
          public var hasPokemonSettings:Bool {
               get {
                   return builderResult.hasPokemonSettings
               }
          }
          public var pokemonSettings:Pogoprotos.Settings.Master.PokemonSettings! {
               get {
                   if pokemonSettingsBuilder_ != nil {
                      builderResult.pokemonSettings = pokemonSettingsBuilder_.getMessage()
                   }
                   return builderResult.pokemonSettings
               }
               set (value) {
                   builderResult.hasPokemonSettings = true
                   builderResult.pokemonSettings = value
               }
          }
          fileprivate var pokemonSettingsBuilder_:Pogoprotos.Settings.Master.PokemonSettings.Builder! {
               didSet {
                  builderResult.hasPokemonSettings = true
               }
          }
          public func getPokemonSettingsBuilder() -> Pogoprotos.Settings.Master.PokemonSettings.Builder {
            if pokemonSettingsBuilder_ == nil {
               pokemonSettingsBuilder_ = Pogoprotos.Settings.Master.PokemonSettings.Builder()
               builderResult.pokemonSettings = pokemonSettingsBuilder_.getMessage()
               if pokemonSettings != nil {
                  try! pokemonSettingsBuilder_.mergeFrom(other: pokemonSettings)
               }
            }
            return pokemonSettingsBuilder_
          }
          @discardableResult
          public func setPokemonSettings(_ value:Pogoprotos.Settings.Master.PokemonSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.pokemonSettings = value
            return self
          }
          @discardableResult
          public func mergePokemonSettings(value:Pogoprotos.Settings.Master.PokemonSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasPokemonSettings {
              builderResult.pokemonSettings = try Pogoprotos.Settings.Master.PokemonSettings.builderWithPrototype(prototype:builderResult.pokemonSettings).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.pokemonSettings = value
            }
            builderResult.hasPokemonSettings = true
            return self
          }
          @discardableResult
          public func clearPokemonSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            pokemonSettingsBuilder_ = nil
            builderResult.hasPokemonSettings = false
            builderResult.pokemonSettings = nil
            return self
          }
          public var hasItemSettings:Bool {
               get {
                   return builderResult.hasItemSettings
               }
          }
          public var itemSettings:Pogoprotos.Settings.Master.ItemSettings! {
               get {
                   if itemSettingsBuilder_ != nil {
                      builderResult.itemSettings = itemSettingsBuilder_.getMessage()
                   }
                   return builderResult.itemSettings
               }
               set (value) {
                   builderResult.hasItemSettings = true
                   builderResult.itemSettings = value
               }
          }
          fileprivate var itemSettingsBuilder_:Pogoprotos.Settings.Master.ItemSettings.Builder! {
               didSet {
                  builderResult.hasItemSettings = true
               }
          }
          public func getItemSettingsBuilder() -> Pogoprotos.Settings.Master.ItemSettings.Builder {
            if itemSettingsBuilder_ == nil {
               itemSettingsBuilder_ = Pogoprotos.Settings.Master.ItemSettings.Builder()
               builderResult.itemSettings = itemSettingsBuilder_.getMessage()
               if itemSettings != nil {
                  try! itemSettingsBuilder_.mergeFrom(other: itemSettings)
               }
            }
            return itemSettingsBuilder_
          }
          @discardableResult
          public func setItemSettings(_ value:Pogoprotos.Settings.Master.ItemSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.itemSettings = value
            return self
          }
          @discardableResult
          public func mergeItemSettings(value:Pogoprotos.Settings.Master.ItemSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasItemSettings {
              builderResult.itemSettings = try Pogoprotos.Settings.Master.ItemSettings.builderWithPrototype(prototype:builderResult.itemSettings).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.itemSettings = value
            }
            builderResult.hasItemSettings = true
            return self
          }
          @discardableResult
          public func clearItemSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            itemSettingsBuilder_ = nil
            builderResult.hasItemSettings = false
            builderResult.itemSettings = nil
            return self
          }
          public var hasMoveSettings:Bool {
               get {
                   return builderResult.hasMoveSettings
               }
          }
          public var moveSettings:Pogoprotos.Settings.Master.MoveSettings! {
               get {
                   if moveSettingsBuilder_ != nil {
                      builderResult.moveSettings = moveSettingsBuilder_.getMessage()
                   }
                   return builderResult.moveSettings
               }
               set (value) {
                   builderResult.hasMoveSettings = true
                   builderResult.moveSettings = value
               }
          }
          fileprivate var moveSettingsBuilder_:Pogoprotos.Settings.Master.MoveSettings.Builder! {
               didSet {
                  builderResult.hasMoveSettings = true
               }
          }
          public func getMoveSettingsBuilder() -> Pogoprotos.Settings.Master.MoveSettings.Builder {
            if moveSettingsBuilder_ == nil {
               moveSettingsBuilder_ = Pogoprotos.Settings.Master.MoveSettings.Builder()
               builderResult.moveSettings = moveSettingsBuilder_.getMessage()
               if moveSettings != nil {
                  try! moveSettingsBuilder_.mergeFrom(other: moveSettings)
               }
            }
            return moveSettingsBuilder_
          }
          @discardableResult
          public func setMoveSettings(_ value:Pogoprotos.Settings.Master.MoveSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.moveSettings = value
            return self
          }
          @discardableResult
          public func mergeMoveSettings(value:Pogoprotos.Settings.Master.MoveSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasMoveSettings {
              builderResult.moveSettings = try Pogoprotos.Settings.Master.MoveSettings.builderWithPrototype(prototype:builderResult.moveSettings).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.moveSettings = value
            }
            builderResult.hasMoveSettings = true
            return self
          }
          @discardableResult
          public func clearMoveSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            moveSettingsBuilder_ = nil
            builderResult.hasMoveSettings = false
            builderResult.moveSettings = nil
            return self
          }
          public var hasMoveSequenceSettings:Bool {
               get {
                   return builderResult.hasMoveSequenceSettings
               }
          }
          public var moveSequenceSettings:Pogoprotos.Settings.Master.MoveSequenceSettings! {
               get {
                   if moveSequenceSettingsBuilder_ != nil {
                      builderResult.moveSequenceSettings = moveSequenceSettingsBuilder_.getMessage()
                   }
                   return builderResult.moveSequenceSettings
               }
               set (value) {
                   builderResult.hasMoveSequenceSettings = true
                   builderResult.moveSequenceSettings = value
               }
          }
          fileprivate var moveSequenceSettingsBuilder_:Pogoprotos.Settings.Master.MoveSequenceSettings.Builder! {
               didSet {
                  builderResult.hasMoveSequenceSettings = true
               }
          }
          public func getMoveSequenceSettingsBuilder() -> Pogoprotos.Settings.Master.MoveSequenceSettings.Builder {
            if moveSequenceSettingsBuilder_ == nil {
               moveSequenceSettingsBuilder_ = Pogoprotos.Settings.Master.MoveSequenceSettings.Builder()
               builderResult.moveSequenceSettings = moveSequenceSettingsBuilder_.getMessage()
               if moveSequenceSettings != nil {
                  try! moveSequenceSettingsBuilder_.mergeFrom(other: moveSequenceSettings)
               }
            }
            return moveSequenceSettingsBuilder_
          }
          @discardableResult
          public func setMoveSequenceSettings(_ value:Pogoprotos.Settings.Master.MoveSequenceSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.moveSequenceSettings = value
            return self
          }
          @discardableResult
          public func mergeMoveSequenceSettings(value:Pogoprotos.Settings.Master.MoveSequenceSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasMoveSequenceSettings {
              builderResult.moveSequenceSettings = try Pogoprotos.Settings.Master.MoveSequenceSettings.builderWithPrototype(prototype:builderResult.moveSequenceSettings).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.moveSequenceSettings = value
            }
            builderResult.hasMoveSequenceSettings = true
            return self
          }
          @discardableResult
          public func clearMoveSequenceSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            moveSequenceSettingsBuilder_ = nil
            builderResult.hasMoveSequenceSettings = false
            builderResult.moveSequenceSettings = nil
            return self
          }
          public var hasTypeEffective:Bool {
               get {
                   return builderResult.hasTypeEffective
               }
          }
          public var typeEffective:Pogoprotos.Settings.Master.TypeEffectiveSettings! {
               get {
                   if typeEffectiveBuilder_ != nil {
                      builderResult.typeEffective = typeEffectiveBuilder_.getMessage()
                   }
                   return builderResult.typeEffective
               }
               set (value) {
                   builderResult.hasTypeEffective = true
                   builderResult.typeEffective = value
               }
          }
          fileprivate var typeEffectiveBuilder_:Pogoprotos.Settings.Master.TypeEffectiveSettings.Builder! {
               didSet {
                  builderResult.hasTypeEffective = true
               }
          }
          public func getTypeEffectiveBuilder() -> Pogoprotos.Settings.Master.TypeEffectiveSettings.Builder {
            if typeEffectiveBuilder_ == nil {
               typeEffectiveBuilder_ = Pogoprotos.Settings.Master.TypeEffectiveSettings.Builder()
               builderResult.typeEffective = typeEffectiveBuilder_.getMessage()
               if typeEffective != nil {
                  try! typeEffectiveBuilder_.mergeFrom(other: typeEffective)
               }
            }
            return typeEffectiveBuilder_
          }
          @discardableResult
          public func setTypeEffective(_ value:Pogoprotos.Settings.Master.TypeEffectiveSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.typeEffective = value
            return self
          }
          @discardableResult
          public func mergeTypeEffective(value:Pogoprotos.Settings.Master.TypeEffectiveSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasTypeEffective {
              builderResult.typeEffective = try Pogoprotos.Settings.Master.TypeEffectiveSettings.builderWithPrototype(prototype:builderResult.typeEffective).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.typeEffective = value
            }
            builderResult.hasTypeEffective = true
            return self
          }
          @discardableResult
          public func clearTypeEffective() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            typeEffectiveBuilder_ = nil
            builderResult.hasTypeEffective = false
            builderResult.typeEffective = nil
            return self
          }
          public var hasBadgeSettings:Bool {
               get {
                   return builderResult.hasBadgeSettings
               }
          }
          public var badgeSettings:Pogoprotos.Settings.Master.BadgeSettings! {
               get {
                   if badgeSettingsBuilder_ != nil {
                      builderResult.badgeSettings = badgeSettingsBuilder_.getMessage()
                   }
                   return builderResult.badgeSettings
               }
               set (value) {
                   builderResult.hasBadgeSettings = true
                   builderResult.badgeSettings = value
               }
          }
          fileprivate var badgeSettingsBuilder_:Pogoprotos.Settings.Master.BadgeSettings.Builder! {
               didSet {
                  builderResult.hasBadgeSettings = true
               }
          }
          public func getBadgeSettingsBuilder() -> Pogoprotos.Settings.Master.BadgeSettings.Builder {
            if badgeSettingsBuilder_ == nil {
               badgeSettingsBuilder_ = Pogoprotos.Settings.Master.BadgeSettings.Builder()
               builderResult.badgeSettings = badgeSettingsBuilder_.getMessage()
               if badgeSettings != nil {
                  try! badgeSettingsBuilder_.mergeFrom(other: badgeSettings)
               }
            }
            return badgeSettingsBuilder_
          }
          @discardableResult
          public func setBadgeSettings(_ value:Pogoprotos.Settings.Master.BadgeSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.badgeSettings = value
            return self
          }
          @discardableResult
          public func mergeBadgeSettings(value:Pogoprotos.Settings.Master.BadgeSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasBadgeSettings {
              builderResult.badgeSettings = try Pogoprotos.Settings.Master.BadgeSettings.builderWithPrototype(prototype:builderResult.badgeSettings).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.badgeSettings = value
            }
            builderResult.hasBadgeSettings = true
            return self
          }
          @discardableResult
          public func clearBadgeSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            badgeSettingsBuilder_ = nil
            builderResult.hasBadgeSettings = false
            builderResult.badgeSettings = nil
            return self
          }
          public var hasCamera:Bool {
               get {
                   return builderResult.hasCamera
               }
          }
          public var camera:Pogoprotos.Settings.Master.CameraSettings! {
               get {
                   if cameraBuilder_ != nil {
                      builderResult.camera = cameraBuilder_.getMessage()
                   }
                   return builderResult.camera
               }
               set (value) {
                   builderResult.hasCamera = true
                   builderResult.camera = value
               }
          }
          fileprivate var cameraBuilder_:Pogoprotos.Settings.Master.CameraSettings.Builder! {
               didSet {
                  builderResult.hasCamera = true
               }
          }
          public func getCameraBuilder() -> Pogoprotos.Settings.Master.CameraSettings.Builder {
            if cameraBuilder_ == nil {
               cameraBuilder_ = Pogoprotos.Settings.Master.CameraSettings.Builder()
               builderResult.camera = cameraBuilder_.getMessage()
               if camera != nil {
                  try! cameraBuilder_.mergeFrom(other: camera)
               }
            }
            return cameraBuilder_
          }
          @discardableResult
          public func setCamera(_ value:Pogoprotos.Settings.Master.CameraSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.camera = value
            return self
          }
          @discardableResult
          public func mergeCamera(value:Pogoprotos.Settings.Master.CameraSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasCamera {
              builderResult.camera = try Pogoprotos.Settings.Master.CameraSettings.builderWithPrototype(prototype:builderResult.camera).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.camera = value
            }
            builderResult.hasCamera = true
            return self
          }
          @discardableResult
          public func clearCamera() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            cameraBuilder_ = nil
            builderResult.hasCamera = false
            builderResult.camera = nil
            return self
          }
          public var hasPlayerLevel:Bool {
               get {
                   return builderResult.hasPlayerLevel
               }
          }
          public var playerLevel:Pogoprotos.Settings.Master.PlayerLevelSettings! {
               get {
                   if playerLevelBuilder_ != nil {
                      builderResult.playerLevel = playerLevelBuilder_.getMessage()
                   }
                   return builderResult.playerLevel
               }
               set (value) {
                   builderResult.hasPlayerLevel = true
                   builderResult.playerLevel = value
               }
          }
          fileprivate var playerLevelBuilder_:Pogoprotos.Settings.Master.PlayerLevelSettings.Builder! {
               didSet {
                  builderResult.hasPlayerLevel = true
               }
          }
          public func getPlayerLevelBuilder() -> Pogoprotos.Settings.Master.PlayerLevelSettings.Builder {
            if playerLevelBuilder_ == nil {
               playerLevelBuilder_ = Pogoprotos.Settings.Master.PlayerLevelSettings.Builder()
               builderResult.playerLevel = playerLevelBuilder_.getMessage()
               if playerLevel != nil {
                  try! playerLevelBuilder_.mergeFrom(other: playerLevel)
               }
            }
            return playerLevelBuilder_
          }
          @discardableResult
          public func setPlayerLevel(_ value:Pogoprotos.Settings.Master.PlayerLevelSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.playerLevel = value
            return self
          }
          @discardableResult
          public func mergePlayerLevel(value:Pogoprotos.Settings.Master.PlayerLevelSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasPlayerLevel {
              builderResult.playerLevel = try Pogoprotos.Settings.Master.PlayerLevelSettings.builderWithPrototype(prototype:builderResult.playerLevel).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.playerLevel = value
            }
            builderResult.hasPlayerLevel = true
            return self
          }
          @discardableResult
          public func clearPlayerLevel() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            playerLevelBuilder_ = nil
            builderResult.hasPlayerLevel = false
            builderResult.playerLevel = nil
            return self
          }
          public var hasGymLevel:Bool {
               get {
                   return builderResult.hasGymLevel
               }
          }
          public var gymLevel:Pogoprotos.Settings.Master.GymLevelSettings! {
               get {
                   if gymLevelBuilder_ != nil {
                      builderResult.gymLevel = gymLevelBuilder_.getMessage()
                   }
                   return builderResult.gymLevel
               }
               set (value) {
                   builderResult.hasGymLevel = true
                   builderResult.gymLevel = value
               }
          }
          fileprivate var gymLevelBuilder_:Pogoprotos.Settings.Master.GymLevelSettings.Builder! {
               didSet {
                  builderResult.hasGymLevel = true
               }
          }
          public func getGymLevelBuilder() -> Pogoprotos.Settings.Master.GymLevelSettings.Builder {
            if gymLevelBuilder_ == nil {
               gymLevelBuilder_ = Pogoprotos.Settings.Master.GymLevelSettings.Builder()
               builderResult.gymLevel = gymLevelBuilder_.getMessage()
               if gymLevel != nil {
                  try! gymLevelBuilder_.mergeFrom(other: gymLevel)
               }
            }
            return gymLevelBuilder_
          }
          @discardableResult
          public func setGymLevel(_ value:Pogoprotos.Settings.Master.GymLevelSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.gymLevel = value
            return self
          }
          @discardableResult
          public func mergeGymLevel(value:Pogoprotos.Settings.Master.GymLevelSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasGymLevel {
              builderResult.gymLevel = try Pogoprotos.Settings.Master.GymLevelSettings.builderWithPrototype(prototype:builderResult.gymLevel).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.gymLevel = value
            }
            builderResult.hasGymLevel = true
            return self
          }
          @discardableResult
          public func clearGymLevel() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            gymLevelBuilder_ = nil
            builderResult.hasGymLevel = false
            builderResult.gymLevel = nil
            return self
          }
          public var hasBattleSettings:Bool {
               get {
                   return builderResult.hasBattleSettings
               }
          }
          public var battleSettings:Pogoprotos.Settings.Master.GymBattleSettings! {
               get {
                   if battleSettingsBuilder_ != nil {
                      builderResult.battleSettings = battleSettingsBuilder_.getMessage()
                   }
                   return builderResult.battleSettings
               }
               set (value) {
                   builderResult.hasBattleSettings = true
                   builderResult.battleSettings = value
               }
          }
          fileprivate var battleSettingsBuilder_:Pogoprotos.Settings.Master.GymBattleSettings.Builder! {
               didSet {
                  builderResult.hasBattleSettings = true
               }
          }
          public func getBattleSettingsBuilder() -> Pogoprotos.Settings.Master.GymBattleSettings.Builder {
            if battleSettingsBuilder_ == nil {
               battleSettingsBuilder_ = Pogoprotos.Settings.Master.GymBattleSettings.Builder()
               builderResult.battleSettings = battleSettingsBuilder_.getMessage()
               if battleSettings != nil {
                  try! battleSettingsBuilder_.mergeFrom(other: battleSettings)
               }
            }
            return battleSettingsBuilder_
          }
          @discardableResult
          public func setBattleSettings(_ value:Pogoprotos.Settings.Master.GymBattleSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.battleSettings = value
            return self
          }
          @discardableResult
          public func mergeBattleSettings(value:Pogoprotos.Settings.Master.GymBattleSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasBattleSettings {
              builderResult.battleSettings = try Pogoprotos.Settings.Master.GymBattleSettings.builderWithPrototype(prototype:builderResult.battleSettings).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.battleSettings = value
            }
            builderResult.hasBattleSettings = true
            return self
          }
          @discardableResult
          public func clearBattleSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            battleSettingsBuilder_ = nil
            builderResult.hasBattleSettings = false
            builderResult.battleSettings = nil
            return self
          }
          public var hasEncounterSettings:Bool {
               get {
                   return builderResult.hasEncounterSettings
               }
          }
          public var encounterSettings:Pogoprotos.Settings.Master.EncounterSettings! {
               get {
                   if encounterSettingsBuilder_ != nil {
                      builderResult.encounterSettings = encounterSettingsBuilder_.getMessage()
                   }
                   return builderResult.encounterSettings
               }
               set (value) {
                   builderResult.hasEncounterSettings = true
                   builderResult.encounterSettings = value
               }
          }
          fileprivate var encounterSettingsBuilder_:Pogoprotos.Settings.Master.EncounterSettings.Builder! {
               didSet {
                  builderResult.hasEncounterSettings = true
               }
          }
          public func getEncounterSettingsBuilder() -> Pogoprotos.Settings.Master.EncounterSettings.Builder {
            if encounterSettingsBuilder_ == nil {
               encounterSettingsBuilder_ = Pogoprotos.Settings.Master.EncounterSettings.Builder()
               builderResult.encounterSettings = encounterSettingsBuilder_.getMessage()
               if encounterSettings != nil {
                  try! encounterSettingsBuilder_.mergeFrom(other: encounterSettings)
               }
            }
            return encounterSettingsBuilder_
          }
          @discardableResult
          public func setEncounterSettings(_ value:Pogoprotos.Settings.Master.EncounterSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.encounterSettings = value
            return self
          }
          @discardableResult
          public func mergeEncounterSettings(value:Pogoprotos.Settings.Master.EncounterSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasEncounterSettings {
              builderResult.encounterSettings = try Pogoprotos.Settings.Master.EncounterSettings.builderWithPrototype(prototype:builderResult.encounterSettings).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.encounterSettings = value
            }
            builderResult.hasEncounterSettings = true
            return self
          }
          @discardableResult
          public func clearEncounterSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            encounterSettingsBuilder_ = nil
            builderResult.hasEncounterSettings = false
            builderResult.encounterSettings = nil
            return self
          }
          public var hasIapItemDisplay:Bool {
               get {
                   return builderResult.hasIapItemDisplay
               }
          }
          public var iapItemDisplay:Pogoprotos.Settings.Master.IapItemDisplay! {
               get {
                   if iapItemDisplayBuilder_ != nil {
                      builderResult.iapItemDisplay = iapItemDisplayBuilder_.getMessage()
                   }
                   return builderResult.iapItemDisplay
               }
               set (value) {
                   builderResult.hasIapItemDisplay = true
                   builderResult.iapItemDisplay = value
               }
          }
          fileprivate var iapItemDisplayBuilder_:Pogoprotos.Settings.Master.IapItemDisplay.Builder! {
               didSet {
                  builderResult.hasIapItemDisplay = true
               }
          }
          public func getIapItemDisplayBuilder() -> Pogoprotos.Settings.Master.IapItemDisplay.Builder {
            if iapItemDisplayBuilder_ == nil {
               iapItemDisplayBuilder_ = Pogoprotos.Settings.Master.IapItemDisplay.Builder()
               builderResult.iapItemDisplay = iapItemDisplayBuilder_.getMessage()
               if iapItemDisplay != nil {
                  try! iapItemDisplayBuilder_.mergeFrom(other: iapItemDisplay)
               }
            }
            return iapItemDisplayBuilder_
          }
          @discardableResult
          public func setIapItemDisplay(_ value:Pogoprotos.Settings.Master.IapItemDisplay!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.iapItemDisplay = value
            return self
          }
          @discardableResult
          public func mergeIapItemDisplay(value:Pogoprotos.Settings.Master.IapItemDisplay) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasIapItemDisplay {
              builderResult.iapItemDisplay = try Pogoprotos.Settings.Master.IapItemDisplay.builderWithPrototype(prototype:builderResult.iapItemDisplay).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.iapItemDisplay = value
            }
            builderResult.hasIapItemDisplay = true
            return self
          }
          @discardableResult
          public func clearIapItemDisplay() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            iapItemDisplayBuilder_ = nil
            builderResult.hasIapItemDisplay = false
            builderResult.iapItemDisplay = nil
            return self
          }
          public var hasIapSettings:Bool {
               get {
                   return builderResult.hasIapSettings
               }
          }
          public var iapSettings:Pogoprotos.Settings.Master.IapSettings! {
               get {
                   if iapSettingsBuilder_ != nil {
                      builderResult.iapSettings = iapSettingsBuilder_.getMessage()
                   }
                   return builderResult.iapSettings
               }
               set (value) {
                   builderResult.hasIapSettings = true
                   builderResult.iapSettings = value
               }
          }
          fileprivate var iapSettingsBuilder_:Pogoprotos.Settings.Master.IapSettings.Builder! {
               didSet {
                  builderResult.hasIapSettings = true
               }
          }
          public func getIapSettingsBuilder() -> Pogoprotos.Settings.Master.IapSettings.Builder {
            if iapSettingsBuilder_ == nil {
               iapSettingsBuilder_ = Pogoprotos.Settings.Master.IapSettings.Builder()
               builderResult.iapSettings = iapSettingsBuilder_.getMessage()
               if iapSettings != nil {
                  try! iapSettingsBuilder_.mergeFrom(other: iapSettings)
               }
            }
            return iapSettingsBuilder_
          }
          @discardableResult
          public func setIapSettings(_ value:Pogoprotos.Settings.Master.IapSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.iapSettings = value
            return self
          }
          @discardableResult
          public func mergeIapSettings(value:Pogoprotos.Settings.Master.IapSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasIapSettings {
              builderResult.iapSettings = try Pogoprotos.Settings.Master.IapSettings.builderWithPrototype(prototype:builderResult.iapSettings).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.iapSettings = value
            }
            builderResult.hasIapSettings = true
            return self
          }
          @discardableResult
          public func clearIapSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            iapSettingsBuilder_ = nil
            builderResult.hasIapSettings = false
            builderResult.iapSettings = nil
            return self
          }
          public var hasPokemonUpgrades:Bool {
               get {
                   return builderResult.hasPokemonUpgrades
               }
          }
          public var pokemonUpgrades:Pogoprotos.Settings.Master.PokemonUpgradeSettings! {
               get {
                   if pokemonUpgradesBuilder_ != nil {
                      builderResult.pokemonUpgrades = pokemonUpgradesBuilder_.getMessage()
                   }
                   return builderResult.pokemonUpgrades
               }
               set (value) {
                   builderResult.hasPokemonUpgrades = true
                   builderResult.pokemonUpgrades = value
               }
          }
          fileprivate var pokemonUpgradesBuilder_:Pogoprotos.Settings.Master.PokemonUpgradeSettings.Builder! {
               didSet {
                  builderResult.hasPokemonUpgrades = true
               }
          }
          public func getPokemonUpgradesBuilder() -> Pogoprotos.Settings.Master.PokemonUpgradeSettings.Builder {
            if pokemonUpgradesBuilder_ == nil {
               pokemonUpgradesBuilder_ = Pogoprotos.Settings.Master.PokemonUpgradeSettings.Builder()
               builderResult.pokemonUpgrades = pokemonUpgradesBuilder_.getMessage()
               if pokemonUpgrades != nil {
                  try! pokemonUpgradesBuilder_.mergeFrom(other: pokemonUpgrades)
               }
            }
            return pokemonUpgradesBuilder_
          }
          @discardableResult
          public func setPokemonUpgrades(_ value:Pogoprotos.Settings.Master.PokemonUpgradeSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.pokemonUpgrades = value
            return self
          }
          @discardableResult
          public func mergePokemonUpgrades(value:Pogoprotos.Settings.Master.PokemonUpgradeSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasPokemonUpgrades {
              builderResult.pokemonUpgrades = try Pogoprotos.Settings.Master.PokemonUpgradeSettings.builderWithPrototype(prototype:builderResult.pokemonUpgrades).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.pokemonUpgrades = value
            }
            builderResult.hasPokemonUpgrades = true
            return self
          }
          @discardableResult
          public func clearPokemonUpgrades() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            pokemonUpgradesBuilder_ = nil
            builderResult.hasPokemonUpgrades = false
            builderResult.pokemonUpgrades = nil
            return self
          }
          public var hasEquippedBadges:Bool {
               get {
                   return builderResult.hasEquippedBadges
               }
          }
          public var equippedBadges:Pogoprotos.Settings.Master.EquippedBadgeSettings! {
               get {
                   if equippedBadgesBuilder_ != nil {
                      builderResult.equippedBadges = equippedBadgesBuilder_.getMessage()
                   }
                   return builderResult.equippedBadges
               }
               set (value) {
                   builderResult.hasEquippedBadges = true
                   builderResult.equippedBadges = value
               }
          }
          fileprivate var equippedBadgesBuilder_:Pogoprotos.Settings.Master.EquippedBadgeSettings.Builder! {
               didSet {
                  builderResult.hasEquippedBadges = true
               }
          }
          public func getEquippedBadgesBuilder() -> Pogoprotos.Settings.Master.EquippedBadgeSettings.Builder {
            if equippedBadgesBuilder_ == nil {
               equippedBadgesBuilder_ = Pogoprotos.Settings.Master.EquippedBadgeSettings.Builder()
               builderResult.equippedBadges = equippedBadgesBuilder_.getMessage()
               if equippedBadges != nil {
                  try! equippedBadgesBuilder_.mergeFrom(other: equippedBadges)
               }
            }
            return equippedBadgesBuilder_
          }
          @discardableResult
          public func setEquippedBadges(_ value:Pogoprotos.Settings.Master.EquippedBadgeSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.equippedBadges = value
            return self
          }
          @discardableResult
          public func mergeEquippedBadges(value:Pogoprotos.Settings.Master.EquippedBadgeSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasEquippedBadges {
              builderResult.equippedBadges = try Pogoprotos.Settings.Master.EquippedBadgeSettings.builderWithPrototype(prototype:builderResult.equippedBadges).mergeFrom(other: value).buildPartial()
            } else {
              builderResult.equippedBadges = value
            }
            builderResult.hasEquippedBadges = true
            return self
          }
          @discardableResult
          public func clearEquippedBadges() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            equippedBadgesBuilder_ = nil
            builderResult.hasEquippedBadges = false
            builderResult.equippedBadges = nil
            return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          @discardableResult
          override public func clear() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            builderResult = Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate()
            return self
          }
          override public func clone() throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.builderWithPrototype(prototype:builderResult)
          }
          override public func build() throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
            let returnMe:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate = builderResult
            return returnMe
          }
          @discardableResult
          public func mergeFrom(other:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if other == Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate() {
             return self
            }
            if other.hasTemplateId {
                 templateId = other.templateId
            }
            if (other.hasPokemonSettings) {
                try mergePokemonSettings(value: other.pokemonSettings)
            }
            if (other.hasItemSettings) {
                try mergeItemSettings(value: other.itemSettings)
            }
            if (other.hasMoveSettings) {
                try mergeMoveSettings(value: other.moveSettings)
            }
            if (other.hasMoveSequenceSettings) {
                try mergeMoveSequenceSettings(value: other.moveSequenceSettings)
            }
            if (other.hasTypeEffective) {
                try mergeTypeEffective(value: other.typeEffective)
            }
            if (other.hasBadgeSettings) {
                try mergeBadgeSettings(value: other.badgeSettings)
            }
            if (other.hasCamera) {
                try mergeCamera(value: other.camera)
            }
            if (other.hasPlayerLevel) {
                try mergePlayerLevel(value: other.playerLevel)
            }
            if (other.hasGymLevel) {
                try mergeGymLevel(value: other.gymLevel)
            }
            if (other.hasBattleSettings) {
                try mergeBattleSettings(value: other.battleSettings)
            }
            if (other.hasEncounterSettings) {
                try mergeEncounterSettings(value: other.encounterSettings)
            }
            if (other.hasIapItemDisplay) {
                try mergeIapItemDisplay(value: other.iapItemDisplay)
            }
            if (other.hasIapSettings) {
                try mergeIapSettings(value: other.iapSettings)
            }
            if (other.hasPokemonUpgrades) {
                try mergePokemonUpgrades(value: other.pokemonUpgrades)
            }
            if (other.hasEquippedBadges) {
                try mergeEquippedBadges(value: other.equippedBadges)
            }
            _ = try merge(unknownField: other.unknownFields)
            return self
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
               return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
          }
          @discardableResult
          override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
              let protobufTag = try codedInputStream.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10:
                templateId = try codedInputStream.readString()

              case 18:
                let subBuilder:Pogoprotos.Settings.Master.PokemonSettings.Builder = Pogoprotos.Settings.Master.PokemonSettings.Builder()
                if hasPokemonSettings {
                  try subBuilder.mergeFrom(other: pokemonSettings)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                pokemonSettings = subBuilder.buildPartial()

              case 26:
                let subBuilder:Pogoprotos.Settings.Master.ItemSettings.Builder = Pogoprotos.Settings.Master.ItemSettings.Builder()
                if hasItemSettings {
                  try subBuilder.mergeFrom(other: itemSettings)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                itemSettings = subBuilder.buildPartial()

              case 34:
                let subBuilder:Pogoprotos.Settings.Master.MoveSettings.Builder = Pogoprotos.Settings.Master.MoveSettings.Builder()
                if hasMoveSettings {
                  try subBuilder.mergeFrom(other: moveSettings)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                moveSettings = subBuilder.buildPartial()

              case 42:
                let subBuilder:Pogoprotos.Settings.Master.MoveSequenceSettings.Builder = Pogoprotos.Settings.Master.MoveSequenceSettings.Builder()
                if hasMoveSequenceSettings {
                  try subBuilder.mergeFrom(other: moveSequenceSettings)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                moveSequenceSettings = subBuilder.buildPartial()

              case 66:
                let subBuilder:Pogoprotos.Settings.Master.TypeEffectiveSettings.Builder = Pogoprotos.Settings.Master.TypeEffectiveSettings.Builder()
                if hasTypeEffective {
                  try subBuilder.mergeFrom(other: typeEffective)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                typeEffective = subBuilder.buildPartial()

              case 82:
                let subBuilder:Pogoprotos.Settings.Master.BadgeSettings.Builder = Pogoprotos.Settings.Master.BadgeSettings.Builder()
                if hasBadgeSettings {
                  try subBuilder.mergeFrom(other: badgeSettings)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                badgeSettings = subBuilder.buildPartial()

              case 90:
                let subBuilder:Pogoprotos.Settings.Master.CameraSettings.Builder = Pogoprotos.Settings.Master.CameraSettings.Builder()
                if hasCamera {
                  try subBuilder.mergeFrom(other: camera)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                camera = subBuilder.buildPartial()

              case 98:
                let subBuilder:Pogoprotos.Settings.Master.PlayerLevelSettings.Builder = Pogoprotos.Settings.Master.PlayerLevelSettings.Builder()
                if hasPlayerLevel {
                  try subBuilder.mergeFrom(other: playerLevel)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                playerLevel = subBuilder.buildPartial()

              case 106:
                let subBuilder:Pogoprotos.Settings.Master.GymLevelSettings.Builder = Pogoprotos.Settings.Master.GymLevelSettings.Builder()
                if hasGymLevel {
                  try subBuilder.mergeFrom(other: gymLevel)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                gymLevel = subBuilder.buildPartial()

              case 114:
                let subBuilder:Pogoprotos.Settings.Master.GymBattleSettings.Builder = Pogoprotos.Settings.Master.GymBattleSettings.Builder()
                if hasBattleSettings {
                  try subBuilder.mergeFrom(other: battleSettings)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                battleSettings = subBuilder.buildPartial()

              case 122:
                let subBuilder:Pogoprotos.Settings.Master.EncounterSettings.Builder = Pogoprotos.Settings.Master.EncounterSettings.Builder()
                if hasEncounterSettings {
                  try subBuilder.mergeFrom(other: encounterSettings)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                encounterSettings = subBuilder.buildPartial()

              case 130:
                let subBuilder:Pogoprotos.Settings.Master.IapItemDisplay.Builder = Pogoprotos.Settings.Master.IapItemDisplay.Builder()
                if hasIapItemDisplay {
                  try subBuilder.mergeFrom(other: iapItemDisplay)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                iapItemDisplay = subBuilder.buildPartial()

              case 138:
                let subBuilder:Pogoprotos.Settings.Master.IapSettings.Builder = Pogoprotos.Settings.Master.IapSettings.Builder()
                if hasIapSettings {
                  try subBuilder.mergeFrom(other: iapSettings)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                iapSettings = subBuilder.buildPartial()

              case 146:
                let subBuilder:Pogoprotos.Settings.Master.PokemonUpgradeSettings.Builder = Pogoprotos.Settings.Master.PokemonUpgradeSettings.Builder()
                if hasPokemonUpgrades {
                  try subBuilder.mergeFrom(other: pokemonUpgrades)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                pokemonUpgrades = subBuilder.buildPartial()

              case 154:
                let subBuilder:Pogoprotos.Settings.Master.EquippedBadgeSettings.Builder = Pogoprotos.Settings.Master.EquippedBadgeSettings.Builder()
                if hasEquippedBadges {
                  try subBuilder.mergeFrom(other: equippedBadges)
                }
                try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                equippedBadges = subBuilder.buildPartial()

              default:
                if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            let resultDecodedBuilder = Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder()
            if let jsonValueTemplateId = jsonMap["templateId"] as? String {
              resultDecodedBuilder.templateId = jsonValueTemplateId
            }
            if let jsonValuePokemonSettings = jsonMap["pokemonSettings"] as? Dictionary<String,Any> {
              resultDecodedBuilder.pokemonSettings = try Pogoprotos.Settings.Master.PokemonSettings.Builder.decodeToBuilder(jsonMap:jsonValuePokemonSettings).build()

            }
            if let jsonValueItemSettings = jsonMap["itemSettings"] as? Dictionary<String,Any> {
              resultDecodedBuilder.itemSettings = try Pogoprotos.Settings.Master.ItemSettings.Builder.decodeToBuilder(jsonMap:jsonValueItemSettings).build()

            }
            if let jsonValueMoveSettings = jsonMap["moveSettings"] as? Dictionary<String,Any> {
              resultDecodedBuilder.moveSettings = try Pogoprotos.Settings.Master.MoveSettings.Builder.decodeToBuilder(jsonMap:jsonValueMoveSettings).build()

            }
            if let jsonValueMoveSequenceSettings = jsonMap["moveSequenceSettings"] as? Dictionary<String,Any> {
              resultDecodedBuilder.moveSequenceSettings = try Pogoprotos.Settings.Master.MoveSequenceSettings.Builder.decodeToBuilder(jsonMap:jsonValueMoveSequenceSettings).build()

            }
            if let jsonValueTypeEffective = jsonMap["typeEffective"] as? Dictionary<String,Any> {
              resultDecodedBuilder.typeEffective = try Pogoprotos.Settings.Master.TypeEffectiveSettings.Builder.decodeToBuilder(jsonMap:jsonValueTypeEffective).build()

            }
            if let jsonValueBadgeSettings = jsonMap["badgeSettings"] as? Dictionary<String,Any> {
              resultDecodedBuilder.badgeSettings = try Pogoprotos.Settings.Master.BadgeSettings.Builder.decodeToBuilder(jsonMap:jsonValueBadgeSettings).build()

            }
            if let jsonValueCamera = jsonMap["camera"] as? Dictionary<String,Any> {
              resultDecodedBuilder.camera = try Pogoprotos.Settings.Master.CameraSettings.Builder.decodeToBuilder(jsonMap:jsonValueCamera).build()

            }
            if let jsonValuePlayerLevel = jsonMap["playerLevel"] as? Dictionary<String,Any> {
              resultDecodedBuilder.playerLevel = try Pogoprotos.Settings.Master.PlayerLevelSettings.Builder.decodeToBuilder(jsonMap:jsonValuePlayerLevel).build()

            }
            if let jsonValueGymLevel = jsonMap["gymLevel"] as? Dictionary<String,Any> {
              resultDecodedBuilder.gymLevel = try Pogoprotos.Settings.Master.GymLevelSettings.Builder.decodeToBuilder(jsonMap:jsonValueGymLevel).build()

            }
            if let jsonValueBattleSettings = jsonMap["battleSettings"] as? Dictionary<String,Any> {
              resultDecodedBuilder.battleSettings = try Pogoprotos.Settings.Master.GymBattleSettings.Builder.decodeToBuilder(jsonMap:jsonValueBattleSettings).build()

            }
            if let jsonValueEncounterSettings = jsonMap["encounterSettings"] as? Dictionary<String,Any> {
              resultDecodedBuilder.encounterSettings = try Pogoprotos.Settings.Master.EncounterSettings.Builder.decodeToBuilder(jsonMap:jsonValueEncounterSettings).build()

            }
            if let jsonValueIapItemDisplay = jsonMap["iapItemDisplay"] as? Dictionary<String,Any> {
              resultDecodedBuilder.iapItemDisplay = try Pogoprotos.Settings.Master.IapItemDisplay.Builder.decodeToBuilder(jsonMap:jsonValueIapItemDisplay).build()

            }
            if let jsonValueIapSettings = jsonMap["iapSettings"] as? Dictionary<String,Any> {
              resultDecodedBuilder.iapSettings = try Pogoprotos.Settings.Master.IapSettings.Builder.decodeToBuilder(jsonMap:jsonValueIapSettings).build()

            }
            if let jsonValuePokemonUpgrades = jsonMap["pokemonUpgrades"] as? Dictionary<String,Any> {
              resultDecodedBuilder.pokemonUpgrades = try Pogoprotos.Settings.Master.PokemonUpgradeSettings.Builder.decodeToBuilder(jsonMap:jsonValuePokemonUpgrades).build()

            }
            if let jsonValueEquippedBadges = jsonMap["equippedBadges"] as? Dictionary<String,Any> {
              resultDecodedBuilder.equippedBadges = try Pogoprotos.Settings.Master.EquippedBadgeSettings.Builder.decodeToBuilder(jsonMap:jsonValueEquippedBadges).build()

            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder.decodeToBuilder(jsonMap:jsDataCast)
          }
        }

      }

    //Nested type declaration end

    public fileprivate(set) var success:Bool = false
    public fileprivate(set) var hasSuccess:Bool = false

    public fileprivate(set) var itemTemplates:Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate>  = Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate>()
    public fileprivate(set) var timestampMs:UInt64 = UInt64(0)
    public fileprivate(set) var hasTimestampMs:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasSuccess {
        try codedOutputStream.writeBool(fieldNumber: 1, value:success)
      }
      for oneElementItemTemplates in itemTemplates {
          try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementItemTemplates)
      }
      if hasTimestampMs {
        try codedOutputStream.writeUInt64(fieldNumber: 3, value:timestampMs)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(fieldNumber: 1)
      }
      for oneElementItemTemplates in itemTemplates {
          serialize_size += oneElementItemTemplates.computeMessageSize(fieldNumber: 2)
      }
      if hasTimestampMs {
        serialize_size += timestampMs.computeUInt64Size(fieldNumber: 3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
      return Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.classBuilder() as! Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if !itemTemplates.isEmpty {
        var jsonArrayItemTemplates:Array<Dictionary<String,Any>> = []
          for oneValueItemTemplates in itemTemplates {
            let ecodedMessageItemTemplates = try oneValueItemTemplates.encode()
            jsonArrayItemTemplates.append(ecodedMessageItemTemplates)
          }
        jsonMap["itemTemplates"] = jsonArrayItemTemplates
      }
      if hasTimestampMs {
        jsonMap["timestampMs"] = "\(timestampMs)"
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      var itemTemplatesElementIndex:Int = 0
      for oneElementItemTemplates in itemTemplates {
          output += "\(indent) itemTemplates[\(itemTemplatesElementIndex)] {\n"
          output += try oneElementItemTemplates.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          itemTemplatesElementIndex += 1
      }
      if hasTimestampMs {
        output += "\(indent) timestampMs: \(timestampMs) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            for oneElementItemTemplates in itemTemplates {
                hashCode = (hashCode &* 31) &+ oneElementItemTemplates.hashValue
            }
            if hasTimestampMs {
               hashCode = (hashCode &* 31) &+ timestampMs.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse = Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      @discardableResult
      public func setSuccess(_ value:Bool) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        self.success = value
        return self
      }
      @discardableResult
      public func clearSuccess() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var itemTemplates:Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate> {
           get {
               return builderResult.itemTemplates
           }
           set (value) {
               builderResult.itemTemplates = value
           }
      }
      @discardableResult
      public func setItemTemplates(_ value:Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate>) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        self.itemTemplates = value
        return self
      }
      @discardableResult
      public func clearItemTemplates() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        builderResult.itemTemplates.removeAll(keepingCapacity: false)
        return self
      }
      public var hasTimestampMs:Bool {
           get {
                return builderResult.hasTimestampMs
           }
      }
      public var timestampMs:UInt64 {
           get {
                return builderResult.timestampMs
           }
           set (value) {
               builderResult.hasTimestampMs = true
               builderResult.timestampMs = value
           }
      }
      @discardableResult
      public func setTimestampMs(_ value:UInt64) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        self.timestampMs = value
        return self
      }
      @discardableResult
      public func clearTimestampMs() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder{
           builderResult.hasTimestampMs = false
           builderResult.timestampMs = UInt64(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
        let returnMe:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        if other == Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if !other.itemTemplates.isEmpty  {
           builderResult.itemTemplates += other.itemTemplates
        }
        if other.hasTimestampMs {
             timestampMs = other.timestampMs
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try codedInputStream.readBool()

          case 18:
            let subBuilder = Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            itemTemplates.append(subBuilder.buildPartial())

          case 24:
            timestampMs = try codedInputStream.readUInt64()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValueItemTemplates = jsonMap["itemTemplates"] as? Array<Dictionary<String,Any>> {
          var jsonArrayItemTemplates:Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate> = []
          for oneValueItemTemplates in jsonValueItemTemplates {
            let messageFromStringItemTemplates = try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder.decodeToBuilder(jsonMap:oneValueItemTemplates).build()

            jsonArrayItemTemplates.append(messageFromStringItemTemplates)
          }
          resultDecodedBuilder.itemTemplates = jsonArrayItemTemplates
        }
        if let jsonValueTimestampMs = jsonMap["timestampMs"] as? String {
          resultDecodedBuilder.timestampMs = UInt64(jsonValueTimestampMs)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class DownloadRemoteConfigVersionResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse, rhs: Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasItemTemplatesTimestampMs == rhs.hasItemTemplatesTimestampMs) && (!lhs.hasItemTemplatesTimestampMs || lhs.itemTemplatesTimestampMs == rhs.itemTemplatesTimestampMs)
      fieldCheck = fieldCheck && (lhs.hasAssetDigestTimestampMs == rhs.hasAssetDigestTimestampMs) && (!lhs.hasAssetDigestTimestampMs || lhs.assetDigestTimestampMs == rhs.assetDigestTimestampMs)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Result = Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    // Latest available?
    public fileprivate(set) var itemTemplatesTimestampMs:UInt64 = UInt64(0)
    public fileprivate(set) var hasItemTemplatesTimestampMs:Bool = false

    public fileprivate(set) var assetDigestTimestampMs:UInt64 = UInt64(0)
    public fileprivate(set) var hasAssetDigestTimestampMs:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasItemTemplatesTimestampMs {
        try codedOutputStream.writeUInt64(fieldNumber: 2, value:itemTemplatesTimestampMs)
      }
      if hasAssetDigestTimestampMs {
        try codedOutputStream.writeUInt64(fieldNumber: 3, value:assetDigestTimestampMs)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasItemTemplatesTimestampMs {
        serialize_size += itemTemplatesTimestampMs.computeUInt64Size(fieldNumber: 2)
      }
      if hasAssetDigestTimestampMs {
        serialize_size += assetDigestTimestampMs.computeUInt64Size(fieldNumber: 3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
      return Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.classBuilder() as! Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasItemTemplatesTimestampMs {
        jsonMap["itemTemplatesTimestampMs"] = "\(itemTemplatesTimestampMs)"
      }
      if hasAssetDigestTimestampMs {
        jsonMap["assetDigestTimestampMs"] = "\(assetDigestTimestampMs)"
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasItemTemplatesTimestampMs {
        output += "\(indent) itemTemplatesTimestampMs: \(itemTemplatesTimestampMs) \n"
      }
      if hasAssetDigestTimestampMs {
        output += "\(indent) assetDigestTimestampMs: \(assetDigestTimestampMs) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasItemTemplatesTimestampMs {
               hashCode = (hashCode &* 31) &+ itemTemplatesTimestampMs.hashValue
            }
            if hasAssetDigestTimestampMs {
               hashCode = (hashCode &* 31) &+ assetDigestTimestampMs.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse = Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Result) -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasItemTemplatesTimestampMs:Bool {
           get {
                return builderResult.hasItemTemplatesTimestampMs
           }
      }
      public var itemTemplatesTimestampMs:UInt64 {
           get {
                return builderResult.itemTemplatesTimestampMs
           }
           set (value) {
               builderResult.hasItemTemplatesTimestampMs = true
               builderResult.itemTemplatesTimestampMs = value
           }
      }
      @discardableResult
      public func setItemTemplatesTimestampMs(_ value:UInt64) -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        self.itemTemplatesTimestampMs = value
        return self
      }
      @discardableResult
      public func clearItemTemplatesTimestampMs() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder{
           builderResult.hasItemTemplatesTimestampMs = false
           builderResult.itemTemplatesTimestampMs = UInt64(0)
           return self
      }
      public var hasAssetDigestTimestampMs:Bool {
           get {
                return builderResult.hasAssetDigestTimestampMs
           }
      }
      public var assetDigestTimestampMs:UInt64 {
           get {
                return builderResult.assetDigestTimestampMs
           }
           set (value) {
               builderResult.hasAssetDigestTimestampMs = true
               builderResult.assetDigestTimestampMs = value
           }
      }
      @discardableResult
      public func setAssetDigestTimestampMs(_ value:UInt64) -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        self.assetDigestTimestampMs = value
        return self
      }
      @discardableResult
      public func clearAssetDigestTimestampMs() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder{
           builderResult.hasAssetDigestTimestampMs = false
           builderResult.assetDigestTimestampMs = UInt64(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
        let returnMe:Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        if other == Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasItemTemplatesTimestampMs {
             itemTemplatesTimestampMs = other.itemTemplatesTimestampMs
        }
        if other.hasAssetDigestTimestampMs {
             assetDigestTimestampMs = other.assetDigestTimestampMs
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 16:
            itemTemplatesTimestampMs = try codedInputStream.readUInt64()

          case 24:
            assetDigestTimestampMs = try codedInputStream.readUInt64()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueItemTemplatesTimestampMs = jsonMap["itemTemplatesTimestampMs"] as? String {
          resultDecodedBuilder.itemTemplatesTimestampMs = UInt64(jsonValueItemTemplatesTimestampMs)!
        }
        if let jsonValueAssetDigestTimestampMs = jsonMap["assetDigestTimestampMs"] as? String {
          resultDecodedBuilder.assetDigestTimestampMs = UInt64(jsonValueAssetDigestTimestampMs)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class DownloadSettingsResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.DownloadSettingsResponse, rhs: Pogoprotos.Networking.Responses.DownloadSettingsResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasError == rhs.hasError) && (!lhs.hasError || lhs.error == rhs.error)
      fieldCheck = fieldCheck && (lhs.hasHash == rhs.hasHash) && (!lhs.hasHash || lhs.hash == rhs.hash)
      fieldCheck = fieldCheck && (lhs.hasSettings == rhs.hasSettings) && (!lhs.hasSettings || lhs.settings == rhs.settings)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var error:String = ""
    public fileprivate(set) var hasError:Bool = false

    public fileprivate(set) var hash:String = ""
    public fileprivate(set) var hasHash:Bool = false

    public fileprivate(set) var settings:Pogoprotos.Settings.GlobalSettings!
    public fileprivate(set) var hasSettings:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasError {
        try codedOutputStream.writeString(fieldNumber: 1, value:error)
      }
      if hasHash {
        try codedOutputStream.writeString(fieldNumber: 2, value:hash)
      }
      if hasSettings {
        try codedOutputStream.writeMessage(fieldNumber: 3, value:settings)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasError {
        serialize_size += error.computeStringSize(fieldNumber: 1)
      }
      if hasHash {
        serialize_size += hash.computeStringSize(fieldNumber: 2)
      }
      if hasSettings {
          if let varSizesettings = settings?.computeMessageSize(fieldNumber: 3) {
              serialize_size += varSizesettings
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
      return Pogoprotos.Networking.Responses.DownloadSettingsResponse.classBuilder() as! Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.DownloadSettingsResponse) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasError {
        jsonMap["error"] = error
      }
      if hasHash {
        jsonMap["hash"] = hash
      }
      if hasSettings {
        jsonMap["settings"] = try settings.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasError {
        output += "\(indent) error: \(error) \n"
      }
      if hasHash {
        output += "\(indent) hash: \(hash) \n"
      }
      if hasSettings {
        output += "\(indent) settings {\n"
        if let outDescSettings = settings {
          output += try outDescSettings.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasError {
               hashCode = (hashCode &* 31) &+ error.hashValue
            }
            if hasHash {
               hashCode = (hashCode &* 31) &+ hash.hashValue
            }
            if hasSettings {
                if let hashValuesettings = settings?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuesettings
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.DownloadSettingsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.DownloadSettingsResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.DownloadSettingsResponse = Pogoprotos.Networking.Responses.DownloadSettingsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasError:Bool {
           get {
                return builderResult.hasError
           }
      }
      public var error:String {
           get {
                return builderResult.error
           }
           set (value) {
               builderResult.hasError = true
               builderResult.error = value
           }
      }
      @discardableResult
      public func setError(_ value:String) -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        self.error = value
        return self
      }
      @discardableResult
      public func clearError() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder{
           builderResult.hasError = false
           builderResult.error = ""
           return self
      }
      public var hasHash:Bool {
           get {
                return builderResult.hasHash
           }
      }
      public var hash:String {
           get {
                return builderResult.hash
           }
           set (value) {
               builderResult.hasHash = true
               builderResult.hash = value
           }
      }
      @discardableResult
      public func setHash(_ value:String) -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        self.hash = value
        return self
      }
      @discardableResult
      public func clearHash() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder{
           builderResult.hasHash = false
           builderResult.hash = ""
           return self
      }
      public var hasSettings:Bool {
           get {
               return builderResult.hasSettings
           }
      }
      public var settings:Pogoprotos.Settings.GlobalSettings! {
           get {
               if settingsBuilder_ != nil {
                  builderResult.settings = settingsBuilder_.getMessage()
               }
               return builderResult.settings
           }
           set (value) {
               builderResult.hasSettings = true
               builderResult.settings = value
           }
      }
      fileprivate var settingsBuilder_:Pogoprotos.Settings.GlobalSettings.Builder! {
           didSet {
              builderResult.hasSettings = true
           }
      }
      public func getSettingsBuilder() -> Pogoprotos.Settings.GlobalSettings.Builder {
        if settingsBuilder_ == nil {
           settingsBuilder_ = Pogoprotos.Settings.GlobalSettings.Builder()
           builderResult.settings = settingsBuilder_.getMessage()
           if settings != nil {
              try! settingsBuilder_.mergeFrom(other: settings)
           }
        }
        return settingsBuilder_
      }
      @discardableResult
      public func setSettings(_ value:Pogoprotos.Settings.GlobalSettings!) -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        self.settings = value
        return self
      }
      @discardableResult
      public func mergeSettings(value:Pogoprotos.Settings.GlobalSettings) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        if builderResult.hasSettings {
          builderResult.settings = try Pogoprotos.Settings.GlobalSettings.builderWithPrototype(prototype:builderResult.settings).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.settings = value
        }
        builderResult.hasSettings = true
        return self
      }
      @discardableResult
      public func clearSettings() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        settingsBuilder_ = nil
        builderResult.hasSettings = false
        builderResult.settings = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.DownloadSettingsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
        let returnMe:Pogoprotos.Networking.Responses.DownloadSettingsResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.DownloadSettingsResponse) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.DownloadSettingsResponse() {
         return self
        }
        if other.hasError {
             error = other.error
        }
        if other.hasHash {
             hash = other.hash
        }
        if (other.hasSettings) {
            try mergeSettings(value: other.settings)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            error = try codedInputStream.readString()

          case 18:
            hash = try codedInputStream.readString()

          case 26:
            let subBuilder:Pogoprotos.Settings.GlobalSettings.Builder = Pogoprotos.Settings.GlobalSettings.Builder()
            if hasSettings {
              try subBuilder.mergeFrom(other: settings)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            settings = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder()
        if let jsonValueError = jsonMap["error"] as? String {
          resultDecodedBuilder.error = jsonValueError
        }
        if let jsonValueHash = jsonMap["hash"] as? String {
          resultDecodedBuilder.hash = jsonValueHash
        }
        if let jsonValueSettings = jsonMap["settings"] as? Dictionary<String,Any> {
          resultDecodedBuilder.settings = try Pogoprotos.Settings.GlobalSettings.Builder.decodeToBuilder(jsonMap:jsonValueSettings).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class EchoResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.EchoResponse, rhs: Pogoprotos.Networking.Responses.EchoResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasContext == rhs.hasContext) && (!lhs.hasContext || lhs.context == rhs.context)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var context:String = ""
    public fileprivate(set) var hasContext:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasContext {
        try codedOutputStream.writeString(fieldNumber: 1, value:context)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasContext {
        serialize_size += context.computeStringSize(fieldNumber: 1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
      return Pogoprotos.Networking.Responses.EchoResponse.classBuilder() as! Pogoprotos.Networking.Responses.EchoResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.EchoResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.EchoResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.EchoResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
      return try Pogoprotos.Networking.Responses.EchoResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.EchoResponse) throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
      return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasContext {
        jsonMap["context"] = context
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.EchoResponse {
      return try Pogoprotos.Networking.Responses.EchoResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.EchoResponse {
      return try Pogoprotos.Networking.Responses.EchoResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasContext {
        output += "\(indent) context: \(context) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasContext {
               hashCode = (hashCode &* 31) &+ context.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.EchoResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.EchoResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.EchoResponse = Pogoprotos.Networking.Responses.EchoResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.EchoResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasContext:Bool {
           get {
                return builderResult.hasContext
           }
      }
      public var context:String {
           get {
                return builderResult.context
           }
           set (value) {
               builderResult.hasContext = true
               builderResult.context = value
           }
      }
      @discardableResult
      public func setContext(_ value:String) -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
        self.context = value
        return self
      }
      @discardableResult
      public func clearContext() -> Pogoprotos.Networking.Responses.EchoResponse.Builder{
           builderResult.hasContext = false
           builderResult.context = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.EchoResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
        return try Pogoprotos.Networking.Responses.EchoResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.EchoResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.EchoResponse {
        let returnMe:Pogoprotos.Networking.Responses.EchoResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.EchoResponse) throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
        if other == Pogoprotos.Networking.Responses.EchoResponse() {
         return self
        }
        if other.hasContext {
             context = other.context
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            context = try codedInputStream.readString()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.EchoResponse.Builder()
        if let jsonValueContext = jsonMap["context"] as? String {
          resultDecodedBuilder.context = jsonValueContext
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.EchoResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class EncounterResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.EncounterResponse, rhs: Pogoprotos.Networking.Responses.EncounterResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasWildPokemon == rhs.hasWildPokemon) && (!lhs.hasWildPokemon || lhs.wildPokemon == rhs.wildPokemon)
      fieldCheck = fieldCheck && (lhs.hasBackground == rhs.hasBackground) && (!lhs.hasBackground || lhs.background == rhs.background)
      fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
      fieldCheck = fieldCheck && (lhs.hasCaptureProbability == rhs.hasCaptureProbability) && (!lhs.hasCaptureProbability || lhs.captureProbability == rhs.captureProbability)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Background:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case park = 0
        case desert = 1
        public func toString() -> String {
          switch self {
          case .park: return "PARK"
          case .desert: return "DESERT"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Background {
          switch str {
          case "PARK":  return .park
          case "DESERT":  return .desert
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .park: return ".park"
          case .desert: return ".desert"
          }
        }
      }

      //Enum type declaration end 



      //Enum type declaration start 

      public enum Status:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case encounterError = 0
        case encounterSuccess = 1
        case encounterNotFound = 2
        case encounterClosed = 3
        case encounterPokemonFled = 4
        case encounterNotInRange = 5
        case encounterAlreadyHappened = 6
        case pokemonInventoryFull = 7
        public func toString() -> String {
          switch self {
          case .encounterError: return "ENCOUNTER_ERROR"
          case .encounterSuccess: return "ENCOUNTER_SUCCESS"
          case .encounterNotFound: return "ENCOUNTER_NOT_FOUND"
          case .encounterClosed: return "ENCOUNTER_CLOSED"
          case .encounterPokemonFled: return "ENCOUNTER_POKEMON_FLED"
          case .encounterNotInRange: return "ENCOUNTER_NOT_IN_RANGE"
          case .encounterAlreadyHappened: return "ENCOUNTER_ALREADY_HAPPENED"
          case .pokemonInventoryFull: return "POKEMON_INVENTORY_FULL"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Status {
          switch str {
          case "ENCOUNTER_ERROR":  return .encounterError
          case "ENCOUNTER_SUCCESS":  return .encounterSuccess
          case "ENCOUNTER_NOT_FOUND":  return .encounterNotFound
          case "ENCOUNTER_CLOSED":  return .encounterClosed
          case "ENCOUNTER_POKEMON_FLED":  return .encounterPokemonFled
          case "ENCOUNTER_NOT_IN_RANGE":  return .encounterNotInRange
          case "ENCOUNTER_ALREADY_HAPPENED":  return .encounterAlreadyHappened
          case "POKEMON_INVENTORY_FULL":  return .pokemonInventoryFull
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .encounterError: return ".encounterError"
          case .encounterSuccess: return ".encounterSuccess"
          case .encounterNotFound: return ".encounterNotFound"
          case .encounterClosed: return ".encounterClosed"
          case .encounterPokemonFled: return ".encounterPokemonFled"
          case .encounterNotInRange: return ".encounterNotInRange"
          case .encounterAlreadyHappened: return ".encounterAlreadyHappened"
          case .pokemonInventoryFull: return ".pokemonInventoryFull"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var wildPokemon:Pogoprotos.Map.Pokemon.WildPokemon!
    public fileprivate(set) var hasWildPokemon:Bool = false
    public fileprivate(set) var background:Pogoprotos.Networking.Responses.EncounterResponse.Background = Pogoprotos.Networking.Responses.EncounterResponse.Background.park
    public fileprivate(set) var hasBackground:Bool = false
    public fileprivate(set) var status:Pogoprotos.Networking.Responses.EncounterResponse.Status = Pogoprotos.Networking.Responses.EncounterResponse.Status.encounterError
    public fileprivate(set) var hasStatus:Bool = false
    public fileprivate(set) var captureProbability:Pogoprotos.Data.Capture.CaptureProbability!
    public fileprivate(set) var hasCaptureProbability:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasWildPokemon {
        try codedOutputStream.writeMessage(fieldNumber: 1, value:wildPokemon)
      }
      if hasBackground {
        try codedOutputStream.writeEnum(fieldNumber: 2, value:background.rawValue)
      }
      if hasStatus {
        try codedOutputStream.writeEnum(fieldNumber: 3, value:status.rawValue)
      }
      if hasCaptureProbability {
        try codedOutputStream.writeMessage(fieldNumber: 4, value:captureProbability)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasWildPokemon {
          if let varSizewildPokemon = wildPokemon?.computeMessageSize(fieldNumber: 1) {
              serialize_size += varSizewildPokemon
          }
      }
      if (hasBackground) {
        serialize_size += background.rawValue.computeEnumSize(fieldNumber: 2)
      }
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(fieldNumber: 3)
      }
      if hasCaptureProbability {
          if let varSizecaptureProbability = captureProbability?.computeMessageSize(fieldNumber: 4) {
              serialize_size += varSizecaptureProbability
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
      return Pogoprotos.Networking.Responses.EncounterResponse.classBuilder() as! Pogoprotos.Networking.Responses.EncounterResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.EncounterResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.EncounterResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.EncounterResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
      return try Pogoprotos.Networking.Responses.EncounterResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.EncounterResponse) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
      return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasWildPokemon {
        jsonMap["wildPokemon"] = try wildPokemon.encode()
      }
      if hasBackground {
        jsonMap["background"] = background.toString()
      }
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      if hasCaptureProbability {
        jsonMap["captureProbability"] = try captureProbability.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
      return try Pogoprotos.Networking.Responses.EncounterResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
      return try Pogoprotos.Networking.Responses.EncounterResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasWildPokemon {
        output += "\(indent) wildPokemon {\n"
        if let outDescWildPokemon = wildPokemon {
          output += try outDescWildPokemon.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if (hasBackground) {
        output += "\(indent) background: \(background.description)\n"
      }
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      if hasCaptureProbability {
        output += "\(indent) captureProbability {\n"
        if let outDescCaptureProbability = captureProbability {
          output += try outDescCaptureProbability.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasWildPokemon {
                if let hashValuewildPokemon = wildPokemon?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuewildPokemon
                }
            }
            if hasBackground {
               hashCode = (hashCode &* 31) &+ Int(background.rawValue)
            }
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            if hasCaptureProbability {
                if let hashValuecaptureProbability = captureProbability?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecaptureProbability
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.EncounterResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.EncounterResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.EncounterResponse = Pogoprotos.Networking.Responses.EncounterResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.EncounterResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasWildPokemon:Bool {
           get {
               return builderResult.hasWildPokemon
           }
      }
      public var wildPokemon:Pogoprotos.Map.Pokemon.WildPokemon! {
           get {
               if wildPokemonBuilder_ != nil {
                  builderResult.wildPokemon = wildPokemonBuilder_.getMessage()
               }
               return builderResult.wildPokemon
           }
           set (value) {
               builderResult.hasWildPokemon = true
               builderResult.wildPokemon = value
           }
      }
      fileprivate var wildPokemonBuilder_:Pogoprotos.Map.Pokemon.WildPokemon.Builder! {
           didSet {
              builderResult.hasWildPokemon = true
           }
      }
      public func getWildPokemonBuilder() -> Pogoprotos.Map.Pokemon.WildPokemon.Builder {
        if wildPokemonBuilder_ == nil {
           wildPokemonBuilder_ = Pogoprotos.Map.Pokemon.WildPokemon.Builder()
           builderResult.wildPokemon = wildPokemonBuilder_.getMessage()
           if wildPokemon != nil {
              try! wildPokemonBuilder_.mergeFrom(other: wildPokemon)
           }
        }
        return wildPokemonBuilder_
      }
      @discardableResult
      public func setWildPokemon(_ value:Pogoprotos.Map.Pokemon.WildPokemon!) -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        self.wildPokemon = value
        return self
      }
      @discardableResult
      public func mergeWildPokemon(value:Pogoprotos.Map.Pokemon.WildPokemon) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        if builderResult.hasWildPokemon {
          builderResult.wildPokemon = try Pogoprotos.Map.Pokemon.WildPokemon.builderWithPrototype(prototype:builderResult.wildPokemon).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.wildPokemon = value
        }
        builderResult.hasWildPokemon = true
        return self
      }
      @discardableResult
      public func clearWildPokemon() -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        wildPokemonBuilder_ = nil
        builderResult.hasWildPokemon = false
        builderResult.wildPokemon = nil
        return self
      }
        public var hasBackground:Bool{
            get {
                return builderResult.hasBackground
            }
        }
        public var background:Pogoprotos.Networking.Responses.EncounterResponse.Background {
            get {
                return builderResult.background
            }
            set (value) {
                builderResult.hasBackground = true
                builderResult.background = value
            }
        }
      @discardableResult
        public func setBackground(_ value:Pogoprotos.Networking.Responses.EncounterResponse.Background) -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
          self.background = value
          return self
        }
      @discardableResult
        public func clearBackground() -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
           builderResult.hasBackground = false
           builderResult.background = .park
           return self
        }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Networking.Responses.EncounterResponse.Status {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
      @discardableResult
        public func setStatus(_ value:Pogoprotos.Networking.Responses.EncounterResponse.Status) -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
          self.status = value
          return self
        }
      @discardableResult
        public func clearStatus() -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .encounterError
           return self
        }
      public var hasCaptureProbability:Bool {
           get {
               return builderResult.hasCaptureProbability
           }
      }
      public var captureProbability:Pogoprotos.Data.Capture.CaptureProbability! {
           get {
               if captureProbabilityBuilder_ != nil {
                  builderResult.captureProbability = captureProbabilityBuilder_.getMessage()
               }
               return builderResult.captureProbability
           }
           set (value) {
               builderResult.hasCaptureProbability = true
               builderResult.captureProbability = value
           }
      }
      fileprivate var captureProbabilityBuilder_:Pogoprotos.Data.Capture.CaptureProbability.Builder! {
           didSet {
              builderResult.hasCaptureProbability = true
           }
      }
      public func getCaptureProbabilityBuilder() -> Pogoprotos.Data.Capture.CaptureProbability.Builder {
        if captureProbabilityBuilder_ == nil {
           captureProbabilityBuilder_ = Pogoprotos.Data.Capture.CaptureProbability.Builder()
           builderResult.captureProbability = captureProbabilityBuilder_.getMessage()
           if captureProbability != nil {
              try! captureProbabilityBuilder_.mergeFrom(other: captureProbability)
           }
        }
        return captureProbabilityBuilder_
      }
      @discardableResult
      public func setCaptureProbability(_ value:Pogoprotos.Data.Capture.CaptureProbability!) -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        self.captureProbability = value
        return self
      }
      @discardableResult
      public func mergeCaptureProbability(value:Pogoprotos.Data.Capture.CaptureProbability) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        if builderResult.hasCaptureProbability {
          builderResult.captureProbability = try Pogoprotos.Data.Capture.CaptureProbability.builderWithPrototype(prototype:builderResult.captureProbability).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.captureProbability = value
        }
        builderResult.hasCaptureProbability = true
        return self
      }
      @discardableResult
      public func clearCaptureProbability() -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        captureProbabilityBuilder_ = nil
        builderResult.hasCaptureProbability = false
        builderResult.captureProbability = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.EncounterResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        return try Pogoprotos.Networking.Responses.EncounterResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.EncounterResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.EncounterResponse {
        let returnMe:Pogoprotos.Networking.Responses.EncounterResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.EncounterResponse) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        if other == Pogoprotos.Networking.Responses.EncounterResponse() {
         return self
        }
        if (other.hasWildPokemon) {
            try mergeWildPokemon(value: other.wildPokemon)
        }
        if other.hasBackground {
             background = other.background
        }
        if other.hasStatus {
             status = other.status
        }
        if (other.hasCaptureProbability) {
            try mergeCaptureProbability(value: other.captureProbability)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder:Pogoprotos.Map.Pokemon.WildPokemon.Builder = Pogoprotos.Map.Pokemon.WildPokemon.Builder()
            if hasWildPokemon {
              try subBuilder.mergeFrom(other: wildPokemon)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            wildPokemon = subBuilder.buildPartial()

          case 16:
            let valueIntbackground = try codedInputStream.readEnum()
            if let enumsbackground = Pogoprotos.Networking.Responses.EncounterResponse.Background(rawValue:valueIntbackground){
                 background = enumsbackground
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntbackground))
            }

          case 24:
            let valueIntstatus = try codedInputStream.readEnum()
            if let enumsstatus = Pogoprotos.Networking.Responses.EncounterResponse.Status(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 3, value:Int64(valueIntstatus))
            }

          case 34:
            let subBuilder:Pogoprotos.Data.Capture.CaptureProbability.Builder = Pogoprotos.Data.Capture.CaptureProbability.Builder()
            if hasCaptureProbability {
              try subBuilder.mergeFrom(other: captureProbability)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            captureProbability = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.EncounterResponse.Builder()
        if let jsonValueWildPokemon = jsonMap["wildPokemon"] as? Dictionary<String,Any> {
          resultDecodedBuilder.wildPokemon = try Pogoprotos.Map.Pokemon.WildPokemon.Builder.decodeToBuilder(jsonMap:jsonValueWildPokemon).build()

        }
        if let jsonValueBackground = jsonMap["background"] as? String {
          resultDecodedBuilder.background = try Pogoprotos.Networking.Responses.EncounterResponse.Background.fromString(str: jsonValueBackground)
        }
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Networking.Responses.EncounterResponse.Status.fromString(str: jsonValueStatus)
        }
        if let jsonValueCaptureProbability = jsonMap["captureProbability"] as? Dictionary<String,Any> {
          resultDecodedBuilder.captureProbability = try Pogoprotos.Data.Capture.CaptureProbability.Builder.decodeToBuilder(jsonMap:jsonValueCaptureProbability).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.EncounterResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class EncounterTutorialCompleteResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse, rhs: Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasPokemonData == rhs.hasPokemonData) && (!lhs.hasPokemonData || lhs.pokemonData == rhs.pokemonData)
      fieldCheck = fieldCheck && (lhs.hasCaptureAward == rhs.hasCaptureAward) && (!lhs.hasCaptureAward || lhs.captureAward == rhs.captureAward)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case errorInvalidPokemon = 2
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .errorInvalidPokemon: return "ERROR_INVALID_POKEMON"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "ERROR_INVALID_POKEMON":  return .errorInvalidPokemon
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .errorInvalidPokemon: return ".errorInvalidPokemon"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Result = Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var pokemonData:Pogoprotos.Data.PokemonData!
    public fileprivate(set) var hasPokemonData:Bool = false
    public fileprivate(set) var captureAward:Pogoprotos.Data.Capture.CaptureAward!
    public fileprivate(set) var hasCaptureAward:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasPokemonData {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:pokemonData)
      }
      if hasCaptureAward {
        try codedOutputStream.writeMessage(fieldNumber: 3, value:captureAward)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasPokemonData {
          if let varSizepokemonData = pokemonData?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizepokemonData
          }
      }
      if hasCaptureAward {
          if let varSizecaptureAward = captureAward?.computeMessageSize(fieldNumber: 3) {
              serialize_size += varSizecaptureAward
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
      return Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.classBuilder() as! Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasPokemonData {
        jsonMap["pokemonData"] = try pokemonData.encode()
      }
      if hasCaptureAward {
        jsonMap["captureAward"] = try captureAward.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasPokemonData {
        output += "\(indent) pokemonData {\n"
        if let outDescPokemonData = pokemonData {
          output += try outDescPokemonData.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasCaptureAward {
        output += "\(indent) captureAward {\n"
        if let outDescCaptureAward = captureAward {
          output += try outDescCaptureAward.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasPokemonData {
                if let hashValuepokemonData = pokemonData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepokemonData
                }
            }
            if hasCaptureAward {
                if let hashValuecaptureAward = captureAward?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecaptureAward
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse = Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Result) -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasPokemonData:Bool {
           get {
               return builderResult.hasPokemonData
           }
      }
      public var pokemonData:Pogoprotos.Data.PokemonData! {
           get {
               if pokemonDataBuilder_ != nil {
                  builderResult.pokemonData = pokemonDataBuilder_.getMessage()
               }
               return builderResult.pokemonData
           }
           set (value) {
               builderResult.hasPokemonData = true
               builderResult.pokemonData = value
           }
      }
      fileprivate var pokemonDataBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasPokemonData = true
           }
      }
      public func getPokemonDataBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if pokemonDataBuilder_ == nil {
           pokemonDataBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.pokemonData = pokemonDataBuilder_.getMessage()
           if pokemonData != nil {
              try! pokemonDataBuilder_.mergeFrom(other: pokemonData)
           }
        }
        return pokemonDataBuilder_
      }
      @discardableResult
      public func setPokemonData(_ value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        self.pokemonData = value
        return self
      }
      @discardableResult
      public func mergePokemonData(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        if builderResult.hasPokemonData {
          builderResult.pokemonData = try Pogoprotos.Data.PokemonData.builderWithPrototype(prototype:builderResult.pokemonData).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.pokemonData = value
        }
        builderResult.hasPokemonData = true
        return self
      }
      @discardableResult
      public func clearPokemonData() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        pokemonDataBuilder_ = nil
        builderResult.hasPokemonData = false
        builderResult.pokemonData = nil
        return self
      }
      public var hasCaptureAward:Bool {
           get {
               return builderResult.hasCaptureAward
           }
      }
      public var captureAward:Pogoprotos.Data.Capture.CaptureAward! {
           get {
               if captureAwardBuilder_ != nil {
                  builderResult.captureAward = captureAwardBuilder_.getMessage()
               }
               return builderResult.captureAward
           }
           set (value) {
               builderResult.hasCaptureAward = true
               builderResult.captureAward = value
           }
      }
      fileprivate var captureAwardBuilder_:Pogoprotos.Data.Capture.CaptureAward.Builder! {
           didSet {
              builderResult.hasCaptureAward = true
           }
      }
      public func getCaptureAwardBuilder() -> Pogoprotos.Data.Capture.CaptureAward.Builder {
        if captureAwardBuilder_ == nil {
           captureAwardBuilder_ = Pogoprotos.Data.Capture.CaptureAward.Builder()
           builderResult.captureAward = captureAwardBuilder_.getMessage()
           if captureAward != nil {
              try! captureAwardBuilder_.mergeFrom(other: captureAward)
           }
        }
        return captureAwardBuilder_
      }
      @discardableResult
      public func setCaptureAward(_ value:Pogoprotos.Data.Capture.CaptureAward!) -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        self.captureAward = value
        return self
      }
      @discardableResult
      public func mergeCaptureAward(value:Pogoprotos.Data.Capture.CaptureAward) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        if builderResult.hasCaptureAward {
          builderResult.captureAward = try Pogoprotos.Data.Capture.CaptureAward.builderWithPrototype(prototype:builderResult.captureAward).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.captureAward = value
        }
        builderResult.hasCaptureAward = true
        return self
      }
      @discardableResult
      public func clearCaptureAward() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        captureAwardBuilder_ = nil
        builderResult.hasCaptureAward = false
        builderResult.captureAward = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
        let returnMe:Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        if other == Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasPokemonData) {
            try mergePokemonData(value: other.pokemonData)
        }
        if (other.hasCaptureAward) {
            try mergeCaptureAward(value: other.captureAward)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasPokemonData {
              try subBuilder.mergeFrom(other: pokemonData)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            pokemonData = subBuilder.buildPartial()

          case 26:
            let subBuilder:Pogoprotos.Data.Capture.CaptureAward.Builder = Pogoprotos.Data.Capture.CaptureAward.Builder()
            if hasCaptureAward {
              try subBuilder.mergeFrom(other: captureAward)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            captureAward = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValuePokemonData = jsonMap["pokemonData"] as? Dictionary<String,Any> {
          resultDecodedBuilder.pokemonData = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonMap:jsonValuePokemonData).build()

        }
        if let jsonValueCaptureAward = jsonMap["captureAward"] as? Dictionary<String,Any> {
          resultDecodedBuilder.captureAward = try Pogoprotos.Data.Capture.CaptureAward.Builder.decodeToBuilder(jsonMap:jsonValueCaptureAward).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class EquipBadgeResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.EquipBadgeResponse, rhs: Pogoprotos.Networking.Responses.EquipBadgeResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasEquipped == rhs.hasEquipped) && (!lhs.hasEquipped || lhs.equipped == rhs.equipped)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case cooldownActive = 2
        case notQualified = 3
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .cooldownActive: return "COOLDOWN_ACTIVE"
          case .notQualified: return "NOT_QUALIFIED"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "COOLDOWN_ACTIVE":  return .cooldownActive
          case "NOT_QUALIFIED":  return .notQualified
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .cooldownActive: return ".cooldownActive"
          case .notQualified: return ".notQualified"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.EquipBadgeResponse.Result = Pogoprotos.Networking.Responses.EquipBadgeResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var equipped:Pogoprotos.Data.Player.EquippedBadge!
    public fileprivate(set) var hasEquipped:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasEquipped {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:equipped)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasEquipped {
          if let varSizeequipped = equipped?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeequipped
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
      return Pogoprotos.Networking.Responses.EquipBadgeResponse.classBuilder() as! Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.EquipBadgeResponse) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasEquipped {
        jsonMap["equipped"] = try equipped.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasEquipped {
        output += "\(indent) equipped {\n"
        if let outDescEquipped = equipped {
          output += try outDescEquipped.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasEquipped {
                if let hashValueequipped = equipped?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueequipped
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.EquipBadgeResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.EquipBadgeResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.EquipBadgeResponse = Pogoprotos.Networking.Responses.EquipBadgeResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.EquipBadgeResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.EquipBadgeResponse.Result) -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasEquipped:Bool {
           get {
               return builderResult.hasEquipped
           }
      }
      public var equipped:Pogoprotos.Data.Player.EquippedBadge! {
           get {
               if equippedBuilder_ != nil {
                  builderResult.equipped = equippedBuilder_.getMessage()
               }
               return builderResult.equipped
           }
           set (value) {
               builderResult.hasEquipped = true
               builderResult.equipped = value
           }
      }
      fileprivate var equippedBuilder_:Pogoprotos.Data.Player.EquippedBadge.Builder! {
           didSet {
              builderResult.hasEquipped = true
           }
      }
      public func getEquippedBuilder() -> Pogoprotos.Data.Player.EquippedBadge.Builder {
        if equippedBuilder_ == nil {
           equippedBuilder_ = Pogoprotos.Data.Player.EquippedBadge.Builder()
           builderResult.equipped = equippedBuilder_.getMessage()
           if equipped != nil {
              try! equippedBuilder_.mergeFrom(other: equipped)
           }
        }
        return equippedBuilder_
      }
      @discardableResult
      public func setEquipped(_ value:Pogoprotos.Data.Player.EquippedBadge!) -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        self.equipped = value
        return self
      }
      @discardableResult
      public func mergeEquipped(value:Pogoprotos.Data.Player.EquippedBadge) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        if builderResult.hasEquipped {
          builderResult.equipped = try Pogoprotos.Data.Player.EquippedBadge.builderWithPrototype(prototype:builderResult.equipped).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.equipped = value
        }
        builderResult.hasEquipped = true
        return self
      }
      @discardableResult
      public func clearEquipped() -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        equippedBuilder_ = nil
        builderResult.hasEquipped = false
        builderResult.equipped = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.EquipBadgeResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        return try Pogoprotos.Networking.Responses.EquipBadgeResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
        let returnMe:Pogoprotos.Networking.Responses.EquipBadgeResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.EquipBadgeResponse) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        if other == Pogoprotos.Networking.Responses.EquipBadgeResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasEquipped) {
            try mergeEquipped(value: other.equipped)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.EquipBadgeResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.Player.EquippedBadge.Builder = Pogoprotos.Data.Player.EquippedBadge.Builder()
            if hasEquipped {
              try subBuilder.mergeFrom(other: equipped)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            equipped = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.EquipBadgeResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueEquipped = jsonMap["equipped"] as? Dictionary<String,Any> {
          resultDecodedBuilder.equipped = try Pogoprotos.Data.Player.EquippedBadge.Builder.decodeToBuilder(jsonMap:jsonValueEquipped).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class EvolvePokemonResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.EvolvePokemonResponse, rhs: Pogoprotos.Networking.Responses.EvolvePokemonResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasEvolvedPokemonData == rhs.hasEvolvedPokemonData) && (!lhs.hasEvolvedPokemonData || lhs.evolvedPokemonData == rhs.evolvedPokemonData)
      fieldCheck = fieldCheck && (lhs.hasExperienceAwarded == rhs.hasExperienceAwarded) && (!lhs.hasExperienceAwarded || lhs.experienceAwarded == rhs.experienceAwarded)
      fieldCheck = fieldCheck && (lhs.hasCandyAwarded == rhs.hasCandyAwarded) && (!lhs.hasCandyAwarded || lhs.candyAwarded == rhs.candyAwarded)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case failedPokemonMissing = 2
        case failedInsufficientResources = 3
        case failedPokemonCannotEvolve = 4
        case failedPokemonIsDeployed = 5
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .failedPokemonMissing: return "FAILED_POKEMON_MISSING"
          case .failedInsufficientResources: return "FAILED_INSUFFICIENT_RESOURCES"
          case .failedPokemonCannotEvolve: return "FAILED_POKEMON_CANNOT_EVOLVE"
          case .failedPokemonIsDeployed: return "FAILED_POKEMON_IS_DEPLOYED"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "FAILED_POKEMON_MISSING":  return .failedPokemonMissing
          case "FAILED_INSUFFICIENT_RESOURCES":  return .failedInsufficientResources
          case "FAILED_POKEMON_CANNOT_EVOLVE":  return .failedPokemonCannotEvolve
          case "FAILED_POKEMON_IS_DEPLOYED":  return .failedPokemonIsDeployed
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .failedPokemonMissing: return ".failedPokemonMissing"
          case .failedInsufficientResources: return ".failedInsufficientResources"
          case .failedPokemonCannotEvolve: return ".failedPokemonCannotEvolve"
          case .failedPokemonIsDeployed: return ".failedPokemonIsDeployed"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.EvolvePokemonResponse.Result = Pogoprotos.Networking.Responses.EvolvePokemonResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var evolvedPokemonData:Pogoprotos.Data.PokemonData!
    public fileprivate(set) var hasEvolvedPokemonData:Bool = false
    public fileprivate(set) var experienceAwarded:Int32 = Int32(0)
    public fileprivate(set) var hasExperienceAwarded:Bool = false

    public fileprivate(set) var candyAwarded:Int32 = Int32(0)
    public fileprivate(set) var hasCandyAwarded:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasEvolvedPokemonData {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:evolvedPokemonData)
      }
      if hasExperienceAwarded {
        try codedOutputStream.writeInt32(fieldNumber: 3, value:experienceAwarded)
      }
      if hasCandyAwarded {
        try codedOutputStream.writeInt32(fieldNumber: 4, value:candyAwarded)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasEvolvedPokemonData {
          if let varSizeevolvedPokemonData = evolvedPokemonData?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeevolvedPokemonData
          }
      }
      if hasExperienceAwarded {
        serialize_size += experienceAwarded.computeInt32Size(fieldNumber: 3)
      }
      if hasCandyAwarded {
        serialize_size += candyAwarded.computeInt32Size(fieldNumber: 4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.EvolvePokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.EvolvePokemonResponse) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasEvolvedPokemonData {
        jsonMap["evolvedPokemonData"] = try evolvedPokemonData.encode()
      }
      if hasExperienceAwarded {
        jsonMap["experienceAwarded"] = Int(experienceAwarded)
      }
      if hasCandyAwarded {
        jsonMap["candyAwarded"] = Int(candyAwarded)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasEvolvedPokemonData {
        output += "\(indent) evolvedPokemonData {\n"
        if let outDescEvolvedPokemonData = evolvedPokemonData {
          output += try outDescEvolvedPokemonData.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasExperienceAwarded {
        output += "\(indent) experienceAwarded: \(experienceAwarded) \n"
      }
      if hasCandyAwarded {
        output += "\(indent) candyAwarded: \(candyAwarded) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasEvolvedPokemonData {
                if let hashValueevolvedPokemonData = evolvedPokemonData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueevolvedPokemonData
                }
            }
            if hasExperienceAwarded {
               hashCode = (hashCode &* 31) &+ experienceAwarded.hashValue
            }
            if hasCandyAwarded {
               hashCode = (hashCode &* 31) &+ candyAwarded.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.EvolvePokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.EvolvePokemonResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.EvolvePokemonResponse = Pogoprotos.Networking.Responses.EvolvePokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.EvolvePokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.EvolvePokemonResponse.Result) -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasEvolvedPokemonData:Bool {
           get {
               return builderResult.hasEvolvedPokemonData
           }
      }
      public var evolvedPokemonData:Pogoprotos.Data.PokemonData! {
           get {
               if evolvedPokemonDataBuilder_ != nil {
                  builderResult.evolvedPokemonData = evolvedPokemonDataBuilder_.getMessage()
               }
               return builderResult.evolvedPokemonData
           }
           set (value) {
               builderResult.hasEvolvedPokemonData = true
               builderResult.evolvedPokemonData = value
           }
      }
      fileprivate var evolvedPokemonDataBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasEvolvedPokemonData = true
           }
      }
      public func getEvolvedPokemonDataBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if evolvedPokemonDataBuilder_ == nil {
           evolvedPokemonDataBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.evolvedPokemonData = evolvedPokemonDataBuilder_.getMessage()
           if evolvedPokemonData != nil {
              try! evolvedPokemonDataBuilder_.mergeFrom(other: evolvedPokemonData)
           }
        }
        return evolvedPokemonDataBuilder_
      }
      @discardableResult
      public func setEvolvedPokemonData(_ value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        self.evolvedPokemonData = value
        return self
      }
      @discardableResult
      public func mergeEvolvedPokemonData(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        if builderResult.hasEvolvedPokemonData {
          builderResult.evolvedPokemonData = try Pogoprotos.Data.PokemonData.builderWithPrototype(prototype:builderResult.evolvedPokemonData).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.evolvedPokemonData = value
        }
        builderResult.hasEvolvedPokemonData = true
        return self
      }
      @discardableResult
      public func clearEvolvedPokemonData() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        evolvedPokemonDataBuilder_ = nil
        builderResult.hasEvolvedPokemonData = false
        builderResult.evolvedPokemonData = nil
        return self
      }
      public var hasExperienceAwarded:Bool {
           get {
                return builderResult.hasExperienceAwarded
           }
      }
      public var experienceAwarded:Int32 {
           get {
                return builderResult.experienceAwarded
           }
           set (value) {
               builderResult.hasExperienceAwarded = true
               builderResult.experienceAwarded = value
           }
      }
      @discardableResult
      public func setExperienceAwarded(_ value:Int32) -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        self.experienceAwarded = value
        return self
      }
      @discardableResult
      public func clearExperienceAwarded() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder{
           builderResult.hasExperienceAwarded = false
           builderResult.experienceAwarded = Int32(0)
           return self
      }
      public var hasCandyAwarded:Bool {
           get {
                return builderResult.hasCandyAwarded
           }
      }
      public var candyAwarded:Int32 {
           get {
                return builderResult.candyAwarded
           }
           set (value) {
               builderResult.hasCandyAwarded = true
               builderResult.candyAwarded = value
           }
      }
      @discardableResult
      public func setCandyAwarded(_ value:Int32) -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        self.candyAwarded = value
        return self
      }
      @discardableResult
      public func clearCandyAwarded() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder{
           builderResult.hasCandyAwarded = false
           builderResult.candyAwarded = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.EvolvePokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.EvolvePokemonResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.EvolvePokemonResponse) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.EvolvePokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasEvolvedPokemonData) {
            try mergeEvolvedPokemonData(value: other.evolvedPokemonData)
        }
        if other.hasExperienceAwarded {
             experienceAwarded = other.experienceAwarded
        }
        if other.hasCandyAwarded {
             candyAwarded = other.candyAwarded
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.EvolvePokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasEvolvedPokemonData {
              try subBuilder.mergeFrom(other: evolvedPokemonData)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            evolvedPokemonData = subBuilder.buildPartial()

          case 24:
            experienceAwarded = try codedInputStream.readInt32()

          case 32:
            candyAwarded = try codedInputStream.readInt32()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueEvolvedPokemonData = jsonMap["evolvedPokemonData"] as? Dictionary<String,Any> {
          resultDecodedBuilder.evolvedPokemonData = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonMap:jsonValueEvolvedPokemonData).build()

        }
        if let jsonValueExperienceAwarded = jsonMap["experienceAwarded"] as? Int {
          resultDecodedBuilder.experienceAwarded = Int32(jsonValueExperienceAwarded)
        }
        if let jsonValueCandyAwarded = jsonMap["candyAwarded"] as? Int {
          resultDecodedBuilder.candyAwarded = Int32(jsonValueCandyAwarded)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class FortDeployPokemonResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.FortDeployPokemonResponse, rhs: Pogoprotos.Networking.Responses.FortDeployPokemonResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasFortDetails == rhs.hasFortDetails) && (!lhs.hasFortDetails || lhs.fortDetails == rhs.fortDetails)
      fieldCheck = fieldCheck && (lhs.hasPokemonData == rhs.hasPokemonData) && (!lhs.hasPokemonData || lhs.pokemonData == rhs.pokemonData)
      fieldCheck = fieldCheck && (lhs.hasGymState == rhs.hasGymState) && (!lhs.hasGymState || lhs.gymState == rhs.gymState)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case noResultSet = 0
        case success = 1
        case errorAlreadyHasPokemonOnFort = 2
        case errorOpposingTeamOwnsFort = 3
        case errorFortIsFull = 4
        case errorNotInRange = 5
        case errorPlayerHasNoTeam = 6
        case errorPokemonNotFullHp = 7
        case errorPlayerBelowMinimumLevel = 8
        case errorPokemonIsBuddy = 9
        public func toString() -> String {
          switch self {
          case .noResultSet: return "NO_RESULT_SET"
          case .success: return "SUCCESS"
          case .errorAlreadyHasPokemonOnFort: return "ERROR_ALREADY_HAS_POKEMON_ON_FORT"
          case .errorOpposingTeamOwnsFort: return "ERROR_OPPOSING_TEAM_OWNS_FORT"
          case .errorFortIsFull: return "ERROR_FORT_IS_FULL"
          case .errorNotInRange: return "ERROR_NOT_IN_RANGE"
          case .errorPlayerHasNoTeam: return "ERROR_PLAYER_HAS_NO_TEAM"
          case .errorPokemonNotFullHp: return "ERROR_POKEMON_NOT_FULL_HP"
          case .errorPlayerBelowMinimumLevel: return "ERROR_PLAYER_BELOW_MINIMUM_LEVEL"
          case .errorPokemonIsBuddy: return "ERROR_POKEMON_IS_BUDDY"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Result {
          switch str {
          case "NO_RESULT_SET":  return .noResultSet
          case "SUCCESS":  return .success
          case "ERROR_ALREADY_HAS_POKEMON_ON_FORT":  return .errorAlreadyHasPokemonOnFort
          case "ERROR_OPPOSING_TEAM_OWNS_FORT":  return .errorOpposingTeamOwnsFort
          case "ERROR_FORT_IS_FULL":  return .errorFortIsFull
          case "ERROR_NOT_IN_RANGE":  return .errorNotInRange
          case "ERROR_PLAYER_HAS_NO_TEAM":  return .errorPlayerHasNoTeam
          case "ERROR_POKEMON_NOT_FULL_HP":  return .errorPokemonNotFullHp
          case "ERROR_PLAYER_BELOW_MINIMUM_LEVEL":  return .errorPlayerBelowMinimumLevel
          case "ERROR_POKEMON_IS_BUDDY":  return .errorPokemonIsBuddy
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .noResultSet: return ".noResultSet"
          case .success: return ".success"
          case .errorAlreadyHasPokemonOnFort: return ".errorAlreadyHasPokemonOnFort"
          case .errorOpposingTeamOwnsFort: return ".errorOpposingTeamOwnsFort"
          case .errorFortIsFull: return ".errorFortIsFull"
          case .errorNotInRange: return ".errorNotInRange"
          case .errorPlayerHasNoTeam: return ".errorPlayerHasNoTeam"
          case .errorPokemonNotFullHp: return ".errorPokemonNotFullHp"
          case .errorPlayerBelowMinimumLevel: return ".errorPlayerBelowMinimumLevel"
          case .errorPokemonIsBuddy: return ".errorPokemonIsBuddy"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Result = Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Result.noResultSet
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var fortDetails:Pogoprotos.Networking.Responses.FortDetailsResponse!
    public fileprivate(set) var hasFortDetails:Bool = false
    public fileprivate(set) var pokemonData:Pogoprotos.Data.PokemonData!
    public fileprivate(set) var hasPokemonData:Bool = false
    public fileprivate(set) var gymState:Pogoprotos.Data.Gym.GymState!
    public fileprivate(set) var hasGymState:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasFortDetails {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:fortDetails)
      }
      if hasPokemonData {
        try codedOutputStream.writeMessage(fieldNumber: 3, value:pokemonData)
      }
      if hasGymState {
        try codedOutputStream.writeMessage(fieldNumber: 4, value:gymState)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasFortDetails {
          if let varSizefortDetails = fortDetails?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizefortDetails
          }
      }
      if hasPokemonData {
          if let varSizepokemonData = pokemonData?.computeMessageSize(fieldNumber: 3) {
              serialize_size += varSizepokemonData
          }
      }
      if hasGymState {
          if let varSizegymState = gymState?.computeMessageSize(fieldNumber: 4) {
              serialize_size += varSizegymState
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.FortDeployPokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.FortDeployPokemonResponse) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasFortDetails {
        jsonMap["fortDetails"] = try fortDetails.encode()
      }
      if hasPokemonData {
        jsonMap["pokemonData"] = try pokemonData.encode()
      }
      if hasGymState {
        jsonMap["gymState"] = try gymState.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasFortDetails {
        output += "\(indent) fortDetails {\n"
        if let outDescFortDetails = fortDetails {
          output += try outDescFortDetails.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasPokemonData {
        output += "\(indent) pokemonData {\n"
        if let outDescPokemonData = pokemonData {
          output += try outDescPokemonData.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasGymState {
        output += "\(indent) gymState {\n"
        if let outDescGymState = gymState {
          output += try outDescGymState.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasFortDetails {
                if let hashValuefortDetails = fortDetails?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuefortDetails
                }
            }
            if hasPokemonData {
                if let hashValuepokemonData = pokemonData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepokemonData
                }
            }
            if hasGymState {
                if let hashValuegymState = gymState?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuegymState
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.FortDeployPokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.FortDeployPokemonResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.FortDeployPokemonResponse = Pogoprotos.Networking.Responses.FortDeployPokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Result) -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .noResultSet
           return self
        }
      public var hasFortDetails:Bool {
           get {
               return builderResult.hasFortDetails
           }
      }
      public var fortDetails:Pogoprotos.Networking.Responses.FortDetailsResponse! {
           get {
               if fortDetailsBuilder_ != nil {
                  builderResult.fortDetails = fortDetailsBuilder_.getMessage()
               }
               return builderResult.fortDetails
           }
           set (value) {
               builderResult.hasFortDetails = true
               builderResult.fortDetails = value
           }
      }
      fileprivate var fortDetailsBuilder_:Pogoprotos.Networking.Responses.FortDetailsResponse.Builder! {
           didSet {
              builderResult.hasFortDetails = true
           }
      }
      public func getFortDetailsBuilder() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        if fortDetailsBuilder_ == nil {
           fortDetailsBuilder_ = Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
           builderResult.fortDetails = fortDetailsBuilder_.getMessage()
           if fortDetails != nil {
              try! fortDetailsBuilder_.mergeFrom(other: fortDetails)
           }
        }
        return fortDetailsBuilder_
      }
      @discardableResult
      public func setFortDetails(_ value:Pogoprotos.Networking.Responses.FortDetailsResponse!) -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        self.fortDetails = value
        return self
      }
      @discardableResult
      public func mergeFortDetails(value:Pogoprotos.Networking.Responses.FortDetailsResponse) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        if builderResult.hasFortDetails {
          builderResult.fortDetails = try Pogoprotos.Networking.Responses.FortDetailsResponse.builderWithPrototype(prototype:builderResult.fortDetails).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.fortDetails = value
        }
        builderResult.hasFortDetails = true
        return self
      }
      @discardableResult
      public func clearFortDetails() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        fortDetailsBuilder_ = nil
        builderResult.hasFortDetails = false
        builderResult.fortDetails = nil
        return self
      }
      public var hasPokemonData:Bool {
           get {
               return builderResult.hasPokemonData
           }
      }
      public var pokemonData:Pogoprotos.Data.PokemonData! {
           get {
               if pokemonDataBuilder_ != nil {
                  builderResult.pokemonData = pokemonDataBuilder_.getMessage()
               }
               return builderResult.pokemonData
           }
           set (value) {
               builderResult.hasPokemonData = true
               builderResult.pokemonData = value
           }
      }
      fileprivate var pokemonDataBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasPokemonData = true
           }
      }
      public func getPokemonDataBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if pokemonDataBuilder_ == nil {
           pokemonDataBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.pokemonData = pokemonDataBuilder_.getMessage()
           if pokemonData != nil {
              try! pokemonDataBuilder_.mergeFrom(other: pokemonData)
           }
        }
        return pokemonDataBuilder_
      }
      @discardableResult
      public func setPokemonData(_ value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        self.pokemonData = value
        return self
      }
      @discardableResult
      public func mergePokemonData(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        if builderResult.hasPokemonData {
          builderResult.pokemonData = try Pogoprotos.Data.PokemonData.builderWithPrototype(prototype:builderResult.pokemonData).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.pokemonData = value
        }
        builderResult.hasPokemonData = true
        return self
      }
      @discardableResult
      public func clearPokemonData() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        pokemonDataBuilder_ = nil
        builderResult.hasPokemonData = false
        builderResult.pokemonData = nil
        return self
      }
      public var hasGymState:Bool {
           get {
               return builderResult.hasGymState
           }
      }
      public var gymState:Pogoprotos.Data.Gym.GymState! {
           get {
               if gymStateBuilder_ != nil {
                  builderResult.gymState = gymStateBuilder_.getMessage()
               }
               return builderResult.gymState
           }
           set (value) {
               builderResult.hasGymState = true
               builderResult.gymState = value
           }
      }
      fileprivate var gymStateBuilder_:Pogoprotos.Data.Gym.GymState.Builder! {
           didSet {
              builderResult.hasGymState = true
           }
      }
      public func getGymStateBuilder() -> Pogoprotos.Data.Gym.GymState.Builder {
        if gymStateBuilder_ == nil {
           gymStateBuilder_ = Pogoprotos.Data.Gym.GymState.Builder()
           builderResult.gymState = gymStateBuilder_.getMessage()
           if gymState != nil {
              try! gymStateBuilder_.mergeFrom(other: gymState)
           }
        }
        return gymStateBuilder_
      }
      @discardableResult
      public func setGymState(_ value:Pogoprotos.Data.Gym.GymState!) -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        self.gymState = value
        return self
      }
      @discardableResult
      public func mergeGymState(value:Pogoprotos.Data.Gym.GymState) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        if builderResult.hasGymState {
          builderResult.gymState = try Pogoprotos.Data.Gym.GymState.builderWithPrototype(prototype:builderResult.gymState).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.gymState = value
        }
        builderResult.hasGymState = true
        return self
      }
      @discardableResult
      public func clearGymState() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        gymStateBuilder_ = nil
        builderResult.hasGymState = false
        builderResult.gymState = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.FortDeployPokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.FortDeployPokemonResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.FortDeployPokemonResponse) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.FortDeployPokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasFortDetails) {
            try mergeFortDetails(value: other.fortDetails)
        }
        if (other.hasPokemonData) {
            try mergePokemonData(value: other.pokemonData)
        }
        if (other.hasGymState) {
            try mergeGymState(value: other.gymState)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Networking.Responses.FortDetailsResponse.Builder = Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
            if hasFortDetails {
              try subBuilder.mergeFrom(other: fortDetails)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            fortDetails = subBuilder.buildPartial()

          case 26:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasPokemonData {
              try subBuilder.mergeFrom(other: pokemonData)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            pokemonData = subBuilder.buildPartial()

          case 34:
            let subBuilder:Pogoprotos.Data.Gym.GymState.Builder = Pogoprotos.Data.Gym.GymState.Builder()
            if hasGymState {
              try subBuilder.mergeFrom(other: gymState)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            gymState = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueFortDetails = jsonMap["fortDetails"] as? Dictionary<String,Any> {
          resultDecodedBuilder.fortDetails = try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder.decodeToBuilder(jsonMap:jsonValueFortDetails).build()

        }
        if let jsonValuePokemonData = jsonMap["pokemonData"] as? Dictionary<String,Any> {
          resultDecodedBuilder.pokemonData = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonMap:jsonValuePokemonData).build()

        }
        if let jsonValueGymState = jsonMap["gymState"] as? Dictionary<String,Any> {
          resultDecodedBuilder.gymState = try Pogoprotos.Data.Gym.GymState.Builder.decodeToBuilder(jsonMap:jsonValueGymState).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class FortDetailsResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.FortDetailsResponse, rhs: Pogoprotos.Networking.Responses.FortDetailsResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasFortId == rhs.hasFortId) && (!lhs.hasFortId || lhs.fortId == rhs.fortId)
      fieldCheck = fieldCheck && (lhs.hasTeamColor == rhs.hasTeamColor) && (!lhs.hasTeamColor || lhs.teamColor == rhs.teamColor)
      fieldCheck = fieldCheck && (lhs.hasPokemonData == rhs.hasPokemonData) && (!lhs.hasPokemonData || lhs.pokemonData == rhs.pokemonData)
      fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
      fieldCheck = fieldCheck && (lhs.imageUrls == rhs.imageUrls)
      fieldCheck = fieldCheck && (lhs.hasFp == rhs.hasFp) && (!lhs.hasFp || lhs.fp == rhs.fp)
      fieldCheck = fieldCheck && (lhs.hasStamina == rhs.hasStamina) && (!lhs.hasStamina || lhs.stamina == rhs.stamina)
      fieldCheck = fieldCheck && (lhs.hasMaxStamina == rhs.hasMaxStamina) && (!lhs.hasMaxStamina || lhs.maxStamina == rhs.maxStamina)
      fieldCheck = fieldCheck && (lhs.hasType == rhs.hasType) && (!lhs.hasType || lhs.type == rhs.type)
      fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
      fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
      fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
      fieldCheck = fieldCheck && (lhs.modifiers == rhs.modifiers)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var fortId:String = ""
    public fileprivate(set) var hasFortId:Bool = false

    public fileprivate(set) var teamColor:Pogoprotos.Enums.TeamColor = Pogoprotos.Enums.TeamColor.neutral
    public fileprivate(set) var hasTeamColor:Bool = false
    public fileprivate(set) var pokemonData:Pogoprotos.Data.PokemonData!
    public fileprivate(set) var hasPokemonData:Bool = false
    public fileprivate(set) var name:String = ""
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var imageUrls:Array<String> = Array<String>()
    public fileprivate(set) var fp:Int32 = Int32(0)
    public fileprivate(set) var hasFp:Bool = false

    public fileprivate(set) var stamina:Int32 = Int32(0)
    public fileprivate(set) var hasStamina:Bool = false

    public fileprivate(set) var maxStamina:Int32 = Int32(0)
    public fileprivate(set) var hasMaxStamina:Bool = false

    public fileprivate(set) var type:Pogoprotos.Map.Fort.FortType = Pogoprotos.Map.Fort.FortType.gym
    public fileprivate(set) var hasType:Bool = false
    public fileprivate(set) var latitude:Double = Double(0)
    public fileprivate(set) var hasLatitude:Bool = false

    public fileprivate(set) var longitude:Double = Double(0)
    public fileprivate(set) var hasLongitude:Bool = false

    public fileprivate(set) var description_:String = ""
    public fileprivate(set) var hasDescription:Bool = false

    public fileprivate(set) var modifiers:Array<Pogoprotos.Map.Fort.FortModifier>  = Array<Pogoprotos.Map.Fort.FortModifier>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasFortId {
        try codedOutputStream.writeString(fieldNumber: 1, value:fortId)
      }
      if hasTeamColor {
        try codedOutputStream.writeEnum(fieldNumber: 2, value:teamColor.rawValue)
      }
      if hasPokemonData {
        try codedOutputStream.writeMessage(fieldNumber: 3, value:pokemonData)
      }
      if hasName {
        try codedOutputStream.writeString(fieldNumber: 4, value:name)
      }
      if !imageUrls.isEmpty {
        for oneValueimageUrls in imageUrls {
          try codedOutputStream.writeString(fieldNumber: 5, value:oneValueimageUrls)
        }
      }
      if hasFp {
        try codedOutputStream.writeInt32(fieldNumber: 6, value:fp)
      }
      if hasStamina {
        try codedOutputStream.writeInt32(fieldNumber: 7, value:stamina)
      }
      if hasMaxStamina {
        try codedOutputStream.writeInt32(fieldNumber: 8, value:maxStamina)
      }
      if hasType {
        try codedOutputStream.writeEnum(fieldNumber: 9, value:type.rawValue)
      }
      if hasLatitude {
        try codedOutputStream.writeDouble(fieldNumber: 10, value:latitude)
      }
      if hasLongitude {
        try codedOutputStream.writeDouble(fieldNumber: 11, value:longitude)
      }
      if hasDescription {
        try codedOutputStream.writeString(fieldNumber: 12, value:description_)
      }
      for oneElementModifiers in modifiers {
          try codedOutputStream.writeMessage(fieldNumber: 13, value:oneElementModifiers)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasFortId {
        serialize_size += fortId.computeStringSize(fieldNumber: 1)
      }
      if (hasTeamColor) {
        serialize_size += teamColor.rawValue.computeEnumSize(fieldNumber: 2)
      }
      if hasPokemonData {
          if let varSizepokemonData = pokemonData?.computeMessageSize(fieldNumber: 3) {
              serialize_size += varSizepokemonData
          }
      }
      if hasName {
        serialize_size += name.computeStringSize(fieldNumber: 4)
      }
      var dataSizeImageUrls:Int32 = 0
      for oneValueimageUrls in imageUrls {
          dataSizeImageUrls += oneValueimageUrls.computeStringSizeNoTag()
      }
      serialize_size += dataSizeImageUrls
      serialize_size += 1 * Int32(imageUrls.count)
      if hasFp {
        serialize_size += fp.computeInt32Size(fieldNumber: 6)
      }
      if hasStamina {
        serialize_size += stamina.computeInt32Size(fieldNumber: 7)
      }
      if hasMaxStamina {
        serialize_size += maxStamina.computeInt32Size(fieldNumber: 8)
      }
      if (hasType) {
        serialize_size += type.rawValue.computeEnumSize(fieldNumber: 9)
      }
      if hasLatitude {
        serialize_size += latitude.computeDoubleSize(fieldNumber: 10)
      }
      if hasLongitude {
        serialize_size += longitude.computeDoubleSize(fieldNumber: 11)
      }
      if hasDescription {
        serialize_size += description_.computeStringSize(fieldNumber: 12)
      }
      for oneElementModifiers in modifiers {
          serialize_size += oneElementModifiers.computeMessageSize(fieldNumber: 13)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
      return Pogoprotos.Networking.Responses.FortDetailsResponse.classBuilder() as! Pogoprotos.Networking.Responses.FortDetailsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.FortDetailsResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.FortDetailsResponse) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasFortId {
        jsonMap["fortId"] = fortId
      }
      if hasTeamColor {
        jsonMap["teamColor"] = teamColor.toString()
      }
      if hasPokemonData {
        jsonMap["pokemonData"] = try pokemonData.encode()
      }
      if hasName {
        jsonMap["name"] = name
      }
      if !imageUrls.isEmpty {
        var jsonArrayImageUrls:Array<String> = []
          for oneValueImageUrls in imageUrls {
            jsonArrayImageUrls.append(oneValueImageUrls)
          }
        jsonMap["imageUrls"] = jsonArrayImageUrls
      }
      if hasFp {
        jsonMap["fp"] = Int(fp)
      }
      if hasStamina {
        jsonMap["stamina"] = Int(stamina)
      }
      if hasMaxStamina {
        jsonMap["maxStamina"] = Int(maxStamina)
      }
      if hasType {
        jsonMap["type"] = type.toString()
      }
      if hasLatitude {
        jsonMap["latitude"] = Double(latitude)
      }
      if hasLongitude {
        jsonMap["longitude"] = Double(longitude)
      }
      if hasDescription {
        jsonMap["description"] = description_
      }
      if !modifiers.isEmpty {
        var jsonArrayModifiers:Array<Dictionary<String,Any>> = []
          for oneValueModifiers in modifiers {
            let ecodedMessageModifiers = try oneValueModifiers.encode()
            jsonArrayModifiers.append(ecodedMessageModifiers)
          }
        jsonMap["modifiers"] = jsonArrayModifiers
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasFortId {
        output += "\(indent) fortId: \(fortId) \n"
      }
      if (hasTeamColor) {
        output += "\(indent) teamColor: \(teamColor.description)\n"
      }
      if hasPokemonData {
        output += "\(indent) pokemonData {\n"
        if let outDescPokemonData = pokemonData {
          output += try outDescPokemonData.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      var imageUrlsElementIndex:Int = 0
      for oneValueImageUrls in imageUrls  {
          output += "\(indent) imageUrls[\(imageUrlsElementIndex)]: \(oneValueImageUrls)\n"
          imageUrlsElementIndex += 1
      }
      if hasFp {
        output += "\(indent) fp: \(fp) \n"
      }
      if hasStamina {
        output += "\(indent) stamina: \(stamina) \n"
      }
      if hasMaxStamina {
        output += "\(indent) maxStamina: \(maxStamina) \n"
      }
      if (hasType) {
        output += "\(indent) type: \(type.description)\n"
      }
      if hasLatitude {
        output += "\(indent) latitude: \(latitude) \n"
      }
      if hasLongitude {
        output += "\(indent) longitude: \(longitude) \n"
      }
      if hasDescription {
        output += "\(indent) description: \(description_) \n"
      }
      var modifiersElementIndex:Int = 0
      for oneElementModifiers in modifiers {
          output += "\(indent) modifiers[\(modifiersElementIndex)] {\n"
          output += try oneElementModifiers.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          modifiersElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasFortId {
               hashCode = (hashCode &* 31) &+ fortId.hashValue
            }
            if hasTeamColor {
               hashCode = (hashCode &* 31) &+ Int(teamColor.rawValue)
            }
            if hasPokemonData {
                if let hashValuepokemonData = pokemonData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepokemonData
                }
            }
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            for oneValueImageUrls in imageUrls {
                hashCode = (hashCode &* 31) &+ oneValueImageUrls.hashValue
            }
            if hasFp {
               hashCode = (hashCode &* 31) &+ fp.hashValue
            }
            if hasStamina {
               hashCode = (hashCode &* 31) &+ stamina.hashValue
            }
            if hasMaxStamina {
               hashCode = (hashCode &* 31) &+ maxStamina.hashValue
            }
            if hasType {
               hashCode = (hashCode &* 31) &+ Int(type.rawValue)
            }
            if hasLatitude {
               hashCode = (hashCode &* 31) &+ latitude.hashValue
            }
            if hasLongitude {
               hashCode = (hashCode &* 31) &+ longitude.hashValue
            }
            if hasDescription {
               hashCode = (hashCode &* 31) &+ description_.hashValue
            }
            for oneElementModifiers in modifiers {
                hashCode = (hashCode &* 31) &+ oneElementModifiers.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.FortDetailsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.FortDetailsResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.FortDetailsResponse = Pogoprotos.Networking.Responses.FortDetailsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.FortDetailsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasFortId:Bool {
           get {
                return builderResult.hasFortId
           }
      }
      public var fortId:String {
           get {
                return builderResult.fortId
           }
           set (value) {
               builderResult.hasFortId = true
               builderResult.fortId = value
           }
      }
      @discardableResult
      public func setFortId(_ value:String) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.fortId = value
        return self
      }
      @discardableResult
      public func clearFortId() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasFortId = false
           builderResult.fortId = ""
           return self
      }
        public var hasTeamColor:Bool{
            get {
                return builderResult.hasTeamColor
            }
        }
        public var teamColor:Pogoprotos.Enums.TeamColor {
            get {
                return builderResult.teamColor
            }
            set (value) {
                builderResult.hasTeamColor = true
                builderResult.teamColor = value
            }
        }
      @discardableResult
        public func setTeamColor(_ value:Pogoprotos.Enums.TeamColor) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
          self.teamColor = value
          return self
        }
      @discardableResult
        public func clearTeamColor() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
           builderResult.hasTeamColor = false
           builderResult.teamColor = .neutral
           return self
        }
      public var hasPokemonData:Bool {
           get {
               return builderResult.hasPokemonData
           }
      }
      public var pokemonData:Pogoprotos.Data.PokemonData! {
           get {
               if pokemonDataBuilder_ != nil {
                  builderResult.pokemonData = pokemonDataBuilder_.getMessage()
               }
               return builderResult.pokemonData
           }
           set (value) {
               builderResult.hasPokemonData = true
               builderResult.pokemonData = value
           }
      }
      fileprivate var pokemonDataBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasPokemonData = true
           }
      }
      public func getPokemonDataBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if pokemonDataBuilder_ == nil {
           pokemonDataBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.pokemonData = pokemonDataBuilder_.getMessage()
           if pokemonData != nil {
              try! pokemonDataBuilder_.mergeFrom(other: pokemonData)
           }
        }
        return pokemonDataBuilder_
      }
      @discardableResult
      public func setPokemonData(_ value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.pokemonData = value
        return self
      }
      @discardableResult
      public func mergePokemonData(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        if builderResult.hasPokemonData {
          builderResult.pokemonData = try Pogoprotos.Data.PokemonData.builderWithPrototype(prototype:builderResult.pokemonData).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.pokemonData = value
        }
        builderResult.hasPokemonData = true
        return self
      }
      @discardableResult
      public func clearPokemonData() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        pokemonDataBuilder_ = nil
        builderResult.hasPokemonData = false
        builderResult.pokemonData = nil
        return self
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      @discardableResult
      public func setName(_ value:String) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.name = value
        return self
      }
      @discardableResult
      public func clearName() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var imageUrls:Array<String> {
           get {
               return builderResult.imageUrls
           }
           set (array) {
               builderResult.imageUrls = array
           }
      }
      @discardableResult
      public func setImageUrls(_ value:Array<String>) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.imageUrls = value
        return self
      }
      @discardableResult
      public func clearImageUrls() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
         builderResult.imageUrls.removeAll(keepingCapacity: false)
         return self
      }
      public var hasFp:Bool {
           get {
                return builderResult.hasFp
           }
      }
      public var fp:Int32 {
           get {
                return builderResult.fp
           }
           set (value) {
               builderResult.hasFp = true
               builderResult.fp = value
           }
      }
      @discardableResult
      public func setFp(_ value:Int32) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.fp = value
        return self
      }
      @discardableResult
      public func clearFp() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasFp = false
           builderResult.fp = Int32(0)
           return self
      }
      public var hasStamina:Bool {
           get {
                return builderResult.hasStamina
           }
      }
      public var stamina:Int32 {
           get {
                return builderResult.stamina
           }
           set (value) {
               builderResult.hasStamina = true
               builderResult.stamina = value
           }
      }
      @discardableResult
      public func setStamina(_ value:Int32) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.stamina = value
        return self
      }
      @discardableResult
      public func clearStamina() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasStamina = false
           builderResult.stamina = Int32(0)
           return self
      }
      public var hasMaxStamina:Bool {
           get {
                return builderResult.hasMaxStamina
           }
      }
      public var maxStamina:Int32 {
           get {
                return builderResult.maxStamina
           }
           set (value) {
               builderResult.hasMaxStamina = true
               builderResult.maxStamina = value
           }
      }
      @discardableResult
      public func setMaxStamina(_ value:Int32) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.maxStamina = value
        return self
      }
      @discardableResult
      public func clearMaxStamina() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasMaxStamina = false
           builderResult.maxStamina = Int32(0)
           return self
      }
        public var hasType:Bool{
            get {
                return builderResult.hasType
            }
        }
        public var type:Pogoprotos.Map.Fort.FortType {
            get {
                return builderResult.type
            }
            set (value) {
                builderResult.hasType = true
                builderResult.type = value
            }
        }
      @discardableResult
        public func setType(_ value:Pogoprotos.Map.Fort.FortType) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
          self.type = value
          return self
        }
      @discardableResult
        public func clearType() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
           builderResult.hasType = false
           builderResult.type = .gym
           return self
        }
      public var hasLatitude:Bool {
           get {
                return builderResult.hasLatitude
           }
      }
      public var latitude:Double {
           get {
                return builderResult.latitude
           }
           set (value) {
               builderResult.hasLatitude = true
               builderResult.latitude = value
           }
      }
      @discardableResult
      public func setLatitude(_ value:Double) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.latitude = value
        return self
      }
      @discardableResult
      public func clearLatitude() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasLatitude = false
           builderResult.latitude = Double(0)
           return self
      }
      public var hasLongitude:Bool {
           get {
                return builderResult.hasLongitude
           }
      }
      public var longitude:Double {
           get {
                return builderResult.longitude
           }
           set (value) {
               builderResult.hasLongitude = true
               builderResult.longitude = value
           }
      }
      @discardableResult
      public func setLongitude(_ value:Double) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.longitude = value
        return self
      }
      @discardableResult
      public func clearLongitude() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasLongitude = false
           builderResult.longitude = Double(0)
           return self
      }
      public var hasDescription:Bool {
           get {
                return builderResult.hasDescription
           }
      }
      public var description_:String {
           get {
                return builderResult.description_
           }
           set (value) {
               builderResult.hasDescription = true
               builderResult.description_ = value
           }
      }
      @discardableResult
      public func setDescription(_ value:String) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.description_ = value
        return self
      }
      @discardableResult
      public func clearDescription() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasDescription = false
           builderResult.description_ = ""
           return self
      }
      public var modifiers:Array<Pogoprotos.Map.Fort.FortModifier> {
           get {
               return builderResult.modifiers
           }
           set (value) {
               builderResult.modifiers = value
           }
      }
      @discardableResult
      public func setModifiers(_ value:Array<Pogoprotos.Map.Fort.FortModifier>) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.modifiers = value
        return self
      }
      @discardableResult
      public func clearModifiers() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        builderResult.modifiers.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.FortDetailsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        return try Pogoprotos.Networking.Responses.FortDetailsResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.FortDetailsResponse {
        let returnMe:Pogoprotos.Networking.Responses.FortDetailsResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.FortDetailsResponse) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.FortDetailsResponse() {
         return self
        }
        if other.hasFortId {
             fortId = other.fortId
        }
        if other.hasTeamColor {
             teamColor = other.teamColor
        }
        if (other.hasPokemonData) {
            try mergePokemonData(value: other.pokemonData)
        }
        if other.hasName {
             name = other.name
        }
        if !other.imageUrls.isEmpty {
            builderResult.imageUrls += other.imageUrls
        }
        if other.hasFp {
             fp = other.fp
        }
        if other.hasStamina {
             stamina = other.stamina
        }
        if other.hasMaxStamina {
             maxStamina = other.maxStamina
        }
        if other.hasType {
             type = other.type
        }
        if other.hasLatitude {
             latitude = other.latitude
        }
        if other.hasLongitude {
             longitude = other.longitude
        }
        if other.hasDescription {
             description_ = other.description_
        }
        if !other.modifiers.isEmpty  {
           builderResult.modifiers += other.modifiers
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            fortId = try codedInputStream.readString()

          case 16:
            let valueIntteamColor = try codedInputStream.readEnum()
            if let enumsteamColor = Pogoprotos.Enums.TeamColor(rawValue:valueIntteamColor){
                 teamColor = enumsteamColor
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntteamColor))
            }

          case 26:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasPokemonData {
              try subBuilder.mergeFrom(other: pokemonData)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            pokemonData = subBuilder.buildPartial()

          case 34:
            name = try codedInputStream.readString()

          case 42:
            imageUrls += [try codedInputStream.readString()]

          case 48:
            fp = try codedInputStream.readInt32()

          case 56:
            stamina = try codedInputStream.readInt32()

          case 64:
            maxStamina = try codedInputStream.readInt32()

          case 72:
            let valueInttype = try codedInputStream.readEnum()
            if let enumstype = Pogoprotos.Map.Fort.FortType(rawValue:valueInttype){
                 type = enumstype
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 9, value:Int64(valueInttype))
            }

          case 81:
            latitude = try codedInputStream.readDouble()

          case 89:
            longitude = try codedInputStream.readDouble()

          case 98:
            description_ = try codedInputStream.readString()

          case 106:
            let subBuilder = Pogoprotos.Map.Fort.FortModifier.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            modifiers.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
        if let jsonValueFortId = jsonMap["fortId"] as? String {
          resultDecodedBuilder.fortId = jsonValueFortId
        }
        if let jsonValueTeamColor = jsonMap["teamColor"] as? String {
          resultDecodedBuilder.teamColor = try Pogoprotos.Enums.TeamColor.fromString(str: jsonValueTeamColor)
        }
        if let jsonValuePokemonData = jsonMap["pokemonData"] as? Dictionary<String,Any> {
          resultDecodedBuilder.pokemonData = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonMap:jsonValuePokemonData).build()

        }
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueImageUrls = jsonMap["imageUrls"] as? Array<String> {
          var jsonArrayImageUrls:Array<String> = []
          for oneValueImageUrls in jsonValueImageUrls {
            jsonArrayImageUrls.append(oneValueImageUrls)
          }
          resultDecodedBuilder.imageUrls = jsonArrayImageUrls
        }
        if let jsonValueFp = jsonMap["fp"] as? Int {
          resultDecodedBuilder.fp = Int32(jsonValueFp)
        }
        if let jsonValueStamina = jsonMap["stamina"] as? Int {
          resultDecodedBuilder.stamina = Int32(jsonValueStamina)
        }
        if let jsonValueMaxStamina = jsonMap["maxStamina"] as? Int {
          resultDecodedBuilder.maxStamina = Int32(jsonValueMaxStamina)
        }
        if let jsonValueType = jsonMap["type"] as? String {
          resultDecodedBuilder.type = try Pogoprotos.Map.Fort.FortType.fromString(str: jsonValueType)
        }
        if let jsonValueLatitude = jsonMap["latitude"] as? Double {
          resultDecodedBuilder.latitude = Double(jsonValueLatitude)
        }
        if let jsonValueLongitude = jsonMap["longitude"] as? Double {
          resultDecodedBuilder.longitude = Double(jsonValueLongitude)
        }
        if let jsonValueDescription = jsonMap["description"] as? String {
          resultDecodedBuilder.description_ = jsonValueDescription
        }
        if let jsonValueModifiers = jsonMap["modifiers"] as? Array<Dictionary<String,Any>> {
          var jsonArrayModifiers:Array<Pogoprotos.Map.Fort.FortModifier> = []
          for oneValueModifiers in jsonValueModifiers {
            let messageFromStringModifiers = try Pogoprotos.Map.Fort.FortModifier.Builder.decodeToBuilder(jsonMap:oneValueModifiers).build()

            jsonArrayModifiers.append(messageFromStringModifiers)
          }
          resultDecodedBuilder.modifiers = jsonArrayModifiers
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class FortRecallPokemonResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.FortRecallPokemonResponse, rhs: Pogoprotos.Networking.Responses.FortRecallPokemonResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasFortDetails == rhs.hasFortDetails) && (!lhs.hasFortDetails || lhs.fortDetails == rhs.fortDetails)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case noResultSet = 0
        case success = 1
        case errorNotInRange = 2
        case errorPokemonNotOnFort = 3
        case errorNoPlayer = 4
        public func toString() -> String {
          switch self {
          case .noResultSet: return "NO_RESULT_SET"
          case .success: return "SUCCESS"
          case .errorNotInRange: return "ERROR_NOT_IN_RANGE"
          case .errorPokemonNotOnFort: return "ERROR_POKEMON_NOT_ON_FORT"
          case .errorNoPlayer: return "ERROR_NO_PLAYER"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Result {
          switch str {
          case "NO_RESULT_SET":  return .noResultSet
          case "SUCCESS":  return .success
          case "ERROR_NOT_IN_RANGE":  return .errorNotInRange
          case "ERROR_POKEMON_NOT_ON_FORT":  return .errorPokemonNotOnFort
          case "ERROR_NO_PLAYER":  return .errorNoPlayer
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .noResultSet: return ".noResultSet"
          case .success: return ".success"
          case .errorNotInRange: return ".errorNotInRange"
          case .errorPokemonNotOnFort: return ".errorPokemonNotOnFort"
          case .errorNoPlayer: return ".errorNoPlayer"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Result = Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Result.noResultSet
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var fortDetails:Pogoprotos.Networking.Responses.FortDetailsResponse!
    public fileprivate(set) var hasFortDetails:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasFortDetails {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:fortDetails)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasFortDetails {
          if let varSizefortDetails = fortDetails?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizefortDetails
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.FortRecallPokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.FortRecallPokemonResponse) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasFortDetails {
        jsonMap["fortDetails"] = try fortDetails.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasFortDetails {
        output += "\(indent) fortDetails {\n"
        if let outDescFortDetails = fortDetails {
          output += try outDescFortDetails.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasFortDetails {
                if let hashValuefortDetails = fortDetails?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuefortDetails
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.FortRecallPokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.FortRecallPokemonResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.FortRecallPokemonResponse = Pogoprotos.Networking.Responses.FortRecallPokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Result) -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .noResultSet
           return self
        }
      public var hasFortDetails:Bool {
           get {
               return builderResult.hasFortDetails
           }
      }
      public var fortDetails:Pogoprotos.Networking.Responses.FortDetailsResponse! {
           get {
               if fortDetailsBuilder_ != nil {
                  builderResult.fortDetails = fortDetailsBuilder_.getMessage()
               }
               return builderResult.fortDetails
           }
           set (value) {
               builderResult.hasFortDetails = true
               builderResult.fortDetails = value
           }
      }
      fileprivate var fortDetailsBuilder_:Pogoprotos.Networking.Responses.FortDetailsResponse.Builder! {
           didSet {
              builderResult.hasFortDetails = true
           }
      }
      public func getFortDetailsBuilder() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        if fortDetailsBuilder_ == nil {
           fortDetailsBuilder_ = Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
           builderResult.fortDetails = fortDetailsBuilder_.getMessage()
           if fortDetails != nil {
              try! fortDetailsBuilder_.mergeFrom(other: fortDetails)
           }
        }
        return fortDetailsBuilder_
      }
      @discardableResult
      public func setFortDetails(_ value:Pogoprotos.Networking.Responses.FortDetailsResponse!) -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        self.fortDetails = value
        return self
      }
      @discardableResult
      public func mergeFortDetails(value:Pogoprotos.Networking.Responses.FortDetailsResponse) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        if builderResult.hasFortDetails {
          builderResult.fortDetails = try Pogoprotos.Networking.Responses.FortDetailsResponse.builderWithPrototype(prototype:builderResult.fortDetails).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.fortDetails = value
        }
        builderResult.hasFortDetails = true
        return self
      }
      @discardableResult
      public func clearFortDetails() -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        fortDetailsBuilder_ = nil
        builderResult.hasFortDetails = false
        builderResult.fortDetails = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.FortRecallPokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.FortRecallPokemonResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.FortRecallPokemonResponse) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.FortRecallPokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasFortDetails) {
            try mergeFortDetails(value: other.fortDetails)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Networking.Responses.FortDetailsResponse.Builder = Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
            if hasFortDetails {
              try subBuilder.mergeFrom(other: fortDetails)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            fortDetails = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueFortDetails = jsonMap["fortDetails"] as? Dictionary<String,Any> {
          resultDecodedBuilder.fortDetails = try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder.decodeToBuilder(jsonMap:jsonValueFortDetails).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class FortSearchResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.FortSearchResponse, rhs: Pogoprotos.Networking.Responses.FortSearchResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.itemsAwarded == rhs.itemsAwarded)
      fieldCheck = fieldCheck && (lhs.hasGemsAwarded == rhs.hasGemsAwarded) && (!lhs.hasGemsAwarded || lhs.gemsAwarded == rhs.gemsAwarded)
      fieldCheck = fieldCheck && (lhs.hasPokemonDataEgg == rhs.hasPokemonDataEgg) && (!lhs.hasPokemonDataEgg || lhs.pokemonDataEgg == rhs.pokemonDataEgg)
      fieldCheck = fieldCheck && (lhs.hasExperienceAwarded == rhs.hasExperienceAwarded) && (!lhs.hasExperienceAwarded || lhs.experienceAwarded == rhs.experienceAwarded)
      fieldCheck = fieldCheck && (lhs.hasCooldownCompleteTimestampMs == rhs.hasCooldownCompleteTimestampMs) && (!lhs.hasCooldownCompleteTimestampMs || lhs.cooldownCompleteTimestampMs == rhs.cooldownCompleteTimestampMs)
      fieldCheck = fieldCheck && (lhs.hasChainHackSequenceNumber == rhs.hasChainHackSequenceNumber) && (!lhs.hasChainHackSequenceNumber || lhs.chainHackSequenceNumber == rhs.chainHackSequenceNumber)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case noResultSet = 0
        case success = 1
        case outOfRange = 2
        case inCooldownPeriod = 3
        case inventoryFull = 4
        case exceededDailyLimit = 5
        public func toString() -> String {
          switch self {
          case .noResultSet: return "NO_RESULT_SET"
          case .success: return "SUCCESS"
          case .outOfRange: return "OUT_OF_RANGE"
          case .inCooldownPeriod: return "IN_COOLDOWN_PERIOD"
          case .inventoryFull: return "INVENTORY_FULL"
          case .exceededDailyLimit: return "EXCEEDED_DAILY_LIMIT"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Result {
          switch str {
          case "NO_RESULT_SET":  return .noResultSet
          case "SUCCESS":  return .success
          case "OUT_OF_RANGE":  return .outOfRange
          case "IN_COOLDOWN_PERIOD":  return .inCooldownPeriod
          case "INVENTORY_FULL":  return .inventoryFull
          case "EXCEEDED_DAILY_LIMIT":  return .exceededDailyLimit
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .noResultSet: return ".noResultSet"
          case .success: return ".success"
          case .outOfRange: return ".outOfRange"
          case .inCooldownPeriod: return ".inCooldownPeriod"
          case .inventoryFull: return ".inventoryFull"
          case .exceededDailyLimit: return ".exceededDailyLimit"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.FortSearchResponse.Result = Pogoprotos.Networking.Responses.FortSearchResponse.Result.noResultSet
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var itemsAwarded:Array<Pogoprotos.Inventory.Item.ItemAward>  = Array<Pogoprotos.Inventory.Item.ItemAward>()
    public fileprivate(set) var gemsAwarded:Int32 = Int32(0)
    public fileprivate(set) var hasGemsAwarded:Bool = false

    public fileprivate(set) var pokemonDataEgg:Pogoprotos.Data.PokemonData!
    public fileprivate(set) var hasPokemonDataEgg:Bool = false
    public fileprivate(set) var experienceAwarded:Int32 = Int32(0)
    public fileprivate(set) var hasExperienceAwarded:Bool = false

    public fileprivate(set) var cooldownCompleteTimestampMs:Int64 = Int64(0)
    public fileprivate(set) var hasCooldownCompleteTimestampMs:Bool = false

    public fileprivate(set) var chainHackSequenceNumber:Int32 = Int32(0)
    public fileprivate(set) var hasChainHackSequenceNumber:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      for oneElementItemsAwarded in itemsAwarded {
          try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementItemsAwarded)
      }
      if hasGemsAwarded {
        try codedOutputStream.writeInt32(fieldNumber: 3, value:gemsAwarded)
      }
      if hasPokemonDataEgg {
        try codedOutputStream.writeMessage(fieldNumber: 4, value:pokemonDataEgg)
      }
      if hasExperienceAwarded {
        try codedOutputStream.writeInt32(fieldNumber: 5, value:experienceAwarded)
      }
      if hasCooldownCompleteTimestampMs {
        try codedOutputStream.writeInt64(fieldNumber: 6, value:cooldownCompleteTimestampMs)
      }
      if hasChainHackSequenceNumber {
        try codedOutputStream.writeInt32(fieldNumber: 7, value:chainHackSequenceNumber)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      for oneElementItemsAwarded in itemsAwarded {
          serialize_size += oneElementItemsAwarded.computeMessageSize(fieldNumber: 2)
      }
      if hasGemsAwarded {
        serialize_size += gemsAwarded.computeInt32Size(fieldNumber: 3)
      }
      if hasPokemonDataEgg {
          if let varSizepokemonDataEgg = pokemonDataEgg?.computeMessageSize(fieldNumber: 4) {
              serialize_size += varSizepokemonDataEgg
          }
      }
      if hasExperienceAwarded {
        serialize_size += experienceAwarded.computeInt32Size(fieldNumber: 5)
      }
      if hasCooldownCompleteTimestampMs {
        serialize_size += cooldownCompleteTimestampMs.computeInt64Size(fieldNumber: 6)
      }
      if hasChainHackSequenceNumber {
        serialize_size += chainHackSequenceNumber.computeInt32Size(fieldNumber: 7)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
      return Pogoprotos.Networking.Responses.FortSearchResponse.classBuilder() as! Pogoprotos.Networking.Responses.FortSearchResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.FortSearchResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.FortSearchResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.FortSearchResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.FortSearchResponse) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if !itemsAwarded.isEmpty {
        var jsonArrayItemsAwarded:Array<Dictionary<String,Any>> = []
          for oneValueItemsAwarded in itemsAwarded {
            let ecodedMessageItemsAwarded = try oneValueItemsAwarded.encode()
            jsonArrayItemsAwarded.append(ecodedMessageItemsAwarded)
          }
        jsonMap["itemsAwarded"] = jsonArrayItemsAwarded
      }
      if hasGemsAwarded {
        jsonMap["gemsAwarded"] = Int(gemsAwarded)
      }
      if hasPokemonDataEgg {
        jsonMap["pokemonDataEgg"] = try pokemonDataEgg.encode()
      }
      if hasExperienceAwarded {
        jsonMap["experienceAwarded"] = Int(experienceAwarded)
      }
      if hasCooldownCompleteTimestampMs {
        jsonMap["cooldownCompleteTimestampMs"] = "\(cooldownCompleteTimestampMs)"
      }
      if hasChainHackSequenceNumber {
        jsonMap["chainHackSequenceNumber"] = Int(chainHackSequenceNumber)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      var itemsAwardedElementIndex:Int = 0
      for oneElementItemsAwarded in itemsAwarded {
          output += "\(indent) itemsAwarded[\(itemsAwardedElementIndex)] {\n"
          output += try oneElementItemsAwarded.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          itemsAwardedElementIndex += 1
      }
      if hasGemsAwarded {
        output += "\(indent) gemsAwarded: \(gemsAwarded) \n"
      }
      if hasPokemonDataEgg {
        output += "\(indent) pokemonDataEgg {\n"
        if let outDescPokemonDataEgg = pokemonDataEgg {
          output += try outDescPokemonDataEgg.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasExperienceAwarded {
        output += "\(indent) experienceAwarded: \(experienceAwarded) \n"
      }
      if hasCooldownCompleteTimestampMs {
        output += "\(indent) cooldownCompleteTimestampMs: \(cooldownCompleteTimestampMs) \n"
      }
      if hasChainHackSequenceNumber {
        output += "\(indent) chainHackSequenceNumber: \(chainHackSequenceNumber) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            for oneElementItemsAwarded in itemsAwarded {
                hashCode = (hashCode &* 31) &+ oneElementItemsAwarded.hashValue
            }
            if hasGemsAwarded {
               hashCode = (hashCode &* 31) &+ gemsAwarded.hashValue
            }
            if hasPokemonDataEgg {
                if let hashValuepokemonDataEgg = pokemonDataEgg?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepokemonDataEgg
                }
            }
            if hasExperienceAwarded {
               hashCode = (hashCode &* 31) &+ experienceAwarded.hashValue
            }
            if hasCooldownCompleteTimestampMs {
               hashCode = (hashCode &* 31) &+ cooldownCompleteTimestampMs.hashValue
            }
            if hasChainHackSequenceNumber {
               hashCode = (hashCode &* 31) &+ chainHackSequenceNumber.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.FortSearchResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.FortSearchResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.FortSearchResponse = Pogoprotos.Networking.Responses.FortSearchResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.FortSearchResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.FortSearchResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.FortSearchResponse.Result) -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .noResultSet
           return self
        }
      public var itemsAwarded:Array<Pogoprotos.Inventory.Item.ItemAward> {
           get {
               return builderResult.itemsAwarded
           }
           set (value) {
               builderResult.itemsAwarded = value
           }
      }
      @discardableResult
      public func setItemsAwarded(_ value:Array<Pogoprotos.Inventory.Item.ItemAward>) -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        self.itemsAwarded = value
        return self
      }
      @discardableResult
      public func clearItemsAwarded() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        builderResult.itemsAwarded.removeAll(keepingCapacity: false)
        return self
      }
      public var hasGemsAwarded:Bool {
           get {
                return builderResult.hasGemsAwarded
           }
      }
      public var gemsAwarded:Int32 {
           get {
                return builderResult.gemsAwarded
           }
           set (value) {
               builderResult.hasGemsAwarded = true
               builderResult.gemsAwarded = value
           }
      }
      @discardableResult
      public func setGemsAwarded(_ value:Int32) -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        self.gemsAwarded = value
        return self
      }
      @discardableResult
      public func clearGemsAwarded() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder{
           builderResult.hasGemsAwarded = false
           builderResult.gemsAwarded = Int32(0)
           return self
      }
      public var hasPokemonDataEgg:Bool {
           get {
               return builderResult.hasPokemonDataEgg
           }
      }
      public var pokemonDataEgg:Pogoprotos.Data.PokemonData! {
           get {
               if pokemonDataEggBuilder_ != nil {
                  builderResult.pokemonDataEgg = pokemonDataEggBuilder_.getMessage()
               }
               return builderResult.pokemonDataEgg
           }
           set (value) {
               builderResult.hasPokemonDataEgg = true
               builderResult.pokemonDataEgg = value
           }
      }
      fileprivate var pokemonDataEggBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasPokemonDataEgg = true
           }
      }
      public func getPokemonDataEggBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if pokemonDataEggBuilder_ == nil {
           pokemonDataEggBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.pokemonDataEgg = pokemonDataEggBuilder_.getMessage()
           if pokemonDataEgg != nil {
              try! pokemonDataEggBuilder_.mergeFrom(other: pokemonDataEgg)
           }
        }
        return pokemonDataEggBuilder_
      }
      @discardableResult
      public func setPokemonDataEgg(_ value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        self.pokemonDataEgg = value
        return self
      }
      @discardableResult
      public func mergePokemonDataEgg(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        if builderResult.hasPokemonDataEgg {
          builderResult.pokemonDataEgg = try Pogoprotos.Data.PokemonData.builderWithPrototype(prototype:builderResult.pokemonDataEgg).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.pokemonDataEgg = value
        }
        builderResult.hasPokemonDataEgg = true
        return self
      }
      @discardableResult
      public func clearPokemonDataEgg() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        pokemonDataEggBuilder_ = nil
        builderResult.hasPokemonDataEgg = false
        builderResult.pokemonDataEgg = nil
        return self
      }
      public var hasExperienceAwarded:Bool {
           get {
                return builderResult.hasExperienceAwarded
           }
      }
      public var experienceAwarded:Int32 {
           get {
                return builderResult.experienceAwarded
           }
           set (value) {
               builderResult.hasExperienceAwarded = true
               builderResult.experienceAwarded = value
           }
      }
      @discardableResult
      public func setExperienceAwarded(_ value:Int32) -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        self.experienceAwarded = value
        return self
      }
      @discardableResult
      public func clearExperienceAwarded() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder{
           builderResult.hasExperienceAwarded = false
           builderResult.experienceAwarded = Int32(0)
           return self
      }
      public var hasCooldownCompleteTimestampMs:Bool {
           get {
                return builderResult.hasCooldownCompleteTimestampMs
           }
      }
      public var cooldownCompleteTimestampMs:Int64 {
           get {
                return builderResult.cooldownCompleteTimestampMs
           }
           set (value) {
               builderResult.hasCooldownCompleteTimestampMs = true
               builderResult.cooldownCompleteTimestampMs = value
           }
      }
      @discardableResult
      public func setCooldownCompleteTimestampMs(_ value:Int64) -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        self.cooldownCompleteTimestampMs = value
        return self
      }
      @discardableResult
      public func clearCooldownCompleteTimestampMs() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder{
           builderResult.hasCooldownCompleteTimestampMs = false
           builderResult.cooldownCompleteTimestampMs = Int64(0)
           return self
      }
      public var hasChainHackSequenceNumber:Bool {
           get {
                return builderResult.hasChainHackSequenceNumber
           }
      }
      public var chainHackSequenceNumber:Int32 {
           get {
                return builderResult.chainHackSequenceNumber
           }
           set (value) {
               builderResult.hasChainHackSequenceNumber = true
               builderResult.chainHackSequenceNumber = value
           }
      }
      @discardableResult
      public func setChainHackSequenceNumber(_ value:Int32) -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        self.chainHackSequenceNumber = value
        return self
      }
      @discardableResult
      public func clearChainHackSequenceNumber() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder{
           builderResult.hasChainHackSequenceNumber = false
           builderResult.chainHackSequenceNumber = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.FortSearchResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        return try Pogoprotos.Networking.Responses.FortSearchResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.FortSearchResponse {
        let returnMe:Pogoprotos.Networking.Responses.FortSearchResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.FortSearchResponse) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        if other == Pogoprotos.Networking.Responses.FortSearchResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if !other.itemsAwarded.isEmpty  {
           builderResult.itemsAwarded += other.itemsAwarded
        }
        if other.hasGemsAwarded {
             gemsAwarded = other.gemsAwarded
        }
        if (other.hasPokemonDataEgg) {
            try mergePokemonDataEgg(value: other.pokemonDataEgg)
        }
        if other.hasExperienceAwarded {
             experienceAwarded = other.experienceAwarded
        }
        if other.hasCooldownCompleteTimestampMs {
             cooldownCompleteTimestampMs = other.cooldownCompleteTimestampMs
        }
        if other.hasChainHackSequenceNumber {
             chainHackSequenceNumber = other.chainHackSequenceNumber
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.FortSearchResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder = Pogoprotos.Inventory.Item.ItemAward.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            itemsAwarded.append(subBuilder.buildPartial())

          case 24:
            gemsAwarded = try codedInputStream.readInt32()

          case 34:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasPokemonDataEgg {
              try subBuilder.mergeFrom(other: pokemonDataEgg)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            pokemonDataEgg = subBuilder.buildPartial()

          case 40:
            experienceAwarded = try codedInputStream.readInt32()

          case 48:
            cooldownCompleteTimestampMs = try codedInputStream.readInt64()

          case 56:
            chainHackSequenceNumber = try codedInputStream.readInt32()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.FortSearchResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.FortSearchResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueItemsAwarded = jsonMap["itemsAwarded"] as? Array<Dictionary<String,Any>> {
          var jsonArrayItemsAwarded:Array<Pogoprotos.Inventory.Item.ItemAward> = []
          for oneValueItemsAwarded in jsonValueItemsAwarded {
            let messageFromStringItemsAwarded = try Pogoprotos.Inventory.Item.ItemAward.Builder.decodeToBuilder(jsonMap:oneValueItemsAwarded).build()

            jsonArrayItemsAwarded.append(messageFromStringItemsAwarded)
          }
          resultDecodedBuilder.itemsAwarded = jsonArrayItemsAwarded
        }
        if let jsonValueGemsAwarded = jsonMap["gemsAwarded"] as? Int {
          resultDecodedBuilder.gemsAwarded = Int32(jsonValueGemsAwarded)
        }
        if let jsonValuePokemonDataEgg = jsonMap["pokemonDataEgg"] as? Dictionary<String,Any> {
          resultDecodedBuilder.pokemonDataEgg = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonMap:jsonValuePokemonDataEgg).build()

        }
        if let jsonValueExperienceAwarded = jsonMap["experienceAwarded"] as? Int {
          resultDecodedBuilder.experienceAwarded = Int32(jsonValueExperienceAwarded)
        }
        if let jsonValueCooldownCompleteTimestampMs = jsonMap["cooldownCompleteTimestampMs"] as? String {
          resultDecodedBuilder.cooldownCompleteTimestampMs = Int64(jsonValueCooldownCompleteTimestampMs)!
        }
        if let jsonValueChainHackSequenceNumber = jsonMap["chainHackSequenceNumber"] as? Int {
          resultDecodedBuilder.chainHackSequenceNumber = Int32(jsonValueChainHackSequenceNumber)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class GetAssetDigestResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.GetAssetDigestResponse, rhs: Pogoprotos.Networking.Responses.GetAssetDigestResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.digest == rhs.digest)
      fieldCheck = fieldCheck && (lhs.hasTimestampMs == rhs.hasTimestampMs) && (!lhs.hasTimestampMs || lhs.timestampMs == rhs.timestampMs)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var digest:Array<Pogoprotos.Data.AssetDigestEntry>  = Array<Pogoprotos.Data.AssetDigestEntry>()
    public fileprivate(set) var timestampMs:UInt64 = UInt64(0)
    public fileprivate(set) var hasTimestampMs:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      for oneElementDigest in digest {
          try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementDigest)
      }
      if hasTimestampMs {
        try codedOutputStream.writeUInt64(fieldNumber: 2, value:timestampMs)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementDigest in digest {
          serialize_size += oneElementDigest.computeMessageSize(fieldNumber: 1)
      }
      if hasTimestampMs {
        serialize_size += timestampMs.computeUInt64Size(fieldNumber: 2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
      return Pogoprotos.Networking.Responses.GetAssetDigestResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetAssetDigestResponse) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if !digest.isEmpty {
        var jsonArrayDigest:Array<Dictionary<String,Any>> = []
          for oneValueDigest in digest {
            let ecodedMessageDigest = try oneValueDigest.encode()
            jsonArrayDigest.append(ecodedMessageDigest)
          }
        jsonMap["digest"] = jsonArrayDigest
      }
      if hasTimestampMs {
        jsonMap["timestampMs"] = "\(timestampMs)"
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var digestElementIndex:Int = 0
      for oneElementDigest in digest {
          output += "\(indent) digest[\(digestElementIndex)] {\n"
          output += try oneElementDigest.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          digestElementIndex += 1
      }
      if hasTimestampMs {
        output += "\(indent) timestampMs: \(timestampMs) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementDigest in digest {
                hashCode = (hashCode &* 31) &+ oneElementDigest.hashValue
            }
            if hasTimestampMs {
               hashCode = (hashCode &* 31) &+ timestampMs.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetAssetDigestResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetAssetDigestResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.GetAssetDigestResponse = Pogoprotos.Networking.Responses.GetAssetDigestResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var digest:Array<Pogoprotos.Data.AssetDigestEntry> {
           get {
               return builderResult.digest
           }
           set (value) {
               builderResult.digest = value
           }
      }
      @discardableResult
      public func setDigest(_ value:Array<Pogoprotos.Data.AssetDigestEntry>) -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        self.digest = value
        return self
      }
      @discardableResult
      public func clearDigest() -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        builderResult.digest.removeAll(keepingCapacity: false)
        return self
      }
      public var hasTimestampMs:Bool {
           get {
                return builderResult.hasTimestampMs
           }
      }
      public var timestampMs:UInt64 {
           get {
                return builderResult.timestampMs
           }
           set (value) {
               builderResult.hasTimestampMs = true
               builderResult.timestampMs = value
           }
      }
      @discardableResult
      public func setTimestampMs(_ value:UInt64) -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        self.timestampMs = value
        return self
      }
      @discardableResult
      public func clearTimestampMs() -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder{
           builderResult.hasTimestampMs = false
           builderResult.timestampMs = UInt64(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetAssetDigestResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetAssetDigestResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetAssetDigestResponse) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetAssetDigestResponse() {
         return self
        }
        if !other.digest.isEmpty  {
           builderResult.digest += other.digest
        }
        if other.hasTimestampMs {
             timestampMs = other.timestampMs
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = Pogoprotos.Data.AssetDigestEntry.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            digest.append(subBuilder.buildPartial())

          case 16:
            timestampMs = try codedInputStream.readUInt64()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder()
        if let jsonValueDigest = jsonMap["digest"] as? Array<Dictionary<String,Any>> {
          var jsonArrayDigest:Array<Pogoprotos.Data.AssetDigestEntry> = []
          for oneValueDigest in jsonValueDigest {
            let messageFromStringDigest = try Pogoprotos.Data.AssetDigestEntry.Builder.decodeToBuilder(jsonMap:oneValueDigest).build()

            jsonArrayDigest.append(messageFromStringDigest)
          }
          resultDecodedBuilder.digest = jsonArrayDigest
        }
        if let jsonValueTimestampMs = jsonMap["timestampMs"] as? String {
          resultDecodedBuilder.timestampMs = UInt64(jsonValueTimestampMs)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class GetBuddyWalkedResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.GetBuddyWalkedResponse, rhs: Pogoprotos.Networking.Responses.GetBuddyWalkedResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
      fieldCheck = fieldCheck && (lhs.hasFamilyCandyId == rhs.hasFamilyCandyId) && (!lhs.hasFamilyCandyId || lhs.familyCandyId == rhs.familyCandyId)
      fieldCheck = fieldCheck && (lhs.hasCandyEarnedCount == rhs.hasCandyEarnedCount) && (!lhs.hasCandyEarnedCount || lhs.candyEarnedCount == rhs.candyEarnedCount)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var success:Bool = false
    public fileprivate(set) var hasSuccess:Bool = false

    public fileprivate(set) var familyCandyId:Pogoprotos.Enums.PokemonFamilyId = Pogoprotos.Enums.PokemonFamilyId.familyUnset
    public fileprivate(set) var hasFamilyCandyId:Bool = false
    public fileprivate(set) var candyEarnedCount:Int32 = Int32(0)
    public fileprivate(set) var hasCandyEarnedCount:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasSuccess {
        try codedOutputStream.writeBool(fieldNumber: 1, value:success)
      }
      if hasFamilyCandyId {
        try codedOutputStream.writeEnum(fieldNumber: 2, value:familyCandyId.rawValue)
      }
      if hasCandyEarnedCount {
        try codedOutputStream.writeInt32(fieldNumber: 3, value:candyEarnedCount)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(fieldNumber: 1)
      }
      if (hasFamilyCandyId) {
        serialize_size += familyCandyId.rawValue.computeEnumSize(fieldNumber: 2)
      }
      if hasCandyEarnedCount {
        serialize_size += candyEarnedCount.computeInt32Size(fieldNumber: 3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
      return Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetBuddyWalkedResponse) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if hasFamilyCandyId {
        jsonMap["familyCandyId"] = familyCandyId.toString()
      }
      if hasCandyEarnedCount {
        jsonMap["candyEarnedCount"] = Int(candyEarnedCount)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse {
      return try Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse {
      return try Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      if (hasFamilyCandyId) {
        output += "\(indent) familyCandyId: \(familyCandyId.description)\n"
      }
      if hasCandyEarnedCount {
        output += "\(indent) candyEarnedCount: \(candyEarnedCount) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            if hasFamilyCandyId {
               hashCode = (hashCode &* 31) &+ Int(familyCandyId.rawValue)
            }
            if hasCandyEarnedCount {
               hashCode = (hashCode &* 31) &+ candyEarnedCount.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetBuddyWalkedResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetBuddyWalkedResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.GetBuddyWalkedResponse = Pogoprotos.Networking.Responses.GetBuddyWalkedResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      @discardableResult
      public func setSuccess(_ value:Bool) -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
        self.success = value
        return self
      }
      @discardableResult
      public func clearSuccess() -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
        public var hasFamilyCandyId:Bool{
            get {
                return builderResult.hasFamilyCandyId
            }
        }
        public var familyCandyId:Pogoprotos.Enums.PokemonFamilyId {
            get {
                return builderResult.familyCandyId
            }
            set (value) {
                builderResult.hasFamilyCandyId = true
                builderResult.familyCandyId = value
            }
        }
      @discardableResult
        public func setFamilyCandyId(_ value:Pogoprotos.Enums.PokemonFamilyId) -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
          self.familyCandyId = value
          return self
        }
      @discardableResult
        public func clearFamilyCandyId() -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
           builderResult.hasFamilyCandyId = false
           builderResult.familyCandyId = .familyUnset
           return self
        }
      public var hasCandyEarnedCount:Bool {
           get {
                return builderResult.hasCandyEarnedCount
           }
      }
      public var candyEarnedCount:Int32 {
           get {
                return builderResult.candyEarnedCount
           }
           set (value) {
               builderResult.hasCandyEarnedCount = true
               builderResult.candyEarnedCount = value
           }
      }
      @discardableResult
      public func setCandyEarnedCount(_ value:Int32) -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
        self.candyEarnedCount = value
        return self
      }
      @discardableResult
      public func clearCandyEarnedCount() -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder{
           builderResult.hasCandyEarnedCount = false
           builderResult.candyEarnedCount = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetBuddyWalkedResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetBuddyWalkedResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetBuddyWalkedResponse) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetBuddyWalkedResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if other.hasFamilyCandyId {
             familyCandyId = other.familyCandyId
        }
        if other.hasCandyEarnedCount {
             candyEarnedCount = other.candyEarnedCount
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try codedInputStream.readBool()

          case 16:
            let valueIntfamilyCandyId = try codedInputStream.readEnum()
            if let enumsfamilyCandyId = Pogoprotos.Enums.PokemonFamilyId(rawValue:valueIntfamilyCandyId){
                 familyCandyId = enumsfamilyCandyId
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntfamilyCandyId))
            }

          case 24:
            candyEarnedCount = try codedInputStream.readInt32()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValueFamilyCandyId = jsonMap["familyCandyId"] as? String {
          resultDecodedBuilder.familyCandyId = try Pogoprotos.Enums.PokemonFamilyId.fromString(str: jsonValueFamilyCandyId)
        }
        if let jsonValueCandyEarnedCount = jsonMap["candyEarnedCount"] as? Int {
          resultDecodedBuilder.candyEarnedCount = Int32(jsonValueCandyEarnedCount)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class GetDownloadUrlsResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.GetDownloadUrlsResponse, rhs: Pogoprotos.Networking.Responses.GetDownloadUrlsResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.downloadUrls == rhs.downloadUrls)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var downloadUrls:Array<Pogoprotos.Data.DownloadUrlEntry>  = Array<Pogoprotos.Data.DownloadUrlEntry>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      for oneElementDownloadUrls in downloadUrls {
          try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementDownloadUrls)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementDownloadUrls in downloadUrls {
          serialize_size += oneElementDownloadUrls.computeMessageSize(fieldNumber: 1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
      return Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetDownloadUrlsResponse) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if !downloadUrls.isEmpty {
        var jsonArrayDownloadUrls:Array<Dictionary<String,Any>> = []
          for oneValueDownloadUrls in downloadUrls {
            let ecodedMessageDownloadUrls = try oneValueDownloadUrls.encode()
            jsonArrayDownloadUrls.append(ecodedMessageDownloadUrls)
          }
        jsonMap["downloadUrls"] = jsonArrayDownloadUrls
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var downloadUrlsElementIndex:Int = 0
      for oneElementDownloadUrls in downloadUrls {
          output += "\(indent) downloadUrls[\(downloadUrlsElementIndex)] {\n"
          output += try oneElementDownloadUrls.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          downloadUrlsElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementDownloadUrls in downloadUrls {
                hashCode = (hashCode &* 31) &+ oneElementDownloadUrls.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetDownloadUrlsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetDownloadUrlsResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.GetDownloadUrlsResponse = Pogoprotos.Networking.Responses.GetDownloadUrlsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var downloadUrls:Array<Pogoprotos.Data.DownloadUrlEntry> {
           get {
               return builderResult.downloadUrls
           }
           set (value) {
               builderResult.downloadUrls = value
           }
      }
      @discardableResult
      public func setDownloadUrls(_ value:Array<Pogoprotos.Data.DownloadUrlEntry>) -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        self.downloadUrls = value
        return self
      }
      @discardableResult
      public func clearDownloadUrls() -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        builderResult.downloadUrls.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetDownloadUrlsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetDownloadUrlsResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetDownloadUrlsResponse) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetDownloadUrlsResponse() {
         return self
        }
        if !other.downloadUrls.isEmpty  {
           builderResult.downloadUrls += other.downloadUrls
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = Pogoprotos.Data.DownloadUrlEntry.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            downloadUrls.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder()
        if let jsonValueDownloadUrls = jsonMap["downloadUrls"] as? Array<Dictionary<String,Any>> {
          var jsonArrayDownloadUrls:Array<Pogoprotos.Data.DownloadUrlEntry> = []
          for oneValueDownloadUrls in jsonValueDownloadUrls {
            let messageFromStringDownloadUrls = try Pogoprotos.Data.DownloadUrlEntry.Builder.decodeToBuilder(jsonMap:oneValueDownloadUrls).build()

            jsonArrayDownloadUrls.append(messageFromStringDownloadUrls)
          }
          resultDecodedBuilder.downloadUrls = jsonArrayDownloadUrls
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class GetGymDetailsResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.GetGymDetailsResponse, rhs: Pogoprotos.Networking.Responses.GetGymDetailsResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasGymState == rhs.hasGymState) && (!lhs.hasGymState || lhs.gymState == rhs.gymState)
      fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
      fieldCheck = fieldCheck && (lhs.urls == rhs.urls)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case errorNotInRange = 2
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .errorNotInRange: return "ERROR_NOT_IN_RANGE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "ERROR_NOT_IN_RANGE":  return .errorNotInRange
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .errorNotInRange: return ".errorNotInRange"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var gymState:Pogoprotos.Data.Gym.GymState!
    public fileprivate(set) var hasGymState:Bool = false
    public fileprivate(set) var name:String = ""
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var urls:Array<String> = Array<String>()
    public fileprivate(set) var result:Pogoprotos.Networking.Responses.GetGymDetailsResponse.Result = Pogoprotos.Networking.Responses.GetGymDetailsResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var description_:String = ""
    public fileprivate(set) var hasDescription:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasGymState {
        try codedOutputStream.writeMessage(fieldNumber: 1, value:gymState)
      }
      if hasName {
        try codedOutputStream.writeString(fieldNumber: 2, value:name)
      }
      if !urls.isEmpty {
        for oneValueurls in urls {
          try codedOutputStream.writeString(fieldNumber: 3, value:oneValueurls)
        }
      }
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 4, value:result.rawValue)
      }
      if hasDescription {
        try codedOutputStream.writeString(fieldNumber: 5, value:description_)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasGymState {
          if let varSizegymState = gymState?.computeMessageSize(fieldNumber: 1) {
              serialize_size += varSizegymState
          }
      }
      if hasName {
        serialize_size += name.computeStringSize(fieldNumber: 2)
      }
      var dataSizeUrls:Int32 = 0
      for oneValueurls in urls {
          dataSizeUrls += oneValueurls.computeStringSizeNoTag()
      }
      serialize_size += dataSizeUrls
      serialize_size += 1 * Int32(urls.count)
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 4)
      }
      if hasDescription {
        serialize_size += description_.computeStringSize(fieldNumber: 5)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
      return Pogoprotos.Networking.Responses.GetGymDetailsResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetGymDetailsResponse) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasGymState {
        jsonMap["gymState"] = try gymState.encode()
      }
      if hasName {
        jsonMap["name"] = name
      }
      if !urls.isEmpty {
        var jsonArrayUrls:Array<String> = []
          for oneValueUrls in urls {
            jsonArrayUrls.append(oneValueUrls)
          }
        jsonMap["urls"] = jsonArrayUrls
      }
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasDescription {
        jsonMap["description"] = description_
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasGymState {
        output += "\(indent) gymState {\n"
        if let outDescGymState = gymState {
          output += try outDescGymState.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      var urlsElementIndex:Int = 0
      for oneValueUrls in urls  {
          output += "\(indent) urls[\(urlsElementIndex)]: \(oneValueUrls)\n"
          urlsElementIndex += 1
      }
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasDescription {
        output += "\(indent) description: \(description_) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasGymState {
                if let hashValuegymState = gymState?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuegymState
                }
            }
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            for oneValueUrls in urls {
                hashCode = (hashCode &* 31) &+ oneValueUrls.hashValue
            }
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasDescription {
               hashCode = (hashCode &* 31) &+ description_.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetGymDetailsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetGymDetailsResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.GetGymDetailsResponse = Pogoprotos.Networking.Responses.GetGymDetailsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasGymState:Bool {
           get {
               return builderResult.hasGymState
           }
      }
      public var gymState:Pogoprotos.Data.Gym.GymState! {
           get {
               if gymStateBuilder_ != nil {
                  builderResult.gymState = gymStateBuilder_.getMessage()
               }
               return builderResult.gymState
           }
           set (value) {
               builderResult.hasGymState = true
               builderResult.gymState = value
           }
      }
      fileprivate var gymStateBuilder_:Pogoprotos.Data.Gym.GymState.Builder! {
           didSet {
              builderResult.hasGymState = true
           }
      }
      public func getGymStateBuilder() -> Pogoprotos.Data.Gym.GymState.Builder {
        if gymStateBuilder_ == nil {
           gymStateBuilder_ = Pogoprotos.Data.Gym.GymState.Builder()
           builderResult.gymState = gymStateBuilder_.getMessage()
           if gymState != nil {
              try! gymStateBuilder_.mergeFrom(other: gymState)
           }
        }
        return gymStateBuilder_
      }
      @discardableResult
      public func setGymState(_ value:Pogoprotos.Data.Gym.GymState!) -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        self.gymState = value
        return self
      }
      @discardableResult
      public func mergeGymState(value:Pogoprotos.Data.Gym.GymState) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        if builderResult.hasGymState {
          builderResult.gymState = try Pogoprotos.Data.Gym.GymState.builderWithPrototype(prototype:builderResult.gymState).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.gymState = value
        }
        builderResult.hasGymState = true
        return self
      }
      @discardableResult
      public func clearGymState() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        gymStateBuilder_ = nil
        builderResult.hasGymState = false
        builderResult.gymState = nil
        return self
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      @discardableResult
      public func setName(_ value:String) -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        self.name = value
        return self
      }
      @discardableResult
      public func clearName() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var urls:Array<String> {
           get {
               return builderResult.urls
           }
           set (array) {
               builderResult.urls = array
           }
      }
      @discardableResult
      public func setUrls(_ value:Array<String>) -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        self.urls = value
        return self
      }
      @discardableResult
      public func clearUrls() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
         builderResult.urls.removeAll(keepingCapacity: false)
         return self
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.GetGymDetailsResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.GetGymDetailsResponse.Result) -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasDescription:Bool {
           get {
                return builderResult.hasDescription
           }
      }
      public var description_:String {
           get {
                return builderResult.description_
           }
           set (value) {
               builderResult.hasDescription = true
               builderResult.description_ = value
           }
      }
      @discardableResult
      public func setDescription(_ value:String) -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        self.description_ = value
        return self
      }
      @discardableResult
      public func clearDescription() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder{
           builderResult.hasDescription = false
           builderResult.description_ = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetGymDetailsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetGymDetailsResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetGymDetailsResponse) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetGymDetailsResponse() {
         return self
        }
        if (other.hasGymState) {
            try mergeGymState(value: other.gymState)
        }
        if other.hasName {
             name = other.name
        }
        if !other.urls.isEmpty {
            builderResult.urls += other.urls
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasDescription {
             description_ = other.description_
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder:Pogoprotos.Data.Gym.GymState.Builder = Pogoprotos.Data.Gym.GymState.Builder()
            if hasGymState {
              try subBuilder.mergeFrom(other: gymState)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            gymState = subBuilder.buildPartial()

          case 18:
            name = try codedInputStream.readString()

          case 26:
            urls += [try codedInputStream.readString()]

          case 32:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.GetGymDetailsResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntresult))
            }

          case 42:
            description_ = try codedInputStream.readString()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder()
        if let jsonValueGymState = jsonMap["gymState"] as? Dictionary<String,Any> {
          resultDecodedBuilder.gymState = try Pogoprotos.Data.Gym.GymState.Builder.decodeToBuilder(jsonMap:jsonValueGymState).build()

        }
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueUrls = jsonMap["urls"] as? Array<String> {
          var jsonArrayUrls:Array<String> = []
          for oneValueUrls in jsonValueUrls {
            jsonArrayUrls.append(oneValueUrls)
          }
          resultDecodedBuilder.urls = jsonArrayUrls
        }
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueDescription = jsonMap["description"] as? String {
          resultDecodedBuilder.description_ = jsonValueDescription
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class GetHatchedEggsResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.GetHatchedEggsResponse, rhs: Pogoprotos.Networking.Responses.GetHatchedEggsResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
      fieldCheck = fieldCheck && (lhs.pokemonId == rhs.pokemonId)
      fieldCheck = fieldCheck && (lhs.experienceAwarded == rhs.experienceAwarded)
      fieldCheck = fieldCheck && (lhs.candyAwarded == rhs.candyAwarded)
      fieldCheck = fieldCheck && (lhs.stardustAwarded == rhs.stardustAwarded)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var success:Bool = false
    public fileprivate(set) var hasSuccess:Bool = false

    public fileprivate(set) var pokemonId:Array<UInt64> = Array<UInt64>()
    private var pokemonIdMemoizedSerializedSize:Int32 = -1
    public fileprivate(set) var experienceAwarded:Array<Int32> = Array<Int32>()
    private var experienceAwardedMemoizedSerializedSize:Int32 = -1
    public fileprivate(set) var candyAwarded:Array<Int32> = Array<Int32>()
    private var candyAwardedMemoizedSerializedSize:Int32 = -1
    public fileprivate(set) var stardustAwarded:Array<Int32> = Array<Int32>()
    private var stardustAwardedMemoizedSerializedSize:Int32 = -1
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasSuccess {
        try codedOutputStream.writeBool(fieldNumber: 1, value:success)
      }
      if !pokemonId.isEmpty {
        try codedOutputStream.writeRawVarint32(value: 18)
        try codedOutputStream.writeRawVarint32(value: pokemonIdMemoizedSerializedSize)
        for oneValuepokemonId in pokemonId {
          try codedOutputStream.writeFixed64NoTag(value: oneValuepokemonId)
        }
      }
      if !experienceAwarded.isEmpty {
        try codedOutputStream.writeRawVarint32(value: 26)
        try codedOutputStream.writeRawVarint32(value: experienceAwardedMemoizedSerializedSize)
        for oneValueexperienceAwarded in experienceAwarded {
          try codedOutputStream.writeInt32NoTag(value: oneValueexperienceAwarded)
        }
      }
      if !candyAwarded.isEmpty {
        try codedOutputStream.writeRawVarint32(value: 34)
        try codedOutputStream.writeRawVarint32(value: candyAwardedMemoizedSerializedSize)
        for oneValuecandyAwarded in candyAwarded {
          try codedOutputStream.writeInt32NoTag(value: oneValuecandyAwarded)
        }
      }
      if !stardustAwarded.isEmpty {
        try codedOutputStream.writeRawVarint32(value: 42)
        try codedOutputStream.writeRawVarint32(value: stardustAwardedMemoizedSerializedSize)
        for oneValuestardustAwarded in stardustAwarded {
          try codedOutputStream.writeInt32NoTag(value: oneValuestardustAwarded)
        }
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(fieldNumber: 1)
      }
      var dataSizePokemonId:Int32 = 0
      dataSizePokemonId = 8 * Int32(pokemonId.count)
      serialize_size += dataSizePokemonId
      if !pokemonId.isEmpty {
        serialize_size += 1
        serialize_size += dataSizePokemonId.computeInt32SizeNoTag()
      }
      pokemonIdMemoizedSerializedSize = dataSizePokemonId
      var dataSizeExperienceAwarded:Int32 = 0
      for oneValueexperienceAwarded in experienceAwarded {
          dataSizeExperienceAwarded += oneValueexperienceAwarded.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeExperienceAwarded
      if !experienceAwarded.isEmpty {
        serialize_size += 1
        serialize_size += dataSizeExperienceAwarded.computeInt32SizeNoTag()
      }
      experienceAwardedMemoizedSerializedSize = dataSizeExperienceAwarded
      var dataSizeCandyAwarded:Int32 = 0
      for oneValuecandyAwarded in candyAwarded {
          dataSizeCandyAwarded += oneValuecandyAwarded.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeCandyAwarded
      if !candyAwarded.isEmpty {
        serialize_size += 1
        serialize_size += dataSizeCandyAwarded.computeInt32SizeNoTag()
      }
      candyAwardedMemoizedSerializedSize = dataSizeCandyAwarded
      var dataSizeStardustAwarded:Int32 = 0
      for oneValuestardustAwarded in stardustAwarded {
          dataSizeStardustAwarded += oneValuestardustAwarded.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeStardustAwarded
      if !stardustAwarded.isEmpty {
        serialize_size += 1
        serialize_size += dataSizeStardustAwarded.computeInt32SizeNoTag()
      }
      stardustAwardedMemoizedSerializedSize = dataSizeStardustAwarded
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
      return Pogoprotos.Networking.Responses.GetHatchedEggsResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetHatchedEggsResponse) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if !pokemonId.isEmpty {
        var jsonArrayPokemonId:Array<String> = []
          for oneValuePokemonId in pokemonId {
            jsonArrayPokemonId.append("\(oneValuePokemonId)")
          }
        jsonMap["pokemonId"] = jsonArrayPokemonId
      }
      if !experienceAwarded.isEmpty {
        var jsonArrayExperienceAwarded:Array<Int> = []
          for oneValueExperienceAwarded in experienceAwarded {
            jsonArrayExperienceAwarded.append(Int(oneValueExperienceAwarded))
          }
        jsonMap["experienceAwarded"] = jsonArrayExperienceAwarded
      }
      if !candyAwarded.isEmpty {
        var jsonArrayCandyAwarded:Array<Int> = []
          for oneValueCandyAwarded in candyAwarded {
            jsonArrayCandyAwarded.append(Int(oneValueCandyAwarded))
          }
        jsonMap["candyAwarded"] = jsonArrayCandyAwarded
      }
      if !stardustAwarded.isEmpty {
        var jsonArrayStardustAwarded:Array<Int> = []
          for oneValueStardustAwarded in stardustAwarded {
            jsonArrayStardustAwarded.append(Int(oneValueStardustAwarded))
          }
        jsonMap["stardustAwarded"] = jsonArrayStardustAwarded
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      var pokemonIdElementIndex:Int = 0
      for oneValuePokemonId in pokemonId  {
          output += "\(indent) pokemonId[\(pokemonIdElementIndex)]: \(oneValuePokemonId)\n"
          pokemonIdElementIndex += 1
      }
      var experienceAwardedElementIndex:Int = 0
      for oneValueExperienceAwarded in experienceAwarded  {
          output += "\(indent) experienceAwarded[\(experienceAwardedElementIndex)]: \(oneValueExperienceAwarded)\n"
          experienceAwardedElementIndex += 1
      }
      var candyAwardedElementIndex:Int = 0
      for oneValueCandyAwarded in candyAwarded  {
          output += "\(indent) candyAwarded[\(candyAwardedElementIndex)]: \(oneValueCandyAwarded)\n"
          candyAwardedElementIndex += 1
      }
      var stardustAwardedElementIndex:Int = 0
      for oneValueStardustAwarded in stardustAwarded  {
          output += "\(indent) stardustAwarded[\(stardustAwardedElementIndex)]: \(oneValueStardustAwarded)\n"
          stardustAwardedElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            for oneValuePokemonId in pokemonId {
                hashCode = (hashCode &* 31) &+ oneValuePokemonId.hashValue
            }
            for oneValueExperienceAwarded in experienceAwarded {
                hashCode = (hashCode &* 31) &+ oneValueExperienceAwarded.hashValue
            }
            for oneValueCandyAwarded in candyAwarded {
                hashCode = (hashCode &* 31) &+ oneValueCandyAwarded.hashValue
            }
            for oneValueStardustAwarded in stardustAwarded {
                hashCode = (hashCode &* 31) &+ oneValueStardustAwarded.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetHatchedEggsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetHatchedEggsResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.GetHatchedEggsResponse = Pogoprotos.Networking.Responses.GetHatchedEggsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      @discardableResult
      public func setSuccess(_ value:Bool) -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        self.success = value
        return self
      }
      @discardableResult
      public func clearSuccess() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var pokemonId:Array<UInt64> {
           get {
               return builderResult.pokemonId
           }
           set (array) {
               builderResult.pokemonId = array
           }
      }
      @discardableResult
      public func setPokemonId(_ value:Array<UInt64>) -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        self.pokemonId = value
        return self
      }
      @discardableResult
      public func clearPokemonId() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
         builderResult.pokemonId.removeAll(keepingCapacity: false)
         return self
      }
      public var experienceAwarded:Array<Int32> {
           get {
               return builderResult.experienceAwarded
           }
           set (array) {
               builderResult.experienceAwarded = array
           }
      }
      @discardableResult
      public func setExperienceAwarded(_ value:Array<Int32>) -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        self.experienceAwarded = value
        return self
      }
      @discardableResult
      public func clearExperienceAwarded() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
         builderResult.experienceAwarded.removeAll(keepingCapacity: false)
         return self
      }
      public var candyAwarded:Array<Int32> {
           get {
               return builderResult.candyAwarded
           }
           set (array) {
               builderResult.candyAwarded = array
           }
      }
      @discardableResult
      public func setCandyAwarded(_ value:Array<Int32>) -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        self.candyAwarded = value
        return self
      }
      @discardableResult
      public func clearCandyAwarded() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
         builderResult.candyAwarded.removeAll(keepingCapacity: false)
         return self
      }
      public var stardustAwarded:Array<Int32> {
           get {
               return builderResult.stardustAwarded
           }
           set (array) {
               builderResult.stardustAwarded = array
           }
      }
      @discardableResult
      public func setStardustAwarded(_ value:Array<Int32>) -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        self.stardustAwarded = value
        return self
      }
      @discardableResult
      public func clearStardustAwarded() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
         builderResult.stardustAwarded.removeAll(keepingCapacity: false)
         return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetHatchedEggsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetHatchedEggsResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetHatchedEggsResponse) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetHatchedEggsResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if !other.pokemonId.isEmpty {
            builderResult.pokemonId += other.pokemonId
        }
        if !other.experienceAwarded.isEmpty {
            builderResult.experienceAwarded += other.experienceAwarded
        }
        if !other.candyAwarded.isEmpty {
            builderResult.candyAwarded += other.candyAwarded
        }
        if !other.stardustAwarded.isEmpty {
            builderResult.stardustAwarded += other.stardustAwarded
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try codedInputStream.readBool()

          case 18:
            let length = Int(try codedInputStream.readRawVarint32())
            let limit = try codedInputStream.pushLimit(byteLimit: length)
            while (codedInputStream.bytesUntilLimit() > 0) {
              builderResult.pokemonId.append(try codedInputStream.readFixed64())
            }
            codedInputStream.popLimit(oldLimit: limit)

          case 26:
            let length = Int(try codedInputStream.readRawVarint32())
            let limit = try codedInputStream.pushLimit(byteLimit: length)
            while (codedInputStream.bytesUntilLimit() > 0) {
              builderResult.experienceAwarded.append(try codedInputStream.readInt32())
            }
            codedInputStream.popLimit(oldLimit: limit)

          case 34:
            let length = Int(try codedInputStream.readRawVarint32())
            let limit = try codedInputStream.pushLimit(byteLimit: length)
            while (codedInputStream.bytesUntilLimit() > 0) {
              builderResult.candyAwarded.append(try codedInputStream.readInt32())
            }
            codedInputStream.popLimit(oldLimit: limit)

          case 42:
            let length = Int(try codedInputStream.readRawVarint32())
            let limit = try codedInputStream.pushLimit(byteLimit: length)
            while (codedInputStream.bytesUntilLimit() > 0) {
              builderResult.stardustAwarded.append(try codedInputStream.readInt32())
            }
            codedInputStream.popLimit(oldLimit: limit)

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValuePokemonId = jsonMap["pokemonId"] as? Array<String> {
          var jsonArrayPokemonId:Array<UInt64> = []
          for oneValuePokemonId in jsonValuePokemonId {
            jsonArrayPokemonId.append(UInt64(oneValuePokemonId)!)
          }
          resultDecodedBuilder.pokemonId = jsonArrayPokemonId
        }
        if let jsonValueExperienceAwarded = jsonMap["experienceAwarded"] as? Array<Int> {
          var jsonArrayExperienceAwarded:Array<Int32> = []
          for oneValueExperienceAwarded in jsonValueExperienceAwarded {
            jsonArrayExperienceAwarded.append(Int32(oneValueExperienceAwarded))
          }
          resultDecodedBuilder.experienceAwarded = jsonArrayExperienceAwarded
        }
        if let jsonValueCandyAwarded = jsonMap["candyAwarded"] as? Array<Int> {
          var jsonArrayCandyAwarded:Array<Int32> = []
          for oneValueCandyAwarded in jsonValueCandyAwarded {
            jsonArrayCandyAwarded.append(Int32(oneValueCandyAwarded))
          }
          resultDecodedBuilder.candyAwarded = jsonArrayCandyAwarded
        }
        if let jsonValueStardustAwarded = jsonMap["stardustAwarded"] as? Array<Int> {
          var jsonArrayStardustAwarded:Array<Int32> = []
          for oneValueStardustAwarded in jsonValueStardustAwarded {
            jsonArrayStardustAwarded.append(Int32(oneValueStardustAwarded))
          }
          resultDecodedBuilder.stardustAwarded = jsonArrayStardustAwarded
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class GetIncensePokemonResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.GetIncensePokemonResponse, rhs: Pogoprotos.Networking.Responses.GetIncensePokemonResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasPokemonId == rhs.hasPokemonId) && (!lhs.hasPokemonId || lhs.pokemonId == rhs.pokemonId)
      fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
      fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
      fieldCheck = fieldCheck && (lhs.hasEncounterLocation == rhs.hasEncounterLocation) && (!lhs.hasEncounterLocation || lhs.encounterLocation == rhs.encounterLocation)
      fieldCheck = fieldCheck && (lhs.hasEncounterId == rhs.hasEncounterId) && (!lhs.hasEncounterId || lhs.encounterId == rhs.encounterId)
      fieldCheck = fieldCheck && (lhs.hasDisappearTimestampMs == rhs.hasDisappearTimestampMs) && (!lhs.hasDisappearTimestampMs || lhs.disappearTimestampMs == rhs.disappearTimestampMs)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case incenseEncounterUnknown = 0
        case incenseEncounterAvailable = 1
        case incenseEncounterNotAvailable = 2
        public func toString() -> String {
          switch self {
          case .incenseEncounterUnknown: return "INCENSE_ENCOUNTER_UNKNOWN"
          case .incenseEncounterAvailable: return "INCENSE_ENCOUNTER_AVAILABLE"
          case .incenseEncounterNotAvailable: return "INCENSE_ENCOUNTER_NOT_AVAILABLE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Result {
          switch str {
          case "INCENSE_ENCOUNTER_UNKNOWN":  return .incenseEncounterUnknown
          case "INCENSE_ENCOUNTER_AVAILABLE":  return .incenseEncounterAvailable
          case "INCENSE_ENCOUNTER_NOT_AVAILABLE":  return .incenseEncounterNotAvailable
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .incenseEncounterUnknown: return ".incenseEncounterUnknown"
          case .incenseEncounterAvailable: return ".incenseEncounterAvailable"
          case .incenseEncounterNotAvailable: return ".incenseEncounterNotAvailable"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Result = Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Result.incenseEncounterUnknown
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var pokemonId:Pogoprotos.Enums.PokemonId = Pogoprotos.Enums.PokemonId.missingno
    public fileprivate(set) var hasPokemonId:Bool = false
    public fileprivate(set) var latitude:Double = Double(0)
    public fileprivate(set) var hasLatitude:Bool = false

    public fileprivate(set) var longitude:Double = Double(0)
    public fileprivate(set) var hasLongitude:Bool = false

    public fileprivate(set) var encounterLocation:String = ""
    public fileprivate(set) var hasEncounterLocation:Bool = false

    public fileprivate(set) var encounterId:UInt64 = UInt64(0)
    public fileprivate(set) var hasEncounterId:Bool = false

    public fileprivate(set) var disappearTimestampMs:Int64 = Int64(0)
    public fileprivate(set) var hasDisappearTimestampMs:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasPokemonId {
        try codedOutputStream.writeEnum(fieldNumber: 2, value:pokemonId.rawValue)
      }
      if hasLatitude {
        try codedOutputStream.writeDouble(fieldNumber: 3, value:latitude)
      }
      if hasLongitude {
        try codedOutputStream.writeDouble(fieldNumber: 4, value:longitude)
      }
      if hasEncounterLocation {
        try codedOutputStream.writeString(fieldNumber: 5, value:encounterLocation)
      }
      if hasEncounterId {
        try codedOutputStream.writeFixed64(fieldNumber: 6, value:encounterId)
      }
      if hasDisappearTimestampMs {
        try codedOutputStream.writeInt64(fieldNumber: 7, value:disappearTimestampMs)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if (hasPokemonId) {
        serialize_size += pokemonId.rawValue.computeEnumSize(fieldNumber: 2)
      }
      if hasLatitude {
        serialize_size += latitude.computeDoubleSize(fieldNumber: 3)
      }
      if hasLongitude {
        serialize_size += longitude.computeDoubleSize(fieldNumber: 4)
      }
      if hasEncounterLocation {
        serialize_size += encounterLocation.computeStringSize(fieldNumber: 5)
      }
      if hasEncounterId {
        serialize_size += encounterId.computeFixed64Size(fieldNumber: 6)
      }
      if hasDisappearTimestampMs {
        serialize_size += disappearTimestampMs.computeInt64Size(fieldNumber: 7)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.GetIncensePokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetIncensePokemonResponse) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasPokemonId {
        jsonMap["pokemonId"] = pokemonId.toString()
      }
      if hasLatitude {
        jsonMap["latitude"] = Double(latitude)
      }
      if hasLongitude {
        jsonMap["longitude"] = Double(longitude)
      }
      if hasEncounterLocation {
        jsonMap["encounterLocation"] = encounterLocation
      }
      if hasEncounterId {
        jsonMap["encounterId"] = "\(encounterId)"
      }
      if hasDisappearTimestampMs {
        jsonMap["disappearTimestampMs"] = "\(disappearTimestampMs)"
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if (hasPokemonId) {
        output += "\(indent) pokemonId: \(pokemonId.description)\n"
      }
      if hasLatitude {
        output += "\(indent) latitude: \(latitude) \n"
      }
      if hasLongitude {
        output += "\(indent) longitude: \(longitude) \n"
      }
      if hasEncounterLocation {
        output += "\(indent) encounterLocation: \(encounterLocation) \n"
      }
      if hasEncounterId {
        output += "\(indent) encounterId: \(encounterId) \n"
      }
      if hasDisappearTimestampMs {
        output += "\(indent) disappearTimestampMs: \(disappearTimestampMs) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasPokemonId {
               hashCode = (hashCode &* 31) &+ Int(pokemonId.rawValue)
            }
            if hasLatitude {
               hashCode = (hashCode &* 31) &+ latitude.hashValue
            }
            if hasLongitude {
               hashCode = (hashCode &* 31) &+ longitude.hashValue
            }
            if hasEncounterLocation {
               hashCode = (hashCode &* 31) &+ encounterLocation.hashValue
            }
            if hasEncounterId {
               hashCode = (hashCode &* 31) &+ encounterId.hashValue
            }
            if hasDisappearTimestampMs {
               hashCode = (hashCode &* 31) &+ disappearTimestampMs.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetIncensePokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetIncensePokemonResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.GetIncensePokemonResponse = Pogoprotos.Networking.Responses.GetIncensePokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Result) -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .incenseEncounterUnknown
           return self
        }
        public var hasPokemonId:Bool{
            get {
                return builderResult.hasPokemonId
            }
        }
        public var pokemonId:Pogoprotos.Enums.PokemonId {
            get {
                return builderResult.pokemonId
            }
            set (value) {
                builderResult.hasPokemonId = true
                builderResult.pokemonId = value
            }
        }
      @discardableResult
        public func setPokemonId(_ value:Pogoprotos.Enums.PokemonId) -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
          self.pokemonId = value
          return self
        }
      @discardableResult
        public func clearPokemonId() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
           builderResult.hasPokemonId = false
           builderResult.pokemonId = .missingno
           return self
        }
      public var hasLatitude:Bool {
           get {
                return builderResult.hasLatitude
           }
      }
      public var latitude:Double {
           get {
                return builderResult.latitude
           }
           set (value) {
               builderResult.hasLatitude = true
               builderResult.latitude = value
           }
      }
      @discardableResult
      public func setLatitude(_ value:Double) -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        self.latitude = value
        return self
      }
      @discardableResult
      public func clearLatitude() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder{
           builderResult.hasLatitude = false
           builderResult.latitude = Double(0)
           return self
      }
      public var hasLongitude:Bool {
           get {
                return builderResult.hasLongitude
           }
      }
      public var longitude:Double {
           get {
                return builderResult.longitude
           }
           set (value) {
               builderResult.hasLongitude = true
               builderResult.longitude = value
           }
      }
      @discardableResult
      public func setLongitude(_ value:Double) -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        self.longitude = value
        return self
      }
      @discardableResult
      public func clearLongitude() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder{
           builderResult.hasLongitude = false
           builderResult.longitude = Double(0)
           return self
      }
      public var hasEncounterLocation:Bool {
           get {
                return builderResult.hasEncounterLocation
           }
      }
      public var encounterLocation:String {
           get {
                return builderResult.encounterLocation
           }
           set (value) {
               builderResult.hasEncounterLocation = true
               builderResult.encounterLocation = value
           }
      }
      @discardableResult
      public func setEncounterLocation(_ value:String) -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        self.encounterLocation = value
        return self
      }
      @discardableResult
      public func clearEncounterLocation() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder{
           builderResult.hasEncounterLocation = false
           builderResult.encounterLocation = ""
           return self
      }
      public var hasEncounterId:Bool {
           get {
                return builderResult.hasEncounterId
           }
      }
      public var encounterId:UInt64 {
           get {
                return builderResult.encounterId
           }
           set (value) {
               builderResult.hasEncounterId = true
               builderResult.encounterId = value
           }
      }
      @discardableResult
      public func setEncounterId(_ value:UInt64) -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        self.encounterId = value
        return self
      }
      @discardableResult
      public func clearEncounterId() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder{
           builderResult.hasEncounterId = false
           builderResult.encounterId = UInt64(0)
           return self
      }
      public var hasDisappearTimestampMs:Bool {
           get {
                return builderResult.hasDisappearTimestampMs
           }
      }
      public var disappearTimestampMs:Int64 {
           get {
                return builderResult.disappearTimestampMs
           }
           set (value) {
               builderResult.hasDisappearTimestampMs = true
               builderResult.disappearTimestampMs = value
           }
      }
      @discardableResult
      public func setDisappearTimestampMs(_ value:Int64) -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        self.disappearTimestampMs = value
        return self
      }
      @discardableResult
      public func clearDisappearTimestampMs() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder{
           builderResult.hasDisappearTimestampMs = false
           builderResult.disappearTimestampMs = Int64(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetIncensePokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetIncensePokemonResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetIncensePokemonResponse) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetIncensePokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasPokemonId {
             pokemonId = other.pokemonId
        }
        if other.hasLatitude {
             latitude = other.latitude
        }
        if other.hasLongitude {
             longitude = other.longitude
        }
        if other.hasEncounterLocation {
             encounterLocation = other.encounterLocation
        }
        if other.hasEncounterId {
             encounterId = other.encounterId
        }
        if other.hasDisappearTimestampMs {
             disappearTimestampMs = other.disappearTimestampMs
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 16:
            let valueIntpokemonId = try codedInputStream.readEnum()
            if let enumspokemonId = Pogoprotos.Enums.PokemonId(rawValue:valueIntpokemonId){
                 pokemonId = enumspokemonId
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntpokemonId))
            }

          case 25:
            latitude = try codedInputStream.readDouble()

          case 33:
            longitude = try codedInputStream.readDouble()

          case 42:
            encounterLocation = try codedInputStream.readString()

          case 49:
            encounterId = try codedInputStream.readFixed64()

          case 56:
            disappearTimestampMs = try codedInputStream.readInt64()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValuePokemonId = jsonMap["pokemonId"] as? String {
          resultDecodedBuilder.pokemonId = try Pogoprotos.Enums.PokemonId.fromString(str: jsonValuePokemonId)
        }
        if let jsonValueLatitude = jsonMap["latitude"] as? Double {
          resultDecodedBuilder.latitude = Double(jsonValueLatitude)
        }
        if let jsonValueLongitude = jsonMap["longitude"] as? Double {
          resultDecodedBuilder.longitude = Double(jsonValueLongitude)
        }
        if let jsonValueEncounterLocation = jsonMap["encounterLocation"] as? String {
          resultDecodedBuilder.encounterLocation = jsonValueEncounterLocation
        }
        if let jsonValueEncounterId = jsonMap["encounterId"] as? String {
          resultDecodedBuilder.encounterId = UInt64(jsonValueEncounterId)!
        }
        if let jsonValueDisappearTimestampMs = jsonMap["disappearTimestampMs"] as? String {
          resultDecodedBuilder.disappearTimestampMs = Int64(jsonValueDisappearTimestampMs)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class GetInventoryResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.GetInventoryResponse, rhs: Pogoprotos.Networking.Responses.GetInventoryResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
      fieldCheck = fieldCheck && (lhs.hasInventoryDelta == rhs.hasInventoryDelta) && (!lhs.hasInventoryDelta || lhs.inventoryDelta == rhs.inventoryDelta)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var success:Bool = false
    public fileprivate(set) var hasSuccess:Bool = false

    public fileprivate(set) var inventoryDelta:Pogoprotos.Inventory.InventoryDelta!
    public fileprivate(set) var hasInventoryDelta:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasSuccess {
        try codedOutputStream.writeBool(fieldNumber: 1, value:success)
      }
      if hasInventoryDelta {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:inventoryDelta)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(fieldNumber: 1)
      }
      if hasInventoryDelta {
          if let varSizeinventoryDelta = inventoryDelta?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeinventoryDelta
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
      return Pogoprotos.Networking.Responses.GetInventoryResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetInventoryResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetInventoryResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetInventoryResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetInventoryResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetInventoryResponse) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if hasInventoryDelta {
        jsonMap["inventoryDelta"] = try inventoryDelta.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      if hasInventoryDelta {
        output += "\(indent) inventoryDelta {\n"
        if let outDescInventoryDelta = inventoryDelta {
          output += try outDescInventoryDelta.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            if hasInventoryDelta {
                if let hashValueinventoryDelta = inventoryDelta?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueinventoryDelta
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetInventoryResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetInventoryResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.GetInventoryResponse = Pogoprotos.Networking.Responses.GetInventoryResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetInventoryResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      @discardableResult
      public func setSuccess(_ value:Bool) -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        self.success = value
        return self
      }
      @discardableResult
      public func clearSuccess() -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var hasInventoryDelta:Bool {
           get {
               return builderResult.hasInventoryDelta
           }
      }
      public var inventoryDelta:Pogoprotos.Inventory.InventoryDelta! {
           get {
               if inventoryDeltaBuilder_ != nil {
                  builderResult.inventoryDelta = inventoryDeltaBuilder_.getMessage()
               }
               return builderResult.inventoryDelta
           }
           set (value) {
               builderResult.hasInventoryDelta = true
               builderResult.inventoryDelta = value
           }
      }
      fileprivate var inventoryDeltaBuilder_:Pogoprotos.Inventory.InventoryDelta.Builder! {
           didSet {
              builderResult.hasInventoryDelta = true
           }
      }
      public func getInventoryDeltaBuilder() -> Pogoprotos.Inventory.InventoryDelta.Builder {
        if inventoryDeltaBuilder_ == nil {
           inventoryDeltaBuilder_ = Pogoprotos.Inventory.InventoryDelta.Builder()
           builderResult.inventoryDelta = inventoryDeltaBuilder_.getMessage()
           if inventoryDelta != nil {
              try! inventoryDeltaBuilder_.mergeFrom(other: inventoryDelta)
           }
        }
        return inventoryDeltaBuilder_
      }
      @discardableResult
      public func setInventoryDelta(_ value:Pogoprotos.Inventory.InventoryDelta!) -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        self.inventoryDelta = value
        return self
      }
      @discardableResult
      public func mergeInventoryDelta(value:Pogoprotos.Inventory.InventoryDelta) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        if builderResult.hasInventoryDelta {
          builderResult.inventoryDelta = try Pogoprotos.Inventory.InventoryDelta.builderWithPrototype(prototype:builderResult.inventoryDelta).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.inventoryDelta = value
        }
        builderResult.hasInventoryDelta = true
        return self
      }
      @discardableResult
      public func clearInventoryDelta() -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        inventoryDeltaBuilder_ = nil
        builderResult.hasInventoryDelta = false
        builderResult.inventoryDelta = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetInventoryResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetInventoryResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetInventoryResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetInventoryResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetInventoryResponse) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetInventoryResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if (other.hasInventoryDelta) {
            try mergeInventoryDelta(value: other.inventoryDelta)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try codedInputStream.readBool()

          case 18:
            let subBuilder:Pogoprotos.Inventory.InventoryDelta.Builder = Pogoprotos.Inventory.InventoryDelta.Builder()
            if hasInventoryDelta {
              try subBuilder.mergeFrom(other: inventoryDelta)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            inventoryDelta = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetInventoryResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValueInventoryDelta = jsonMap["inventoryDelta"] as? Dictionary<String,Any> {
          resultDecodedBuilder.inventoryDelta = try Pogoprotos.Inventory.InventoryDelta.Builder.decodeToBuilder(jsonMap:jsonValueInventoryDelta).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class GetMapObjectsResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.GetMapObjectsResponse, rhs: Pogoprotos.Networking.Responses.GetMapObjectsResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.mapCells == rhs.mapCells)
      fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var mapCells:Array<Pogoprotos.Map.MapCell>  = Array<Pogoprotos.Map.MapCell>()
    public fileprivate(set) var status:Pogoprotos.Map.MapObjectsStatus = Pogoprotos.Map.MapObjectsStatus.unsetStatus
    public fileprivate(set) var hasStatus:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      for oneElementMapCells in mapCells {
          try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementMapCells)
      }
      if hasStatus {
        try codedOutputStream.writeEnum(fieldNumber: 2, value:status.rawValue)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementMapCells in mapCells {
          serialize_size += oneElementMapCells.computeMessageSize(fieldNumber: 1)
      }
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(fieldNumber: 2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
      return Pogoprotos.Networking.Responses.GetMapObjectsResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetMapObjectsResponse) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if !mapCells.isEmpty {
        var jsonArrayMapCells:Array<Dictionary<String,Any>> = []
          for oneValueMapCells in mapCells {
            let ecodedMessageMapCells = try oneValueMapCells.encode()
            jsonArrayMapCells.append(ecodedMessageMapCells)
          }
        jsonMap["mapCells"] = jsonArrayMapCells
      }
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var mapCellsElementIndex:Int = 0
      for oneElementMapCells in mapCells {
          output += "\(indent) mapCells[\(mapCellsElementIndex)] {\n"
          output += try oneElementMapCells.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          mapCellsElementIndex += 1
      }
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementMapCells in mapCells {
                hashCode = (hashCode &* 31) &+ oneElementMapCells.hashValue
            }
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetMapObjectsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetMapObjectsResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.GetMapObjectsResponse = Pogoprotos.Networking.Responses.GetMapObjectsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var mapCells:Array<Pogoprotos.Map.MapCell> {
           get {
               return builderResult.mapCells
           }
           set (value) {
               builderResult.mapCells = value
           }
      }
      @discardableResult
      public func setMapCells(_ value:Array<Pogoprotos.Map.MapCell>) -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        self.mapCells = value
        return self
      }
      @discardableResult
      public func clearMapCells() -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        builderResult.mapCells.removeAll(keepingCapacity: false)
        return self
      }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Map.MapObjectsStatus {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
      @discardableResult
        public func setStatus(_ value:Pogoprotos.Map.MapObjectsStatus) -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
          self.status = value
          return self
        }
      @discardableResult
        public func clearStatus() -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .unsetStatus
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetMapObjectsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetMapObjectsResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetMapObjectsResponse) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetMapObjectsResponse() {
         return self
        }
        if !other.mapCells.isEmpty  {
           builderResult.mapCells += other.mapCells
        }
        if other.hasStatus {
             status = other.status
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = Pogoprotos.Map.MapCell.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            mapCells.append(subBuilder.buildPartial())

          case 16:
            let valueIntstatus = try codedInputStream.readEnum()
            if let enumsstatus = Pogoprotos.Map.MapObjectsStatus(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntstatus))
            }

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder()
        if let jsonValueMapCells = jsonMap["mapCells"] as? Array<Dictionary<String,Any>> {
          var jsonArrayMapCells:Array<Pogoprotos.Map.MapCell> = []
          for oneValueMapCells in jsonValueMapCells {
            let messageFromStringMapCells = try Pogoprotos.Map.MapCell.Builder.decodeToBuilder(jsonMap:oneValueMapCells).build()

            jsonArrayMapCells.append(messageFromStringMapCells)
          }
          resultDecodedBuilder.mapCells = jsonArrayMapCells
        }
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Map.MapObjectsStatus.fromString(str: jsonValueStatus)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class GetPlayerProfileResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.GetPlayerProfileResponse, rhs: Pogoprotos.Networking.Responses.GetPlayerProfileResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasStartTime == rhs.hasStartTime) && (!lhs.hasStartTime || lhs.startTime == rhs.startTime)
      fieldCheck = fieldCheck && (lhs.badges == rhs.badges)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Result = Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var startTime:Int64 = Int64(0)
    public fileprivate(set) var hasStartTime:Bool = false

    public fileprivate(set) var badges:Array<Pogoprotos.Data.PlayerBadge>  = Array<Pogoprotos.Data.PlayerBadge>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasStartTime {
        try codedOutputStream.writeInt64(fieldNumber: 2, value:startTime)
      }
      for oneElementBadges in badges {
          try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementBadges)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasStartTime {
        serialize_size += startTime.computeInt64Size(fieldNumber: 2)
      }
      for oneElementBadges in badges {
          serialize_size += oneElementBadges.computeMessageSize(fieldNumber: 3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
      return Pogoprotos.Networking.Responses.GetPlayerProfileResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetPlayerProfileResponse) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasStartTime {
        jsonMap["startTime"] = "\(startTime)"
      }
      if !badges.isEmpty {
        var jsonArrayBadges:Array<Dictionary<String,Any>> = []
          for oneValueBadges in badges {
            let ecodedMessageBadges = try oneValueBadges.encode()
            jsonArrayBadges.append(ecodedMessageBadges)
          }
        jsonMap["badges"] = jsonArrayBadges
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasStartTime {
        output += "\(indent) startTime: \(startTime) \n"
      }
      var badgesElementIndex:Int = 0
      for oneElementBadges in badges {
          output += "\(indent) badges[\(badgesElementIndex)] {\n"
          output += try oneElementBadges.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          badgesElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasStartTime {
               hashCode = (hashCode &* 31) &+ startTime.hashValue
            }
            for oneElementBadges in badges {
                hashCode = (hashCode &* 31) &+ oneElementBadges.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetPlayerProfileResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetPlayerProfileResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.GetPlayerProfileResponse = Pogoprotos.Networking.Responses.GetPlayerProfileResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Result) -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasStartTime:Bool {
           get {
                return builderResult.hasStartTime
           }
      }
      public var startTime:Int64 {
           get {
                return builderResult.startTime
           }
           set (value) {
               builderResult.hasStartTime = true
               builderResult.startTime = value
           }
      }
      @discardableResult
      public func setStartTime(_ value:Int64) -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        self.startTime = value
        return self
      }
      @discardableResult
      public func clearStartTime() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder{
           builderResult.hasStartTime = false
           builderResult.startTime = Int64(0)
           return self
      }
      public var badges:Array<Pogoprotos.Data.PlayerBadge> {
           get {
               return builderResult.badges
           }
           set (value) {
               builderResult.badges = value
           }
      }
      @discardableResult
      public func setBadges(_ value:Array<Pogoprotos.Data.PlayerBadge>) -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        self.badges = value
        return self
      }
      @discardableResult
      public func clearBadges() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        builderResult.badges.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetPlayerProfileResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetPlayerProfileResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetPlayerProfileResponse) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetPlayerProfileResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasStartTime {
             startTime = other.startTime
        }
        if !other.badges.isEmpty  {
           builderResult.badges += other.badges
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 16:
            startTime = try codedInputStream.readInt64()

          case 26:
            let subBuilder = Pogoprotos.Data.PlayerBadge.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            badges.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueStartTime = jsonMap["startTime"] as? String {
          resultDecodedBuilder.startTime = Int64(jsonValueStartTime)!
        }
        if let jsonValueBadges = jsonMap["badges"] as? Array<Dictionary<String,Any>> {
          var jsonArrayBadges:Array<Pogoprotos.Data.PlayerBadge> = []
          for oneValueBadges in jsonValueBadges {
            let messageFromStringBadges = try Pogoprotos.Data.PlayerBadge.Builder.decodeToBuilder(jsonMap:oneValueBadges).build()

            jsonArrayBadges.append(messageFromStringBadges)
          }
          resultDecodedBuilder.badges = jsonArrayBadges
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class GetPlayerResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.GetPlayerResponse, rhs: Pogoprotos.Networking.Responses.GetPlayerResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
      fieldCheck = fieldCheck && (lhs.hasPlayerData == rhs.hasPlayerData) && (!lhs.hasPlayerData || lhs.playerData == rhs.playerData)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var success:Bool = false
    public fileprivate(set) var hasSuccess:Bool = false

    public fileprivate(set) var playerData:Pogoprotos.Data.PlayerData!
    public fileprivate(set) var hasPlayerData:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasSuccess {
        try codedOutputStream.writeBool(fieldNumber: 1, value:success)
      }
      if hasPlayerData {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:playerData)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(fieldNumber: 1)
      }
      if hasPlayerData {
          if let varSizeplayerData = playerData?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeplayerData
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
      return Pogoprotos.Networking.Responses.GetPlayerResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetPlayerResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetPlayerResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetPlayerResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetPlayerResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetPlayerResponse) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if hasPlayerData {
        jsonMap["playerData"] = try playerData.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      if hasPlayerData {
        output += "\(indent) playerData {\n"
        if let outDescPlayerData = playerData {
          output += try outDescPlayerData.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            if hasPlayerData {
                if let hashValueplayerData = playerData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueplayerData
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetPlayerResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetPlayerResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.GetPlayerResponse = Pogoprotos.Networking.Responses.GetPlayerResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetPlayerResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      @discardableResult
      public func setSuccess(_ value:Bool) -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        self.success = value
        return self
      }
      @discardableResult
      public func clearSuccess() -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var hasPlayerData:Bool {
           get {
               return builderResult.hasPlayerData
           }
      }
      public var playerData:Pogoprotos.Data.PlayerData! {
           get {
               if playerDataBuilder_ != nil {
                  builderResult.playerData = playerDataBuilder_.getMessage()
               }
               return builderResult.playerData
           }
           set (value) {
               builderResult.hasPlayerData = true
               builderResult.playerData = value
           }
      }
      fileprivate var playerDataBuilder_:Pogoprotos.Data.PlayerData.Builder! {
           didSet {
              builderResult.hasPlayerData = true
           }
      }
      public func getPlayerDataBuilder() -> Pogoprotos.Data.PlayerData.Builder {
        if playerDataBuilder_ == nil {
           playerDataBuilder_ = Pogoprotos.Data.PlayerData.Builder()
           builderResult.playerData = playerDataBuilder_.getMessage()
           if playerData != nil {
              try! playerDataBuilder_.mergeFrom(other: playerData)
           }
        }
        return playerDataBuilder_
      }
      @discardableResult
      public func setPlayerData(_ value:Pogoprotos.Data.PlayerData!) -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        self.playerData = value
        return self
      }
      @discardableResult
      public func mergePlayerData(value:Pogoprotos.Data.PlayerData) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        if builderResult.hasPlayerData {
          builderResult.playerData = try Pogoprotos.Data.PlayerData.builderWithPrototype(prototype:builderResult.playerData).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.playerData = value
        }
        builderResult.hasPlayerData = true
        return self
      }
      @discardableResult
      public func clearPlayerData() -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        playerDataBuilder_ = nil
        builderResult.hasPlayerData = false
        builderResult.playerData = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetPlayerResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetPlayerResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetPlayerResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetPlayerResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetPlayerResponse) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetPlayerResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if (other.hasPlayerData) {
            try mergePlayerData(value: other.playerData)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try codedInputStream.readBool()

          case 18:
            let subBuilder:Pogoprotos.Data.PlayerData.Builder = Pogoprotos.Data.PlayerData.Builder()
            if hasPlayerData {
              try subBuilder.mergeFrom(other: playerData)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            playerData = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetPlayerResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValuePlayerData = jsonMap["playerData"] as? Dictionary<String,Any> {
          resultDecodedBuilder.playerData = try Pogoprotos.Data.PlayerData.Builder.decodeToBuilder(jsonMap:jsonValuePlayerData).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class GetSuggestedCodenamesResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse, rhs: Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.codenames == rhs.codenames)
      fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var codenames:Array<String> = Array<String>()
    public fileprivate(set) var success:Bool = false
    public fileprivate(set) var hasSuccess:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if !codenames.isEmpty {
        for oneValuecodenames in codenames {
          try codedOutputStream.writeString(fieldNumber: 1, value:oneValuecodenames)
        }
      }
      if hasSuccess {
        try codedOutputStream.writeBool(fieldNumber: 2, value:success)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      var dataSizeCodenames:Int32 = 0
      for oneValuecodenames in codenames {
          dataSizeCodenames += oneValuecodenames.computeStringSizeNoTag()
      }
      serialize_size += dataSizeCodenames
      serialize_size += 1 * Int32(codenames.count)
      if hasSuccess {
        serialize_size += success.computeBoolSize(fieldNumber: 2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
      return Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if !codenames.isEmpty {
        var jsonArrayCodenames:Array<String> = []
          for oneValueCodenames in codenames {
            jsonArrayCodenames.append(oneValueCodenames)
          }
        jsonMap["codenames"] = jsonArrayCodenames
      }
      if hasSuccess {
        jsonMap["success"] = success
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var codenamesElementIndex:Int = 0
      for oneValueCodenames in codenames  {
          output += "\(indent) codenames[\(codenamesElementIndex)]: \(oneValueCodenames)\n"
          codenamesElementIndex += 1
      }
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneValueCodenames in codenames {
                hashCode = (hashCode &* 31) &+ oneValueCodenames.hashValue
            }
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse = Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var codenames:Array<String> {
           get {
               return builderResult.codenames
           }
           set (array) {
               builderResult.codenames = array
           }
      }
      @discardableResult
      public func setCodenames(_ value:Array<String>) -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        self.codenames = value
        return self
      }
      @discardableResult
      public func clearCodenames() -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
         builderResult.codenames.removeAll(keepingCapacity: false)
         return self
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      @discardableResult
      public func setSuccess(_ value:Bool) -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        self.success = value
        return self
      }
      @discardableResult
      public func clearSuccess() -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse() {
         return self
        }
        if !other.codenames.isEmpty {
            builderResult.codenames += other.codenames
        }
        if other.hasSuccess {
             success = other.success
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            codenames += [try codedInputStream.readString()]

          case 16:
            success = try codedInputStream.readBool()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder()
        if let jsonValueCodenames = jsonMap["codenames"] as? Array<String> {
          var jsonArrayCodenames:Array<String> = []
          for oneValueCodenames in jsonValueCodenames {
            jsonArrayCodenames.append(oneValueCodenames)
          }
          resultDecodedBuilder.codenames = jsonArrayCodenames
        }
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class IncenseEncounterResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.IncenseEncounterResponse, rhs: Pogoprotos.Networking.Responses.IncenseEncounterResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasPokemonData == rhs.hasPokemonData) && (!lhs.hasPokemonData || lhs.pokemonData == rhs.pokemonData)
      fieldCheck = fieldCheck && (lhs.hasCaptureProbability == rhs.hasCaptureProbability) && (!lhs.hasCaptureProbability || lhs.captureProbability == rhs.captureProbability)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case incenseEncounterUnknown = 0
        case incenseEncounterSuccess = 1
        case incenseEncounterNotAvailable = 2
        case pokemonInventoryFull = 3
        public func toString() -> String {
          switch self {
          case .incenseEncounterUnknown: return "INCENSE_ENCOUNTER_UNKNOWN"
          case .incenseEncounterSuccess: return "INCENSE_ENCOUNTER_SUCCESS"
          case .incenseEncounterNotAvailable: return "INCENSE_ENCOUNTER_NOT_AVAILABLE"
          case .pokemonInventoryFull: return "POKEMON_INVENTORY_FULL"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Result {
          switch str {
          case "INCENSE_ENCOUNTER_UNKNOWN":  return .incenseEncounterUnknown
          case "INCENSE_ENCOUNTER_SUCCESS":  return .incenseEncounterSuccess
          case "INCENSE_ENCOUNTER_NOT_AVAILABLE":  return .incenseEncounterNotAvailable
          case "POKEMON_INVENTORY_FULL":  return .pokemonInventoryFull
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .incenseEncounterUnknown: return ".incenseEncounterUnknown"
          case .incenseEncounterSuccess: return ".incenseEncounterSuccess"
          case .incenseEncounterNotAvailable: return ".incenseEncounterNotAvailable"
          case .pokemonInventoryFull: return ".pokemonInventoryFull"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.IncenseEncounterResponse.Result = Pogoprotos.Networking.Responses.IncenseEncounterResponse.Result.incenseEncounterUnknown
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var pokemonData:Pogoprotos.Data.PokemonData!
    public fileprivate(set) var hasPokemonData:Bool = false
    public fileprivate(set) var captureProbability:Pogoprotos.Data.Capture.CaptureProbability!
    public fileprivate(set) var hasCaptureProbability:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasPokemonData {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:pokemonData)
      }
      if hasCaptureProbability {
        try codedOutputStream.writeMessage(fieldNumber: 3, value:captureProbability)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasPokemonData {
          if let varSizepokemonData = pokemonData?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizepokemonData
          }
      }
      if hasCaptureProbability {
          if let varSizecaptureProbability = captureProbability?.computeMessageSize(fieldNumber: 3) {
              serialize_size += varSizecaptureProbability
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
      return Pogoprotos.Networking.Responses.IncenseEncounterResponse.classBuilder() as! Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.IncenseEncounterResponse) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasPokemonData {
        jsonMap["pokemonData"] = try pokemonData.encode()
      }
      if hasCaptureProbability {
        jsonMap["captureProbability"] = try captureProbability.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasPokemonData {
        output += "\(indent) pokemonData {\n"
        if let outDescPokemonData = pokemonData {
          output += try outDescPokemonData.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasCaptureProbability {
        output += "\(indent) captureProbability {\n"
        if let outDescCaptureProbability = captureProbability {
          output += try outDescCaptureProbability.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasPokemonData {
                if let hashValuepokemonData = pokemonData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepokemonData
                }
            }
            if hasCaptureProbability {
                if let hashValuecaptureProbability = captureProbability?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecaptureProbability
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.IncenseEncounterResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.IncenseEncounterResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.IncenseEncounterResponse = Pogoprotos.Networking.Responses.IncenseEncounterResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.IncenseEncounterResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.IncenseEncounterResponse.Result) -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .incenseEncounterUnknown
           return self
        }
      public var hasPokemonData:Bool {
           get {
               return builderResult.hasPokemonData
           }
      }
      public var pokemonData:Pogoprotos.Data.PokemonData! {
           get {
               if pokemonDataBuilder_ != nil {
                  builderResult.pokemonData = pokemonDataBuilder_.getMessage()
               }
               return builderResult.pokemonData
           }
           set (value) {
               builderResult.hasPokemonData = true
               builderResult.pokemonData = value
           }
      }
      fileprivate var pokemonDataBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasPokemonData = true
           }
      }
      public func getPokemonDataBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if pokemonDataBuilder_ == nil {
           pokemonDataBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.pokemonData = pokemonDataBuilder_.getMessage()
           if pokemonData != nil {
              try! pokemonDataBuilder_.mergeFrom(other: pokemonData)
           }
        }
        return pokemonDataBuilder_
      }
      @discardableResult
      public func setPokemonData(_ value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        self.pokemonData = value
        return self
      }
      @discardableResult
      public func mergePokemonData(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        if builderResult.hasPokemonData {
          builderResult.pokemonData = try Pogoprotos.Data.PokemonData.builderWithPrototype(prototype:builderResult.pokemonData).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.pokemonData = value
        }
        builderResult.hasPokemonData = true
        return self
      }
      @discardableResult
      public func clearPokemonData() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        pokemonDataBuilder_ = nil
        builderResult.hasPokemonData = false
        builderResult.pokemonData = nil
        return self
      }
      public var hasCaptureProbability:Bool {
           get {
               return builderResult.hasCaptureProbability
           }
      }
      public var captureProbability:Pogoprotos.Data.Capture.CaptureProbability! {
           get {
               if captureProbabilityBuilder_ != nil {
                  builderResult.captureProbability = captureProbabilityBuilder_.getMessage()
               }
               return builderResult.captureProbability
           }
           set (value) {
               builderResult.hasCaptureProbability = true
               builderResult.captureProbability = value
           }
      }
      fileprivate var captureProbabilityBuilder_:Pogoprotos.Data.Capture.CaptureProbability.Builder! {
           didSet {
              builderResult.hasCaptureProbability = true
           }
      }
      public func getCaptureProbabilityBuilder() -> Pogoprotos.Data.Capture.CaptureProbability.Builder {
        if captureProbabilityBuilder_ == nil {
           captureProbabilityBuilder_ = Pogoprotos.Data.Capture.CaptureProbability.Builder()
           builderResult.captureProbability = captureProbabilityBuilder_.getMessage()
           if captureProbability != nil {
              try! captureProbabilityBuilder_.mergeFrom(other: captureProbability)
           }
        }
        return captureProbabilityBuilder_
      }
      @discardableResult
      public func setCaptureProbability(_ value:Pogoprotos.Data.Capture.CaptureProbability!) -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        self.captureProbability = value
        return self
      }
      @discardableResult
      public func mergeCaptureProbability(value:Pogoprotos.Data.Capture.CaptureProbability) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        if builderResult.hasCaptureProbability {
          builderResult.captureProbability = try Pogoprotos.Data.Capture.CaptureProbability.builderWithPrototype(prototype:builderResult.captureProbability).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.captureProbability = value
        }
        builderResult.hasCaptureProbability = true
        return self
      }
      @discardableResult
      public func clearCaptureProbability() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        captureProbabilityBuilder_ = nil
        builderResult.hasCaptureProbability = false
        builderResult.captureProbability = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.IncenseEncounterResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
        let returnMe:Pogoprotos.Networking.Responses.IncenseEncounterResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.IncenseEncounterResponse) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        if other == Pogoprotos.Networking.Responses.IncenseEncounterResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasPokemonData) {
            try mergePokemonData(value: other.pokemonData)
        }
        if (other.hasCaptureProbability) {
            try mergeCaptureProbability(value: other.captureProbability)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.IncenseEncounterResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasPokemonData {
              try subBuilder.mergeFrom(other: pokemonData)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            pokemonData = subBuilder.buildPartial()

          case 26:
            let subBuilder:Pogoprotos.Data.Capture.CaptureProbability.Builder = Pogoprotos.Data.Capture.CaptureProbability.Builder()
            if hasCaptureProbability {
              try subBuilder.mergeFrom(other: captureProbability)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            captureProbability = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValuePokemonData = jsonMap["pokemonData"] as? Dictionary<String,Any> {
          resultDecodedBuilder.pokemonData = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonMap:jsonValuePokemonData).build()

        }
        if let jsonValueCaptureProbability = jsonMap["captureProbability"] as? Dictionary<String,Any> {
          resultDecodedBuilder.captureProbability = try Pogoprotos.Data.Capture.CaptureProbability.Builder.decodeToBuilder(jsonMap:jsonValueCaptureProbability).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class LevelUpRewardsResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.LevelUpRewardsResponse, rhs: Pogoprotos.Networking.Responses.LevelUpRewardsResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.itemsAwarded == rhs.itemsAwarded)
      fieldCheck = fieldCheck && (lhs.itemsUnlocked == rhs.itemsUnlocked)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case awardedAlready = 2
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .awardedAlready: return "AWARDED_ALREADY"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "AWARDED_ALREADY":  return .awardedAlready
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .awardedAlready: return ".awardedAlready"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Result = Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var itemsAwarded:Array<Pogoprotos.Inventory.Item.ItemAward>  = Array<Pogoprotos.Inventory.Item.ItemAward>()
    private var itemsUnlockedMemoizedSerializedSize:Int32 = 0
    public fileprivate(set) var itemsUnlocked:Array<Pogoprotos.Inventory.Item.ItemId> = Array<Pogoprotos.Inventory.Item.ItemId>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      for oneElementItemsAwarded in itemsAwarded {
          try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementItemsAwarded)
      }
      if !itemsUnlocked.isEmpty {
        try codedOutputStream.writeRawVarint32(value: 34)
        try codedOutputStream.writeRawVarint32(value: itemsUnlockedMemoizedSerializedSize)
      }
      for oneValueOfitemsUnlocked in itemsUnlocked {
          try codedOutputStream.writeEnumNoTag(value: oneValueOfitemsUnlocked.rawValue)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      for oneElementItemsAwarded in itemsAwarded {
          serialize_size += oneElementItemsAwarded.computeMessageSize(fieldNumber: 2)
      }
      var dataSizeitemsUnlocked:Int32 = 0
      for oneValueOfitemsUnlocked in itemsUnlocked {
          dataSizeitemsUnlocked += oneValueOfitemsUnlocked.rawValue.computeEnumSizeNoTag()
      }
      serialize_size += dataSizeitemsUnlocked
      if !itemsUnlocked.isEmpty {
        serialize_size += 1
        serialize_size += dataSizeitemsUnlocked.computeRawVarint32Size()
      }
      itemsUnlockedMemoizedSerializedSize = dataSizeitemsUnlocked
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
      return Pogoprotos.Networking.Responses.LevelUpRewardsResponse.classBuilder() as! Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.LevelUpRewardsResponse) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if !itemsAwarded.isEmpty {
        var jsonArrayItemsAwarded:Array<Dictionary<String,Any>> = []
          for oneValueItemsAwarded in itemsAwarded {
            let ecodedMessageItemsAwarded = try oneValueItemsAwarded.encode()
            jsonArrayItemsAwarded.append(ecodedMessageItemsAwarded)
          }
        jsonMap["itemsAwarded"] = jsonArrayItemsAwarded
      }
      if !itemsUnlocked.isEmpty {
        var jsonArrayItemsUnlocked:Array<String> = []
          for oneValueItemsUnlocked in itemsUnlocked {
            jsonArrayItemsUnlocked.append(oneValueItemsUnlocked.toString())
          }
        jsonMap["itemsUnlocked"] = jsonArrayItemsUnlocked
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      var itemsAwardedElementIndex:Int = 0
      for oneElementItemsAwarded in itemsAwarded {
          output += "\(indent) itemsAwarded[\(itemsAwardedElementIndex)] {\n"
          output += try oneElementItemsAwarded.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          itemsAwardedElementIndex += 1
      }
      var itemsUnlockedElementIndex:Int = 0
      for oneValueOfitemsUnlocked in itemsUnlocked {
          output += "\(indent) itemsUnlocked[\(itemsUnlockedElementIndex)]: \(oneValueOfitemsUnlocked.description)\n"
          itemsUnlockedElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            for oneElementItemsAwarded in itemsAwarded {
                hashCode = (hashCode &* 31) &+ oneElementItemsAwarded.hashValue
            }
            for oneValueOfitemsUnlocked in itemsUnlocked {
                hashCode = (hashCode &* 31) &+ Int(oneValueOfitemsUnlocked.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.LevelUpRewardsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.LevelUpRewardsResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.LevelUpRewardsResponse = Pogoprotos.Networking.Responses.LevelUpRewardsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Result) -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var itemsAwarded:Array<Pogoprotos.Inventory.Item.ItemAward> {
           get {
               return builderResult.itemsAwarded
           }
           set (value) {
               builderResult.itemsAwarded = value
           }
      }
      @discardableResult
      public func setItemsAwarded(_ value:Array<Pogoprotos.Inventory.Item.ItemAward>) -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        self.itemsAwarded = value
        return self
      }
      @discardableResult
      public func clearItemsAwarded() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        builderResult.itemsAwarded.removeAll(keepingCapacity: false)
        return self
      }
      public var itemsUnlocked:Array<Pogoprotos.Inventory.Item.ItemId> {
          get {
              return builderResult.itemsUnlocked
          }
          set (value) {
              builderResult.itemsUnlocked = value
          }
      }
      @discardableResult
      public func setItemsUnlocked(_ value:Array<Pogoprotos.Inventory.Item.ItemId>) -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        self.itemsUnlocked = value
        return self
      }
      @discardableResult
      public func clearItemsUnlocked() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        builderResult.itemsUnlocked.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.LevelUpRewardsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
        let returnMe:Pogoprotos.Networking.Responses.LevelUpRewardsResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.LevelUpRewardsResponse) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.LevelUpRewardsResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if !other.itemsAwarded.isEmpty  {
           builderResult.itemsAwarded += other.itemsAwarded
        }
        if !other.itemsUnlocked.isEmpty {
           builderResult.itemsUnlocked += other.itemsUnlocked
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder = Pogoprotos.Inventory.Item.ItemAward.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            itemsAwarded.append(subBuilder.buildPartial())

          case 34:
            let length = Int(try codedInputStream.readRawVarint32())
            let oldLimit = try codedInputStream.pushLimit(byteLimit: length)
            while codedInputStream.bytesUntilLimit() > 0 {
            let valueIntitemsUnlocked = try codedInputStream.readEnum()
            if let enumsitemsUnlocked = Pogoprotos.Inventory.Item.ItemId(rawValue:valueIntitemsUnlocked) {
                 builderResult.itemsUnlocked.append(enumsitemsUnlocked)
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 4, value:Int64(valueIntitemsUnlocked))
            }
            }
            codedInputStream.popLimit(oldLimit: oldLimit)

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueItemsAwarded = jsonMap["itemsAwarded"] as? Array<Dictionary<String,Any>> {
          var jsonArrayItemsAwarded:Array<Pogoprotos.Inventory.Item.ItemAward> = []
          for oneValueItemsAwarded in jsonValueItemsAwarded {
            let messageFromStringItemsAwarded = try Pogoprotos.Inventory.Item.ItemAward.Builder.decodeToBuilder(jsonMap:oneValueItemsAwarded).build()

            jsonArrayItemsAwarded.append(messageFromStringItemsAwarded)
          }
          resultDecodedBuilder.itemsAwarded = jsonArrayItemsAwarded
        }
        if let jsonValueItemsUnlocked = jsonMap["itemsUnlocked"] as? Array<String> {
          var jsonArrayItemsUnlocked:Array<Pogoprotos.Inventory.Item.ItemId> = []
          for oneValueItemsUnlocked in jsonValueItemsUnlocked {
            let enumFromStringItemsUnlocked = try Pogoprotos.Inventory.Item.ItemId.fromString(str: oneValueItemsUnlocked)
            jsonArrayItemsUnlocked.append(enumFromStringItemsUnlocked)
          }
          resultDecodedBuilder.itemsUnlocked = jsonArrayItemsUnlocked
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class MarkTutorialCompleteResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse, rhs: Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
      fieldCheck = fieldCheck && (lhs.hasPlayerData == rhs.hasPlayerData) && (!lhs.hasPlayerData || lhs.playerData == rhs.playerData)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var success:Bool = false
    public fileprivate(set) var hasSuccess:Bool = false

    public fileprivate(set) var playerData:Pogoprotos.Data.PlayerData!
    public fileprivate(set) var hasPlayerData:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasSuccess {
        try codedOutputStream.writeBool(fieldNumber: 1, value:success)
      }
      if hasPlayerData {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:playerData)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(fieldNumber: 1)
      }
      if hasPlayerData {
          if let varSizeplayerData = playerData?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeplayerData
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
      return Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.classBuilder() as! Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if hasPlayerData {
        jsonMap["playerData"] = try playerData.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      if hasPlayerData {
        output += "\(indent) playerData {\n"
        if let outDescPlayerData = playerData {
          output += try outDescPlayerData.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            if hasPlayerData {
                if let hashValueplayerData = playerData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueplayerData
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse = Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      @discardableResult
      public func setSuccess(_ value:Bool) -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        self.success = value
        return self
      }
      @discardableResult
      public func clearSuccess() -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var hasPlayerData:Bool {
           get {
               return builderResult.hasPlayerData
           }
      }
      public var playerData:Pogoprotos.Data.PlayerData! {
           get {
               if playerDataBuilder_ != nil {
                  builderResult.playerData = playerDataBuilder_.getMessage()
               }
               return builderResult.playerData
           }
           set (value) {
               builderResult.hasPlayerData = true
               builderResult.playerData = value
           }
      }
      fileprivate var playerDataBuilder_:Pogoprotos.Data.PlayerData.Builder! {
           didSet {
              builderResult.hasPlayerData = true
           }
      }
      public func getPlayerDataBuilder() -> Pogoprotos.Data.PlayerData.Builder {
        if playerDataBuilder_ == nil {
           playerDataBuilder_ = Pogoprotos.Data.PlayerData.Builder()
           builderResult.playerData = playerDataBuilder_.getMessage()
           if playerData != nil {
              try! playerDataBuilder_.mergeFrom(other: playerData)
           }
        }
        return playerDataBuilder_
      }
      @discardableResult
      public func setPlayerData(_ value:Pogoprotos.Data.PlayerData!) -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        self.playerData = value
        return self
      }
      @discardableResult
      public func mergePlayerData(value:Pogoprotos.Data.PlayerData) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        if builderResult.hasPlayerData {
          builderResult.playerData = try Pogoprotos.Data.PlayerData.builderWithPrototype(prototype:builderResult.playerData).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.playerData = value
        }
        builderResult.hasPlayerData = true
        return self
      }
      @discardableResult
      public func clearPlayerData() -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        playerDataBuilder_ = nil
        builderResult.hasPlayerData = false
        builderResult.playerData = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
        let returnMe:Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        if other == Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if (other.hasPlayerData) {
            try mergePlayerData(value: other.playerData)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try codedInputStream.readBool()

          case 18:
            let subBuilder:Pogoprotos.Data.PlayerData.Builder = Pogoprotos.Data.PlayerData.Builder()
            if hasPlayerData {
              try subBuilder.mergeFrom(other: playerData)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            playerData = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValuePlayerData = jsonMap["playerData"] as? Dictionary<String,Any> {
          resultDecodedBuilder.playerData = try Pogoprotos.Data.PlayerData.Builder.decodeToBuilder(jsonMap:jsonValuePlayerData).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class NicknamePokemonResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.NicknamePokemonResponse, rhs: Pogoprotos.Networking.Responses.NicknamePokemonResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case errorInvalidNickname = 2
        case errorPokemonNotFound = 3
        case errorPokemonIsEgg = 4
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .errorInvalidNickname: return "ERROR_INVALID_NICKNAME"
          case .errorPokemonNotFound: return "ERROR_POKEMON_NOT_FOUND"
          case .errorPokemonIsEgg: return "ERROR_POKEMON_IS_EGG"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "ERROR_INVALID_NICKNAME":  return .errorInvalidNickname
          case "ERROR_POKEMON_NOT_FOUND":  return .errorPokemonNotFound
          case "ERROR_POKEMON_IS_EGG":  return .errorPokemonIsEgg
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .errorInvalidNickname: return ".errorInvalidNickname"
          case .errorPokemonNotFound: return ".errorPokemonNotFound"
          case .errorPokemonIsEgg: return ".errorPokemonIsEgg"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.NicknamePokemonResponse.Result = Pogoprotos.Networking.Responses.NicknamePokemonResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.NicknamePokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.NicknamePokemonResponse) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.NicknamePokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.NicknamePokemonResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.NicknamePokemonResponse = Pogoprotos.Networking.Responses.NicknamePokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.NicknamePokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.NicknamePokemonResponse.Result) -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.NicknamePokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.NicknamePokemonResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.NicknamePokemonResponse) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.NicknamePokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.NicknamePokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Result.fromString(str: jsonValueResult)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class PlayerUpdateResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.PlayerUpdateResponse, rhs: Pogoprotos.Networking.Responses.PlayerUpdateResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.wildPokemons == rhs.wildPokemons)
      fieldCheck = fieldCheck && (lhs.forts == rhs.forts)
      fieldCheck = fieldCheck && (lhs.hasFortsNearby == rhs.hasFortsNearby) && (!lhs.hasFortsNearby || lhs.fortsNearby == rhs.fortsNearby)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var wildPokemons:Array<Pogoprotos.Map.Pokemon.WildPokemon>  = Array<Pogoprotos.Map.Pokemon.WildPokemon>()
    public fileprivate(set) var forts:Array<Pogoprotos.Map.Fort.FortData>  = Array<Pogoprotos.Map.Fort.FortData>()
    public fileprivate(set) var fortsNearby:Int32 = Int32(0)
    public fileprivate(set) var hasFortsNearby:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      for oneElementWildPokemons in wildPokemons {
          try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementWildPokemons)
      }
      for oneElementForts in forts {
          try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementForts)
      }
      if hasFortsNearby {
        try codedOutputStream.writeInt32(fieldNumber: 3, value:fortsNearby)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementWildPokemons in wildPokemons {
          serialize_size += oneElementWildPokemons.computeMessageSize(fieldNumber: 1)
      }
      for oneElementForts in forts {
          serialize_size += oneElementForts.computeMessageSize(fieldNumber: 2)
      }
      if hasFortsNearby {
        serialize_size += fortsNearby.computeInt32Size(fieldNumber: 3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
      return Pogoprotos.Networking.Responses.PlayerUpdateResponse.classBuilder() as! Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.PlayerUpdateResponse) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if !wildPokemons.isEmpty {
        var jsonArrayWildPokemons:Array<Dictionary<String,Any>> = []
          for oneValueWildPokemons in wildPokemons {
            let ecodedMessageWildPokemons = try oneValueWildPokemons.encode()
            jsonArrayWildPokemons.append(ecodedMessageWildPokemons)
          }
        jsonMap["wildPokemons"] = jsonArrayWildPokemons
      }
      if !forts.isEmpty {
        var jsonArrayForts:Array<Dictionary<String,Any>> = []
          for oneValueForts in forts {
            let ecodedMessageForts = try oneValueForts.encode()
            jsonArrayForts.append(ecodedMessageForts)
          }
        jsonMap["forts"] = jsonArrayForts
      }
      if hasFortsNearby {
        jsonMap["fortsNearby"] = Int(fortsNearby)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var wildPokemonsElementIndex:Int = 0
      for oneElementWildPokemons in wildPokemons {
          output += "\(indent) wildPokemons[\(wildPokemonsElementIndex)] {\n"
          output += try oneElementWildPokemons.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          wildPokemonsElementIndex += 1
      }
      var fortsElementIndex:Int = 0
      for oneElementForts in forts {
          output += "\(indent) forts[\(fortsElementIndex)] {\n"
          output += try oneElementForts.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          fortsElementIndex += 1
      }
      if hasFortsNearby {
        output += "\(indent) fortsNearby: \(fortsNearby) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementWildPokemons in wildPokemons {
                hashCode = (hashCode &* 31) &+ oneElementWildPokemons.hashValue
            }
            for oneElementForts in forts {
                hashCode = (hashCode &* 31) &+ oneElementForts.hashValue
            }
            if hasFortsNearby {
               hashCode = (hashCode &* 31) &+ fortsNearby.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.PlayerUpdateResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.PlayerUpdateResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.PlayerUpdateResponse = Pogoprotos.Networking.Responses.PlayerUpdateResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var wildPokemons:Array<Pogoprotos.Map.Pokemon.WildPokemon> {
           get {
               return builderResult.wildPokemons
           }
           set (value) {
               builderResult.wildPokemons = value
           }
      }
      @discardableResult
      public func setWildPokemons(_ value:Array<Pogoprotos.Map.Pokemon.WildPokemon>) -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        self.wildPokemons = value
        return self
      }
      @discardableResult
      public func clearWildPokemons() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        builderResult.wildPokemons.removeAll(keepingCapacity: false)
        return self
      }
      public var forts:Array<Pogoprotos.Map.Fort.FortData> {
           get {
               return builderResult.forts
           }
           set (value) {
               builderResult.forts = value
           }
      }
      @discardableResult
      public func setForts(_ value:Array<Pogoprotos.Map.Fort.FortData>) -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        self.forts = value
        return self
      }
      @discardableResult
      public func clearForts() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        builderResult.forts.removeAll(keepingCapacity: false)
        return self
      }
      public var hasFortsNearby:Bool {
           get {
                return builderResult.hasFortsNearby
           }
      }
      public var fortsNearby:Int32 {
           get {
                return builderResult.fortsNearby
           }
           set (value) {
               builderResult.hasFortsNearby = true
               builderResult.fortsNearby = value
           }
      }
      @discardableResult
      public func setFortsNearby(_ value:Int32) -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        self.fortsNearby = value
        return self
      }
      @discardableResult
      public func clearFortsNearby() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder{
           builderResult.hasFortsNearby = false
           builderResult.fortsNearby = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.PlayerUpdateResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
        let returnMe:Pogoprotos.Networking.Responses.PlayerUpdateResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.PlayerUpdateResponse) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        if other == Pogoprotos.Networking.Responses.PlayerUpdateResponse() {
         return self
        }
        if !other.wildPokemons.isEmpty  {
           builderResult.wildPokemons += other.wildPokemons
        }
        if !other.forts.isEmpty  {
           builderResult.forts += other.forts
        }
        if other.hasFortsNearby {
             fortsNearby = other.fortsNearby
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = Pogoprotos.Map.Pokemon.WildPokemon.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            wildPokemons.append(subBuilder.buildPartial())

          case 18:
            let subBuilder = Pogoprotos.Map.Fort.FortData.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            forts.append(subBuilder.buildPartial())

          case 24:
            fortsNearby = try codedInputStream.readInt32()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder()
        if let jsonValueWildPokemons = jsonMap["wildPokemons"] as? Array<Dictionary<String,Any>> {
          var jsonArrayWildPokemons:Array<Pogoprotos.Map.Pokemon.WildPokemon> = []
          for oneValueWildPokemons in jsonValueWildPokemons {
            let messageFromStringWildPokemons = try Pogoprotos.Map.Pokemon.WildPokemon.Builder.decodeToBuilder(jsonMap:oneValueWildPokemons).build()

            jsonArrayWildPokemons.append(messageFromStringWildPokemons)
          }
          resultDecodedBuilder.wildPokemons = jsonArrayWildPokemons
        }
        if let jsonValueForts = jsonMap["forts"] as? Array<Dictionary<String,Any>> {
          var jsonArrayForts:Array<Pogoprotos.Map.Fort.FortData> = []
          for oneValueForts in jsonValueForts {
            let messageFromStringForts = try Pogoprotos.Map.Fort.FortData.Builder.decodeToBuilder(jsonMap:oneValueForts).build()

            jsonArrayForts.append(messageFromStringForts)
          }
          resultDecodedBuilder.forts = jsonArrayForts
        }
        if let jsonValueFortsNearby = jsonMap["fortsNearby"] as? Int {
          resultDecodedBuilder.fortsNearby = Int32(jsonValueFortsNearby)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class RecycleInventoryItemResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.RecycleInventoryItemResponse, rhs: Pogoprotos.Networking.Responses.RecycleInventoryItemResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasNewCount == rhs.hasNewCount) && (!lhs.hasNewCount || lhs.newCount == rhs.newCount)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case errorNotEnoughCopies = 2
        case errorCannotRecycleIncubators = 3
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .errorNotEnoughCopies: return "ERROR_NOT_ENOUGH_COPIES"
          case .errorCannotRecycleIncubators: return "ERROR_CANNOT_RECYCLE_INCUBATORS"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "ERROR_NOT_ENOUGH_COPIES":  return .errorNotEnoughCopies
          case "ERROR_CANNOT_RECYCLE_INCUBATORS":  return .errorCannotRecycleIncubators
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .errorNotEnoughCopies: return ".errorNotEnoughCopies"
          case .errorCannotRecycleIncubators: return ".errorCannotRecycleIncubators"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Result = Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var newCount:Int32 = Int32(0)
    public fileprivate(set) var hasNewCount:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasNewCount {
        try codedOutputStream.writeInt32(fieldNumber: 2, value:newCount)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasNewCount {
        serialize_size += newCount.computeInt32Size(fieldNumber: 2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
      return Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.classBuilder() as! Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.RecycleInventoryItemResponse) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasNewCount {
        jsonMap["newCount"] = Int(newCount)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasNewCount {
        output += "\(indent) newCount: \(newCount) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasNewCount {
               hashCode = (hashCode &* 31) &+ newCount.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.RecycleInventoryItemResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.RecycleInventoryItemResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.RecycleInventoryItemResponse = Pogoprotos.Networking.Responses.RecycleInventoryItemResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Result) -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasNewCount:Bool {
           get {
                return builderResult.hasNewCount
           }
      }
      public var newCount:Int32 {
           get {
                return builderResult.newCount
           }
           set (value) {
               builderResult.hasNewCount = true
               builderResult.newCount = value
           }
      }
      @discardableResult
      public func setNewCount(_ value:Int32) -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
        self.newCount = value
        return self
      }
      @discardableResult
      public func clearNewCount() -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder{
           builderResult.hasNewCount = false
           builderResult.newCount = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.RecycleInventoryItemResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
        return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
        let returnMe:Pogoprotos.Networking.Responses.RecycleInventoryItemResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.RecycleInventoryItemResponse) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
        if other == Pogoprotos.Networking.Responses.RecycleInventoryItemResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasNewCount {
             newCount = other.newCount
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 16:
            newCount = try codedInputStream.readInt32()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueNewCount = jsonMap["newCount"] as? Int {
          resultDecodedBuilder.newCount = Int32(jsonValueNewCount)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class ReleasePokemonResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.ReleasePokemonResponse, rhs: Pogoprotos.Networking.Responses.ReleasePokemonResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasCandyAwarded == rhs.hasCandyAwarded) && (!lhs.hasCandyAwarded || lhs.candyAwarded == rhs.candyAwarded)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case pokemonDeployed = 2
        case failed = 3
        case errorPokemonIsEgg = 4
        case errorPokemonIsBuddy = 5
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .pokemonDeployed: return "POKEMON_DEPLOYED"
          case .failed: return "FAILED"
          case .errorPokemonIsEgg: return "ERROR_POKEMON_IS_EGG"
          case .errorPokemonIsBuddy: return "ERROR_POKEMON_IS_BUDDY"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "POKEMON_DEPLOYED":  return .pokemonDeployed
          case "FAILED":  return .failed
          case "ERROR_POKEMON_IS_EGG":  return .errorPokemonIsEgg
          case "ERROR_POKEMON_IS_BUDDY":  return .errorPokemonIsBuddy
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .pokemonDeployed: return ".pokemonDeployed"
          case .failed: return ".failed"
          case .errorPokemonIsEgg: return ".errorPokemonIsEgg"
          case .errorPokemonIsBuddy: return ".errorPokemonIsBuddy"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.ReleasePokemonResponse.Result = Pogoprotos.Networking.Responses.ReleasePokemonResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var candyAwarded:Int32 = Int32(0)
    public fileprivate(set) var hasCandyAwarded:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasCandyAwarded {
        try codedOutputStream.writeInt32(fieldNumber: 2, value:candyAwarded)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasCandyAwarded {
        serialize_size += candyAwarded.computeInt32Size(fieldNumber: 2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.ReleasePokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.ReleasePokemonResponse) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasCandyAwarded {
        jsonMap["candyAwarded"] = Int(candyAwarded)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasCandyAwarded {
        output += "\(indent) candyAwarded: \(candyAwarded) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasCandyAwarded {
               hashCode = (hashCode &* 31) &+ candyAwarded.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.ReleasePokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.ReleasePokemonResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.ReleasePokemonResponse = Pogoprotos.Networking.Responses.ReleasePokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.ReleasePokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.ReleasePokemonResponse.Result) -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasCandyAwarded:Bool {
           get {
                return builderResult.hasCandyAwarded
           }
      }
      public var candyAwarded:Int32 {
           get {
                return builderResult.candyAwarded
           }
           set (value) {
               builderResult.hasCandyAwarded = true
               builderResult.candyAwarded = value
           }
      }
      @discardableResult
      public func setCandyAwarded(_ value:Int32) -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
        self.candyAwarded = value
        return self
      }
      @discardableResult
      public func clearCandyAwarded() -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder{
           builderResult.hasCandyAwarded = false
           builderResult.candyAwarded = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.ReleasePokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.ReleasePokemonResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.ReleasePokemonResponse) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.ReleasePokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasCandyAwarded {
             candyAwarded = other.candyAwarded
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.ReleasePokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 16:
            candyAwarded = try codedInputStream.readInt32()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueCandyAwarded = jsonMap["candyAwarded"] as? Int {
          resultDecodedBuilder.candyAwarded = Int32(jsonValueCandyAwarded)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class SetAvatarResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.SetAvatarResponse, rhs: Pogoprotos.Networking.Responses.SetAvatarResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
      fieldCheck = fieldCheck && (lhs.hasPlayerData == rhs.hasPlayerData) && (!lhs.hasPlayerData || lhs.playerData == rhs.playerData)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Status:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case avatarAlreadySet = 2
        case failure = 3
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .avatarAlreadySet: return "AVATAR_ALREADY_SET"
          case .failure: return "FAILURE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Status {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "AVATAR_ALREADY_SET":  return .avatarAlreadySet
          case "FAILURE":  return .failure
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .avatarAlreadySet: return ".avatarAlreadySet"
          case .failure: return ".failure"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var status:Pogoprotos.Networking.Responses.SetAvatarResponse.Status = Pogoprotos.Networking.Responses.SetAvatarResponse.Status.unset
    public fileprivate(set) var hasStatus:Bool = false
    public fileprivate(set) var playerData:Pogoprotos.Data.PlayerData!
    public fileprivate(set) var hasPlayerData:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasStatus {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:status.rawValue)
      }
      if hasPlayerData {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:playerData)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasPlayerData {
          if let varSizeplayerData = playerData?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeplayerData
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
      return Pogoprotos.Networking.Responses.SetAvatarResponse.classBuilder() as! Pogoprotos.Networking.Responses.SetAvatarResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.SetAvatarResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.SetAvatarResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.SetAvatarResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.SetAvatarResponse) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      if hasPlayerData {
        jsonMap["playerData"] = try playerData.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      if hasPlayerData {
        output += "\(indent) playerData {\n"
        if let outDescPlayerData = playerData {
          output += try outDescPlayerData.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            if hasPlayerData {
                if let hashValueplayerData = playerData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueplayerData
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.SetAvatarResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.SetAvatarResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.SetAvatarResponse = Pogoprotos.Networking.Responses.SetAvatarResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.SetAvatarResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Networking.Responses.SetAvatarResponse.Status {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
      @discardableResult
        public func setStatus(_ value:Pogoprotos.Networking.Responses.SetAvatarResponse.Status) -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
          self.status = value
          return self
        }
      @discardableResult
        public func clearStatus() -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .unset
           return self
        }
      public var hasPlayerData:Bool {
           get {
               return builderResult.hasPlayerData
           }
      }
      public var playerData:Pogoprotos.Data.PlayerData! {
           get {
               if playerDataBuilder_ != nil {
                  builderResult.playerData = playerDataBuilder_.getMessage()
               }
               return builderResult.playerData
           }
           set (value) {
               builderResult.hasPlayerData = true
               builderResult.playerData = value
           }
      }
      fileprivate var playerDataBuilder_:Pogoprotos.Data.PlayerData.Builder! {
           didSet {
              builderResult.hasPlayerData = true
           }
      }
      public func getPlayerDataBuilder() -> Pogoprotos.Data.PlayerData.Builder {
        if playerDataBuilder_ == nil {
           playerDataBuilder_ = Pogoprotos.Data.PlayerData.Builder()
           builderResult.playerData = playerDataBuilder_.getMessage()
           if playerData != nil {
              try! playerDataBuilder_.mergeFrom(other: playerData)
           }
        }
        return playerDataBuilder_
      }
      @discardableResult
      public func setPlayerData(_ value:Pogoprotos.Data.PlayerData!) -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        self.playerData = value
        return self
      }
      @discardableResult
      public func mergePlayerData(value:Pogoprotos.Data.PlayerData) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        if builderResult.hasPlayerData {
          builderResult.playerData = try Pogoprotos.Data.PlayerData.builderWithPrototype(prototype:builderResult.playerData).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.playerData = value
        }
        builderResult.hasPlayerData = true
        return self
      }
      @discardableResult
      public func clearPlayerData() -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        playerDataBuilder_ = nil
        builderResult.hasPlayerData = false
        builderResult.playerData = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.SetAvatarResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        return try Pogoprotos.Networking.Responses.SetAvatarResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.SetAvatarResponse {
        let returnMe:Pogoprotos.Networking.Responses.SetAvatarResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.SetAvatarResponse) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        if other == Pogoprotos.Networking.Responses.SetAvatarResponse() {
         return self
        }
        if other.hasStatus {
             status = other.status
        }
        if (other.hasPlayerData) {
            try mergePlayerData(value: other.playerData)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntstatus = try codedInputStream.readEnum()
            if let enumsstatus = Pogoprotos.Networking.Responses.SetAvatarResponse.Status(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntstatus))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PlayerData.Builder = Pogoprotos.Data.PlayerData.Builder()
            if hasPlayerData {
              try subBuilder.mergeFrom(other: playerData)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            playerData = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.SetAvatarResponse.Builder()
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Networking.Responses.SetAvatarResponse.Status.fromString(str: jsonValueStatus)
        }
        if let jsonValuePlayerData = jsonMap["playerData"] as? Dictionary<String,Any> {
          resultDecodedBuilder.playerData = try Pogoprotos.Data.PlayerData.Builder.decodeToBuilder(jsonMap:jsonValuePlayerData).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class SetBuddyPokemonResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.SetBuddyPokemonResponse, rhs: Pogoprotos.Networking.Responses.SetBuddyPokemonResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasUpdatedBuddy == rhs.hasUpdatedBuddy) && (!lhs.hasUpdatedBuddy || lhs.updatedBuddy == rhs.updatedBuddy)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unest = 0
        case success = 1
        case errorPokemonDeployed = 2
        case errorPokemonNotOwned = 3
        case errorPokemonIsEgg = 4
        public func toString() -> String {
          switch self {
          case .unest: return "UNEST"
          case .success: return "SUCCESS"
          case .errorPokemonDeployed: return "ERROR_POKEMON_DEPLOYED"
          case .errorPokemonNotOwned: return "ERROR_POKEMON_NOT_OWNED"
          case .errorPokemonIsEgg: return "ERROR_POKEMON_IS_EGG"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Result {
          switch str {
          case "UNEST":  return .unest
          case "SUCCESS":  return .success
          case "ERROR_POKEMON_DEPLOYED":  return .errorPokemonDeployed
          case "ERROR_POKEMON_NOT_OWNED":  return .errorPokemonNotOwned
          case "ERROR_POKEMON_IS_EGG":  return .errorPokemonIsEgg
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unest: return ".unest"
          case .success: return ".success"
          case .errorPokemonDeployed: return ".errorPokemonDeployed"
          case .errorPokemonNotOwned: return ".errorPokemonNotOwned"
          case .errorPokemonIsEgg: return ".errorPokemonIsEgg"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Result = Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Result.unest
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var updatedBuddy:Pogoprotos.Data.BuddyPokemon!
    public fileprivate(set) var hasUpdatedBuddy:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasUpdatedBuddy {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:updatedBuddy)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasUpdatedBuddy {
          if let varSizeupdatedBuddy = updatedBuddy?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeupdatedBuddy
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.SetBuddyPokemonResponse) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasUpdatedBuddy {
        jsonMap["updatedBuddy"] = try updatedBuddy.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse {
      return try Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse {
      return try Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasUpdatedBuddy {
        output += "\(indent) updatedBuddy {\n"
        if let outDescUpdatedBuddy = updatedBuddy {
          output += try outDescUpdatedBuddy.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasUpdatedBuddy {
                if let hashValueupdatedBuddy = updatedBuddy?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueupdatedBuddy
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.SetBuddyPokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.SetBuddyPokemonResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.SetBuddyPokemonResponse = Pogoprotos.Networking.Responses.SetBuddyPokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Result) -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unest
           return self
        }
      public var hasUpdatedBuddy:Bool {
           get {
               return builderResult.hasUpdatedBuddy
           }
      }
      public var updatedBuddy:Pogoprotos.Data.BuddyPokemon! {
           get {
               if updatedBuddyBuilder_ != nil {
                  builderResult.updatedBuddy = updatedBuddyBuilder_.getMessage()
               }
               return builderResult.updatedBuddy
           }
           set (value) {
               builderResult.hasUpdatedBuddy = true
               builderResult.updatedBuddy = value
           }
      }
      fileprivate var updatedBuddyBuilder_:Pogoprotos.Data.BuddyPokemon.Builder! {
           didSet {
              builderResult.hasUpdatedBuddy = true
           }
      }
      public func getUpdatedBuddyBuilder() -> Pogoprotos.Data.BuddyPokemon.Builder {
        if updatedBuddyBuilder_ == nil {
           updatedBuddyBuilder_ = Pogoprotos.Data.BuddyPokemon.Builder()
           builderResult.updatedBuddy = updatedBuddyBuilder_.getMessage()
           if updatedBuddy != nil {
              try! updatedBuddyBuilder_.mergeFrom(other: updatedBuddy)
           }
        }
        return updatedBuddyBuilder_
      }
      @discardableResult
      public func setUpdatedBuddy(_ value:Pogoprotos.Data.BuddyPokemon!) -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
        self.updatedBuddy = value
        return self
      }
      @discardableResult
      public func mergeUpdatedBuddy(value:Pogoprotos.Data.BuddyPokemon) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
        if builderResult.hasUpdatedBuddy {
          builderResult.updatedBuddy = try Pogoprotos.Data.BuddyPokemon.builderWithPrototype(prototype:builderResult.updatedBuddy).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.updatedBuddy = value
        }
        builderResult.hasUpdatedBuddy = true
        return self
      }
      @discardableResult
      public func clearUpdatedBuddy() -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
        updatedBuddyBuilder_ = nil
        builderResult.hasUpdatedBuddy = false
        builderResult.updatedBuddy = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.SetBuddyPokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.SetBuddyPokemonResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.SetBuddyPokemonResponse) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.SetBuddyPokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasUpdatedBuddy) {
            try mergeUpdatedBuddy(value: other.updatedBuddy)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.BuddyPokemon.Builder = Pogoprotos.Data.BuddyPokemon.Builder()
            if hasUpdatedBuddy {
              try subBuilder.mergeFrom(other: updatedBuddy)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            updatedBuddy = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueUpdatedBuddy = jsonMap["updatedBuddy"] as? Dictionary<String,Any> {
          resultDecodedBuilder.updatedBuddy = try Pogoprotos.Data.BuddyPokemon.Builder.decodeToBuilder(jsonMap:jsonValueUpdatedBuddy).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class SetContactSettingsResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.SetContactSettingsResponse, rhs: Pogoprotos.Networking.Responses.SetContactSettingsResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
      fieldCheck = fieldCheck && (lhs.hasPlayerData == rhs.hasPlayerData) && (!lhs.hasPlayerData || lhs.playerData == rhs.playerData)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Status:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case failure = 2
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .failure: return "FAILURE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Status {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "FAILURE":  return .failure
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .failure: return ".failure"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var status:Pogoprotos.Networking.Responses.SetContactSettingsResponse.Status = Pogoprotos.Networking.Responses.SetContactSettingsResponse.Status.unset
    public fileprivate(set) var hasStatus:Bool = false
    public fileprivate(set) var playerData:Pogoprotos.Data.PlayerData!
    public fileprivate(set) var hasPlayerData:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasStatus {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:status.rawValue)
      }
      if hasPlayerData {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:playerData)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasPlayerData {
          if let varSizeplayerData = playerData?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeplayerData
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
      return Pogoprotos.Networking.Responses.SetContactSettingsResponse.classBuilder() as! Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.SetContactSettingsResponse) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      if hasPlayerData {
        jsonMap["playerData"] = try playerData.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      if hasPlayerData {
        output += "\(indent) playerData {\n"
        if let outDescPlayerData = playerData {
          output += try outDescPlayerData.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            if hasPlayerData {
                if let hashValueplayerData = playerData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueplayerData
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.SetContactSettingsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.SetContactSettingsResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.SetContactSettingsResponse = Pogoprotos.Networking.Responses.SetContactSettingsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Networking.Responses.SetContactSettingsResponse.Status {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
      @discardableResult
        public func setStatus(_ value:Pogoprotos.Networking.Responses.SetContactSettingsResponse.Status) -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
          self.status = value
          return self
        }
      @discardableResult
        public func clearStatus() -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .unset
           return self
        }
      public var hasPlayerData:Bool {
           get {
               return builderResult.hasPlayerData
           }
      }
      public var playerData:Pogoprotos.Data.PlayerData! {
           get {
               if playerDataBuilder_ != nil {
                  builderResult.playerData = playerDataBuilder_.getMessage()
               }
               return builderResult.playerData
           }
           set (value) {
               builderResult.hasPlayerData = true
               builderResult.playerData = value
           }
      }
      fileprivate var playerDataBuilder_:Pogoprotos.Data.PlayerData.Builder! {
           didSet {
              builderResult.hasPlayerData = true
           }
      }
      public func getPlayerDataBuilder() -> Pogoprotos.Data.PlayerData.Builder {
        if playerDataBuilder_ == nil {
           playerDataBuilder_ = Pogoprotos.Data.PlayerData.Builder()
           builderResult.playerData = playerDataBuilder_.getMessage()
           if playerData != nil {
              try! playerDataBuilder_.mergeFrom(other: playerData)
           }
        }
        return playerDataBuilder_
      }
      @discardableResult
      public func setPlayerData(_ value:Pogoprotos.Data.PlayerData!) -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        self.playerData = value
        return self
      }
      @discardableResult
      public func mergePlayerData(value:Pogoprotos.Data.PlayerData) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        if builderResult.hasPlayerData {
          builderResult.playerData = try Pogoprotos.Data.PlayerData.builderWithPrototype(prototype:builderResult.playerData).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.playerData = value
        }
        builderResult.hasPlayerData = true
        return self
      }
      @discardableResult
      public func clearPlayerData() -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        playerDataBuilder_ = nil
        builderResult.hasPlayerData = false
        builderResult.playerData = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.SetContactSettingsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
        let returnMe:Pogoprotos.Networking.Responses.SetContactSettingsResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.SetContactSettingsResponse) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.SetContactSettingsResponse() {
         return self
        }
        if other.hasStatus {
             status = other.status
        }
        if (other.hasPlayerData) {
            try mergePlayerData(value: other.playerData)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntstatus = try codedInputStream.readEnum()
            if let enumsstatus = Pogoprotos.Networking.Responses.SetContactSettingsResponse.Status(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntstatus))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PlayerData.Builder = Pogoprotos.Data.PlayerData.Builder()
            if hasPlayerData {
              try subBuilder.mergeFrom(other: playerData)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            playerData = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder()
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Status.fromString(str: jsonValueStatus)
        }
        if let jsonValuePlayerData = jsonMap["playerData"] as? Dictionary<String,Any> {
          resultDecodedBuilder.playerData = try Pogoprotos.Data.PlayerData.Builder.decodeToBuilder(jsonMap:jsonValuePlayerData).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class SetFavoritePokemonResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.SetFavoritePokemonResponse, rhs: Pogoprotos.Networking.Responses.SetFavoritePokemonResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case errorPokemonNotFound = 2
        case errorPokemonIsEgg = 3
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .errorPokemonNotFound: return "ERROR_POKEMON_NOT_FOUND"
          case .errorPokemonIsEgg: return "ERROR_POKEMON_IS_EGG"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "ERROR_POKEMON_NOT_FOUND":  return .errorPokemonNotFound
          case "ERROR_POKEMON_IS_EGG":  return .errorPokemonIsEgg
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .errorPokemonNotFound: return ".errorPokemonNotFound"
          case .errorPokemonIsEgg: return ".errorPokemonIsEgg"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Result = Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.SetFavoritePokemonResponse) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.SetFavoritePokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.SetFavoritePokemonResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.SetFavoritePokemonResponse = Pogoprotos.Networking.Responses.SetFavoritePokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Result) -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.SetFavoritePokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.SetFavoritePokemonResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.SetFavoritePokemonResponse) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.SetFavoritePokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Result.fromString(str: jsonValueResult)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class SetPlayerTeamResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.SetPlayerTeamResponse, rhs: Pogoprotos.Networking.Responses.SetPlayerTeamResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
      fieldCheck = fieldCheck && (lhs.hasPlayerData == rhs.hasPlayerData) && (!lhs.hasPlayerData || lhs.playerData == rhs.playerData)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Status:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case teamAlreadySet = 2
        case failure = 3
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .teamAlreadySet: return "TEAM_ALREADY_SET"
          case .failure: return "FAILURE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Status {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "TEAM_ALREADY_SET":  return .teamAlreadySet
          case "FAILURE":  return .failure
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .teamAlreadySet: return ".teamAlreadySet"
          case .failure: return ".failure"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var status:Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Status = Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Status.unset
    public fileprivate(set) var hasStatus:Bool = false
    public fileprivate(set) var playerData:Pogoprotos.Data.PlayerData!
    public fileprivate(set) var hasPlayerData:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasStatus {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:status.rawValue)
      }
      if hasPlayerData {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:playerData)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasPlayerData {
          if let varSizeplayerData = playerData?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeplayerData
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
      return Pogoprotos.Networking.Responses.SetPlayerTeamResponse.classBuilder() as! Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.SetPlayerTeamResponse) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      if hasPlayerData {
        jsonMap["playerData"] = try playerData.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      if hasPlayerData {
        output += "\(indent) playerData {\n"
        if let outDescPlayerData = playerData {
          output += try outDescPlayerData.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            if hasPlayerData {
                if let hashValueplayerData = playerData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueplayerData
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.SetPlayerTeamResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.SetPlayerTeamResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.SetPlayerTeamResponse = Pogoprotos.Networking.Responses.SetPlayerTeamResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Status {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
      @discardableResult
        public func setStatus(_ value:Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Status) -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
          self.status = value
          return self
        }
      @discardableResult
        public func clearStatus() -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .unset
           return self
        }
      public var hasPlayerData:Bool {
           get {
               return builderResult.hasPlayerData
           }
      }
      public var playerData:Pogoprotos.Data.PlayerData! {
           get {
               if playerDataBuilder_ != nil {
                  builderResult.playerData = playerDataBuilder_.getMessage()
               }
               return builderResult.playerData
           }
           set (value) {
               builderResult.hasPlayerData = true
               builderResult.playerData = value
           }
      }
      fileprivate var playerDataBuilder_:Pogoprotos.Data.PlayerData.Builder! {
           didSet {
              builderResult.hasPlayerData = true
           }
      }
      public func getPlayerDataBuilder() -> Pogoprotos.Data.PlayerData.Builder {
        if playerDataBuilder_ == nil {
           playerDataBuilder_ = Pogoprotos.Data.PlayerData.Builder()
           builderResult.playerData = playerDataBuilder_.getMessage()
           if playerData != nil {
              try! playerDataBuilder_.mergeFrom(other: playerData)
           }
        }
        return playerDataBuilder_
      }
      @discardableResult
      public func setPlayerData(_ value:Pogoprotos.Data.PlayerData!) -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        self.playerData = value
        return self
      }
      @discardableResult
      public func mergePlayerData(value:Pogoprotos.Data.PlayerData) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        if builderResult.hasPlayerData {
          builderResult.playerData = try Pogoprotos.Data.PlayerData.builderWithPrototype(prototype:builderResult.playerData).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.playerData = value
        }
        builderResult.hasPlayerData = true
        return self
      }
      @discardableResult
      public func clearPlayerData() -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        playerDataBuilder_ = nil
        builderResult.hasPlayerData = false
        builderResult.playerData = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.SetPlayerTeamResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
        let returnMe:Pogoprotos.Networking.Responses.SetPlayerTeamResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.SetPlayerTeamResponse) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        if other == Pogoprotos.Networking.Responses.SetPlayerTeamResponse() {
         return self
        }
        if other.hasStatus {
             status = other.status
        }
        if (other.hasPlayerData) {
            try mergePlayerData(value: other.playerData)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntstatus = try codedInputStream.readEnum()
            if let enumsstatus = Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Status(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntstatus))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PlayerData.Builder = Pogoprotos.Data.PlayerData.Builder()
            if hasPlayerData {
              try subBuilder.mergeFrom(other: playerData)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            playerData = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder()
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Status.fromString(str: jsonValueStatus)
        }
        if let jsonValuePlayerData = jsonMap["playerData"] as? Dictionary<String,Any> {
          resultDecodedBuilder.playerData = try Pogoprotos.Data.PlayerData.Builder.decodeToBuilder(jsonMap:jsonValuePlayerData).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class SfidaActionLogResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.SfidaActionLogResponse, rhs: Pogoprotos.Networking.Responses.SfidaActionLogResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.logEntries == rhs.logEntries)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.SfidaActionLogResponse.Result = Pogoprotos.Networking.Responses.SfidaActionLogResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var logEntries:Array<Pogoprotos.Data.Logs.ActionLogEntry>  = Array<Pogoprotos.Data.Logs.ActionLogEntry>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      for oneElementLogEntries in logEntries {
          try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementLogEntries)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      for oneElementLogEntries in logEntries {
          serialize_size += oneElementLogEntries.computeMessageSize(fieldNumber: 2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
      return Pogoprotos.Networking.Responses.SfidaActionLogResponse.classBuilder() as! Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.SfidaActionLogResponse) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if !logEntries.isEmpty {
        var jsonArrayLogEntries:Array<Dictionary<String,Any>> = []
          for oneValueLogEntries in logEntries {
            let ecodedMessageLogEntries = try oneValueLogEntries.encode()
            jsonArrayLogEntries.append(ecodedMessageLogEntries)
          }
        jsonMap["logEntries"] = jsonArrayLogEntries
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      var logEntriesElementIndex:Int = 0
      for oneElementLogEntries in logEntries {
          output += "\(indent) logEntries[\(logEntriesElementIndex)] {\n"
          output += try oneElementLogEntries.getDescription(indent: "\(indent)  ")
          output += "\(indent)}\n"
          logEntriesElementIndex += 1
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            for oneElementLogEntries in logEntries {
                hashCode = (hashCode &* 31) &+ oneElementLogEntries.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.SfidaActionLogResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.SfidaActionLogResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.SfidaActionLogResponse = Pogoprotos.Networking.Responses.SfidaActionLogResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.SfidaActionLogResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.SfidaActionLogResponse.Result) -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var logEntries:Array<Pogoprotos.Data.Logs.ActionLogEntry> {
           get {
               return builderResult.logEntries
           }
           set (value) {
               builderResult.logEntries = value
           }
      }
      @discardableResult
      public func setLogEntries(_ value:Array<Pogoprotos.Data.Logs.ActionLogEntry>) -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        self.logEntries = value
        return self
      }
      @discardableResult
      public func clearLogEntries() -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        builderResult.logEntries.removeAll(keepingCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.SfidaActionLogResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
        let returnMe:Pogoprotos.Networking.Responses.SfidaActionLogResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.SfidaActionLogResponse) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        if other == Pogoprotos.Networking.Responses.SfidaActionLogResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if !other.logEntries.isEmpty  {
           builderResult.logEntries += other.logEntries
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.SfidaActionLogResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder = Pogoprotos.Data.Logs.ActionLogEntry.Builder()
            try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
            logEntries.append(subBuilder.buildPartial())

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueLogEntries = jsonMap["logEntries"] as? Array<Dictionary<String,Any>> {
          var jsonArrayLogEntries:Array<Pogoprotos.Data.Logs.ActionLogEntry> = []
          for oneValueLogEntries in jsonValueLogEntries {
            let messageFromStringLogEntries = try Pogoprotos.Data.Logs.ActionLogEntry.Builder.decodeToBuilder(jsonMap:oneValueLogEntries).build()

            jsonArrayLogEntries.append(messageFromStringLogEntries)
          }
          resultDecodedBuilder.logEntries = jsonArrayLogEntries
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class StartGymBattleResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.StartGymBattleResponse, rhs: Pogoprotos.Networking.Responses.StartGymBattleResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasBattleStartTimestampMs == rhs.hasBattleStartTimestampMs) && (!lhs.hasBattleStartTimestampMs || lhs.battleStartTimestampMs == rhs.battleStartTimestampMs)
      fieldCheck = fieldCheck && (lhs.hasBattleEndTimestampMs == rhs.hasBattleEndTimestampMs) && (!lhs.hasBattleEndTimestampMs || lhs.battleEndTimestampMs == rhs.battleEndTimestampMs)
      fieldCheck = fieldCheck && (lhs.hasBattleId == rhs.hasBattleId) && (!lhs.hasBattleId || lhs.battleId == rhs.battleId)
      fieldCheck = fieldCheck && (lhs.hasDefender == rhs.hasDefender) && (!lhs.hasDefender || lhs.defender == rhs.defender)
      fieldCheck = fieldCheck && (lhs.hasBattleLog == rhs.hasBattleLog) && (!lhs.hasBattleLog || lhs.battleLog == rhs.battleLog)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case errorGymNotFound = 2
        case errorGymNeutral = 3
        case errorGymWrongTeam = 4
        case errorGymEmpty = 5
        case errorInvalidDefender = 6
        case errorTrainingInvalidAttackerCount = 7
        case errorAllPokemonFainted = 8
        case errorTooManyBattles = 9
        case errorTooManyPlayers = 10
        case errorGymBattleLockout = 11
        case errorPlayerBelowMinimumLevel = 12
        case errorNotInRange = 13
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .errorGymNotFound: return "ERROR_GYM_NOT_FOUND"
          case .errorGymNeutral: return "ERROR_GYM_NEUTRAL"
          case .errorGymWrongTeam: return "ERROR_GYM_WRONG_TEAM"
          case .errorGymEmpty: return "ERROR_GYM_EMPTY"
          case .errorInvalidDefender: return "ERROR_INVALID_DEFENDER"
          case .errorTrainingInvalidAttackerCount: return "ERROR_TRAINING_INVALID_ATTACKER_COUNT"
          case .errorAllPokemonFainted: return "ERROR_ALL_POKEMON_FAINTED"
          case .errorTooManyBattles: return "ERROR_TOO_MANY_BATTLES"
          case .errorTooManyPlayers: return "ERROR_TOO_MANY_PLAYERS"
          case .errorGymBattleLockout: return "ERROR_GYM_BATTLE_LOCKOUT"
          case .errorPlayerBelowMinimumLevel: return "ERROR_PLAYER_BELOW_MINIMUM_LEVEL"
          case .errorNotInRange: return "ERROR_NOT_IN_RANGE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "ERROR_GYM_NOT_FOUND":  return .errorGymNotFound
          case "ERROR_GYM_NEUTRAL":  return .errorGymNeutral
          case "ERROR_GYM_WRONG_TEAM":  return .errorGymWrongTeam
          case "ERROR_GYM_EMPTY":  return .errorGymEmpty
          case "ERROR_INVALID_DEFENDER":  return .errorInvalidDefender
          case "ERROR_TRAINING_INVALID_ATTACKER_COUNT":  return .errorTrainingInvalidAttackerCount
          case "ERROR_ALL_POKEMON_FAINTED":  return .errorAllPokemonFainted
          case "ERROR_TOO_MANY_BATTLES":  return .errorTooManyBattles
          case "ERROR_TOO_MANY_PLAYERS":  return .errorTooManyPlayers
          case "ERROR_GYM_BATTLE_LOCKOUT":  return .errorGymBattleLockout
          case "ERROR_PLAYER_BELOW_MINIMUM_LEVEL":  return .errorPlayerBelowMinimumLevel
          case "ERROR_NOT_IN_RANGE":  return .errorNotInRange
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .errorGymNotFound: return ".errorGymNotFound"
          case .errorGymNeutral: return ".errorGymNeutral"
          case .errorGymWrongTeam: return ".errorGymWrongTeam"
          case .errorGymEmpty: return ".errorGymEmpty"
          case .errorInvalidDefender: return ".errorInvalidDefender"
          case .errorTrainingInvalidAttackerCount: return ".errorTrainingInvalidAttackerCount"
          case .errorAllPokemonFainted: return ".errorAllPokemonFainted"
          case .errorTooManyBattles: return ".errorTooManyBattles"
          case .errorTooManyPlayers: return ".errorTooManyPlayers"
          case .errorGymBattleLockout: return ".errorGymBattleLockout"
          case .errorPlayerBelowMinimumLevel: return ".errorPlayerBelowMinimumLevel"
          case .errorNotInRange: return ".errorNotInRange"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.StartGymBattleResponse.Result = Pogoprotos.Networking.Responses.StartGymBattleResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var battleStartTimestampMs:Int64 = Int64(0)
    public fileprivate(set) var hasBattleStartTimestampMs:Bool = false

    public fileprivate(set) var battleEndTimestampMs:Int64 = Int64(0)
    public fileprivate(set) var hasBattleEndTimestampMs:Bool = false

    public fileprivate(set) var battleId:String = ""
    public fileprivate(set) var hasBattleId:Bool = false

    public fileprivate(set) var defender:Pogoprotos.Data.Battle.BattleParticipant!
    public fileprivate(set) var hasDefender:Bool = false
    public fileprivate(set) var battleLog:Pogoprotos.Data.Battle.BattleLog!
    public fileprivate(set) var hasBattleLog:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasBattleStartTimestampMs {
        try codedOutputStream.writeInt64(fieldNumber: 2, value:battleStartTimestampMs)
      }
      if hasBattleEndTimestampMs {
        try codedOutputStream.writeInt64(fieldNumber: 3, value:battleEndTimestampMs)
      }
      if hasBattleId {
        try codedOutputStream.writeString(fieldNumber: 4, value:battleId)
      }
      if hasDefender {
        try codedOutputStream.writeMessage(fieldNumber: 5, value:defender)
      }
      if hasBattleLog {
        try codedOutputStream.writeMessage(fieldNumber: 6, value:battleLog)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasBattleStartTimestampMs {
        serialize_size += battleStartTimestampMs.computeInt64Size(fieldNumber: 2)
      }
      if hasBattleEndTimestampMs {
        serialize_size += battleEndTimestampMs.computeInt64Size(fieldNumber: 3)
      }
      if hasBattleId {
        serialize_size += battleId.computeStringSize(fieldNumber: 4)
      }
      if hasDefender {
          if let varSizedefender = defender?.computeMessageSize(fieldNumber: 5) {
              serialize_size += varSizedefender
          }
      }
      if hasBattleLog {
          if let varSizebattleLog = battleLog?.computeMessageSize(fieldNumber: 6) {
              serialize_size += varSizebattleLog
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
      return Pogoprotos.Networking.Responses.StartGymBattleResponse.classBuilder() as! Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.StartGymBattleResponse) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasBattleStartTimestampMs {
        jsonMap["battleStartTimestampMs"] = "\(battleStartTimestampMs)"
      }
      if hasBattleEndTimestampMs {
        jsonMap["battleEndTimestampMs"] = "\(battleEndTimestampMs)"
      }
      if hasBattleId {
        jsonMap["battleId"] = battleId
      }
      if hasDefender {
        jsonMap["defender"] = try defender.encode()
      }
      if hasBattleLog {
        jsonMap["battleLog"] = try battleLog.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasBattleStartTimestampMs {
        output += "\(indent) battleStartTimestampMs: \(battleStartTimestampMs) \n"
      }
      if hasBattleEndTimestampMs {
        output += "\(indent) battleEndTimestampMs: \(battleEndTimestampMs) \n"
      }
      if hasBattleId {
        output += "\(indent) battleId: \(battleId) \n"
      }
      if hasDefender {
        output += "\(indent) defender {\n"
        if let outDescDefender = defender {
          output += try outDescDefender.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasBattleLog {
        output += "\(indent) battleLog {\n"
        if let outDescBattleLog = battleLog {
          output += try outDescBattleLog.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasBattleStartTimestampMs {
               hashCode = (hashCode &* 31) &+ battleStartTimestampMs.hashValue
            }
            if hasBattleEndTimestampMs {
               hashCode = (hashCode &* 31) &+ battleEndTimestampMs.hashValue
            }
            if hasBattleId {
               hashCode = (hashCode &* 31) &+ battleId.hashValue
            }
            if hasDefender {
                if let hashValuedefender = defender?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuedefender
                }
            }
            if hasBattleLog {
                if let hashValuebattleLog = battleLog?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuebattleLog
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.StartGymBattleResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.StartGymBattleResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.StartGymBattleResponse = Pogoprotos.Networking.Responses.StartGymBattleResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.StartGymBattleResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.StartGymBattleResponse.Result) -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasBattleStartTimestampMs:Bool {
           get {
                return builderResult.hasBattleStartTimestampMs
           }
      }
      public var battleStartTimestampMs:Int64 {
           get {
                return builderResult.battleStartTimestampMs
           }
           set (value) {
               builderResult.hasBattleStartTimestampMs = true
               builderResult.battleStartTimestampMs = value
           }
      }
      @discardableResult
      public func setBattleStartTimestampMs(_ value:Int64) -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        self.battleStartTimestampMs = value
        return self
      }
      @discardableResult
      public func clearBattleStartTimestampMs() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder{
           builderResult.hasBattleStartTimestampMs = false
           builderResult.battleStartTimestampMs = Int64(0)
           return self
      }
      public var hasBattleEndTimestampMs:Bool {
           get {
                return builderResult.hasBattleEndTimestampMs
           }
      }
      public var battleEndTimestampMs:Int64 {
           get {
                return builderResult.battleEndTimestampMs
           }
           set (value) {
               builderResult.hasBattleEndTimestampMs = true
               builderResult.battleEndTimestampMs = value
           }
      }
      @discardableResult
      public func setBattleEndTimestampMs(_ value:Int64) -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        self.battleEndTimestampMs = value
        return self
      }
      @discardableResult
      public func clearBattleEndTimestampMs() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder{
           builderResult.hasBattleEndTimestampMs = false
           builderResult.battleEndTimestampMs = Int64(0)
           return self
      }
      public var hasBattleId:Bool {
           get {
                return builderResult.hasBattleId
           }
      }
      public var battleId:String {
           get {
                return builderResult.battleId
           }
           set (value) {
               builderResult.hasBattleId = true
               builderResult.battleId = value
           }
      }
      @discardableResult
      public func setBattleId(_ value:String) -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        self.battleId = value
        return self
      }
      @discardableResult
      public func clearBattleId() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder{
           builderResult.hasBattleId = false
           builderResult.battleId = ""
           return self
      }
      public var hasDefender:Bool {
           get {
               return builderResult.hasDefender
           }
      }
      public var defender:Pogoprotos.Data.Battle.BattleParticipant! {
           get {
               if defenderBuilder_ != nil {
                  builderResult.defender = defenderBuilder_.getMessage()
               }
               return builderResult.defender
           }
           set (value) {
               builderResult.hasDefender = true
               builderResult.defender = value
           }
      }
      fileprivate var defenderBuilder_:Pogoprotos.Data.Battle.BattleParticipant.Builder! {
           didSet {
              builderResult.hasDefender = true
           }
      }
      public func getDefenderBuilder() -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        if defenderBuilder_ == nil {
           defenderBuilder_ = Pogoprotos.Data.Battle.BattleParticipant.Builder()
           builderResult.defender = defenderBuilder_.getMessage()
           if defender != nil {
              try! defenderBuilder_.mergeFrom(other: defender)
           }
        }
        return defenderBuilder_
      }
      @discardableResult
      public func setDefender(_ value:Pogoprotos.Data.Battle.BattleParticipant!) -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        self.defender = value
        return self
      }
      @discardableResult
      public func mergeDefender(value:Pogoprotos.Data.Battle.BattleParticipant) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        if builderResult.hasDefender {
          builderResult.defender = try Pogoprotos.Data.Battle.BattleParticipant.builderWithPrototype(prototype:builderResult.defender).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.defender = value
        }
        builderResult.hasDefender = true
        return self
      }
      @discardableResult
      public func clearDefender() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        defenderBuilder_ = nil
        builderResult.hasDefender = false
        builderResult.defender = nil
        return self
      }
      public var hasBattleLog:Bool {
           get {
               return builderResult.hasBattleLog
           }
      }
      public var battleLog:Pogoprotos.Data.Battle.BattleLog! {
           get {
               if battleLogBuilder_ != nil {
                  builderResult.battleLog = battleLogBuilder_.getMessage()
               }
               return builderResult.battleLog
           }
           set (value) {
               builderResult.hasBattleLog = true
               builderResult.battleLog = value
           }
      }
      fileprivate var battleLogBuilder_:Pogoprotos.Data.Battle.BattleLog.Builder! {
           didSet {
              builderResult.hasBattleLog = true
           }
      }
      public func getBattleLogBuilder() -> Pogoprotos.Data.Battle.BattleLog.Builder {
        if battleLogBuilder_ == nil {
           battleLogBuilder_ = Pogoprotos.Data.Battle.BattleLog.Builder()
           builderResult.battleLog = battleLogBuilder_.getMessage()
           if battleLog != nil {
              try! battleLogBuilder_.mergeFrom(other: battleLog)
           }
        }
        return battleLogBuilder_
      }
      @discardableResult
      public func setBattleLog(_ value:Pogoprotos.Data.Battle.BattleLog!) -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        self.battleLog = value
        return self
      }
      @discardableResult
      public func mergeBattleLog(value:Pogoprotos.Data.Battle.BattleLog) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        if builderResult.hasBattleLog {
          builderResult.battleLog = try Pogoprotos.Data.Battle.BattleLog.builderWithPrototype(prototype:builderResult.battleLog).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.battleLog = value
        }
        builderResult.hasBattleLog = true
        return self
      }
      @discardableResult
      public func clearBattleLog() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        battleLogBuilder_ = nil
        builderResult.hasBattleLog = false
        builderResult.battleLog = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.StartGymBattleResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        return try Pogoprotos.Networking.Responses.StartGymBattleResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
        let returnMe:Pogoprotos.Networking.Responses.StartGymBattleResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.StartGymBattleResponse) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        if other == Pogoprotos.Networking.Responses.StartGymBattleResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasBattleStartTimestampMs {
             battleStartTimestampMs = other.battleStartTimestampMs
        }
        if other.hasBattleEndTimestampMs {
             battleEndTimestampMs = other.battleEndTimestampMs
        }
        if other.hasBattleId {
             battleId = other.battleId
        }
        if (other.hasDefender) {
            try mergeDefender(value: other.defender)
        }
        if (other.hasBattleLog) {
            try mergeBattleLog(value: other.battleLog)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.StartGymBattleResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 16:
            battleStartTimestampMs = try codedInputStream.readInt64()

          case 24:
            battleEndTimestampMs = try codedInputStream.readInt64()

          case 34:
            battleId = try codedInputStream.readString()

          case 42:
            let subBuilder:Pogoprotos.Data.Battle.BattleParticipant.Builder = Pogoprotos.Data.Battle.BattleParticipant.Builder()
            if hasDefender {
              try subBuilder.mergeFrom(other: defender)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            defender = subBuilder.buildPartial()

          case 50:
            let subBuilder:Pogoprotos.Data.Battle.BattleLog.Builder = Pogoprotos.Data.Battle.BattleLog.Builder()
            if hasBattleLog {
              try subBuilder.mergeFrom(other: battleLog)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            battleLog = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.StartGymBattleResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueBattleStartTimestampMs = jsonMap["battleStartTimestampMs"] as? String {
          resultDecodedBuilder.battleStartTimestampMs = Int64(jsonValueBattleStartTimestampMs)!
        }
        if let jsonValueBattleEndTimestampMs = jsonMap["battleEndTimestampMs"] as? String {
          resultDecodedBuilder.battleEndTimestampMs = Int64(jsonValueBattleEndTimestampMs)!
        }
        if let jsonValueBattleId = jsonMap["battleId"] as? String {
          resultDecodedBuilder.battleId = jsonValueBattleId
        }
        if let jsonValueDefender = jsonMap["defender"] as? Dictionary<String,Any> {
          resultDecodedBuilder.defender = try Pogoprotos.Data.Battle.BattleParticipant.Builder.decodeToBuilder(jsonMap:jsonValueDefender).build()

        }
        if let jsonValueBattleLog = jsonMap["battleLog"] as? Dictionary<String,Any> {
          resultDecodedBuilder.battleLog = try Pogoprotos.Data.Battle.BattleLog.Builder.decodeToBuilder(jsonMap:jsonValueBattleLog).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class UpgradePokemonResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.UpgradePokemonResponse, rhs: Pogoprotos.Networking.Responses.UpgradePokemonResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasUpgradedPokemon == rhs.hasUpgradedPokemon) && (!lhs.hasUpgradedPokemon || lhs.upgradedPokemon == rhs.upgradedPokemon)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case errorPokemonNotFound = 2
        case errorInsufficientResources = 3
        case errorUpgradeNotAvailable = 4
        case errorPokemonIsDeployed = 5
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .errorPokemonNotFound: return "ERROR_POKEMON_NOT_FOUND"
          case .errorInsufficientResources: return "ERROR_INSUFFICIENT_RESOURCES"
          case .errorUpgradeNotAvailable: return "ERROR_UPGRADE_NOT_AVAILABLE"
          case .errorPokemonIsDeployed: return "ERROR_POKEMON_IS_DEPLOYED"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "ERROR_POKEMON_NOT_FOUND":  return .errorPokemonNotFound
          case "ERROR_INSUFFICIENT_RESOURCES":  return .errorInsufficientResources
          case "ERROR_UPGRADE_NOT_AVAILABLE":  return .errorUpgradeNotAvailable
          case "ERROR_POKEMON_IS_DEPLOYED":  return .errorPokemonIsDeployed
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .errorPokemonNotFound: return ".errorPokemonNotFound"
          case .errorInsufficientResources: return ".errorInsufficientResources"
          case .errorUpgradeNotAvailable: return ".errorUpgradeNotAvailable"
          case .errorPokemonIsDeployed: return ".errorPokemonIsDeployed"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.UpgradePokemonResponse.Result = Pogoprotos.Networking.Responses.UpgradePokemonResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var upgradedPokemon:Pogoprotos.Data.PokemonData!
    public fileprivate(set) var hasUpgradedPokemon:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasUpgradedPokemon {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:upgradedPokemon)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasUpgradedPokemon {
          if let varSizeupgradedPokemon = upgradedPokemon?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeupgradedPokemon
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.UpgradePokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UpgradePokemonResponse) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasUpgradedPokemon {
        jsonMap["upgradedPokemon"] = try upgradedPokemon.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasUpgradedPokemon {
        output += "\(indent) upgradedPokemon {\n"
        if let outDescUpgradedPokemon = upgradedPokemon {
          output += try outDescUpgradedPokemon.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasUpgradedPokemon {
                if let hashValueupgradedPokemon = upgradedPokemon?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueupgradedPokemon
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UpgradePokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UpgradePokemonResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.UpgradePokemonResponse = Pogoprotos.Networking.Responses.UpgradePokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.UpgradePokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.UpgradePokemonResponse.Result) -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasUpgradedPokemon:Bool {
           get {
               return builderResult.hasUpgradedPokemon
           }
      }
      public var upgradedPokemon:Pogoprotos.Data.PokemonData! {
           get {
               if upgradedPokemonBuilder_ != nil {
                  builderResult.upgradedPokemon = upgradedPokemonBuilder_.getMessage()
               }
               return builderResult.upgradedPokemon
           }
           set (value) {
               builderResult.hasUpgradedPokemon = true
               builderResult.upgradedPokemon = value
           }
      }
      fileprivate var upgradedPokemonBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasUpgradedPokemon = true
           }
      }
      public func getUpgradedPokemonBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if upgradedPokemonBuilder_ == nil {
           upgradedPokemonBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.upgradedPokemon = upgradedPokemonBuilder_.getMessage()
           if upgradedPokemon != nil {
              try! upgradedPokemonBuilder_.mergeFrom(other: upgradedPokemon)
           }
        }
        return upgradedPokemonBuilder_
      }
      @discardableResult
      public func setUpgradedPokemon(_ value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        self.upgradedPokemon = value
        return self
      }
      @discardableResult
      public func mergeUpgradedPokemon(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        if builderResult.hasUpgradedPokemon {
          builderResult.upgradedPokemon = try Pogoprotos.Data.PokemonData.builderWithPrototype(prototype:builderResult.upgradedPokemon).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.upgradedPokemon = value
        }
        builderResult.hasUpgradedPokemon = true
        return self
      }
      @discardableResult
      public func clearUpgradedPokemon() -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        upgradedPokemonBuilder_ = nil
        builderResult.hasUpgradedPokemon = false
        builderResult.upgradedPokemon = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UpgradePokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.UpgradePokemonResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UpgradePokemonResponse) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UpgradePokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasUpgradedPokemon) {
            try mergeUpgradedPokemon(value: other.upgradedPokemon)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.UpgradePokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasUpgradedPokemon {
              try subBuilder.mergeFrom(other: upgradedPokemon)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            upgradedPokemon = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueUpgradedPokemon = jsonMap["upgradedPokemon"] as? Dictionary<String,Any> {
          resultDecodedBuilder.upgradedPokemon = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonMap:jsonValueUpgradedPokemon).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class UseIncenseResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.UseIncenseResponse, rhs: Pogoprotos.Networking.Responses.UseIncenseResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasAppliedIncense == rhs.hasAppliedIncense) && (!lhs.hasAppliedIncense || lhs.appliedIncense == rhs.appliedIncense)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unknown = 0
        case success = 1
        case incenseAlreadyActive = 2
        case noneInInventory = 3
        case locationUnset = 4
        public func toString() -> String {
          switch self {
          case .unknown: return "UNKNOWN"
          case .success: return "SUCCESS"
          case .incenseAlreadyActive: return "INCENSE_ALREADY_ACTIVE"
          case .noneInInventory: return "NONE_IN_INVENTORY"
          case .locationUnset: return "LOCATION_UNSET"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Result {
          switch str {
          case "UNKNOWN":  return .unknown
          case "SUCCESS":  return .success
          case "INCENSE_ALREADY_ACTIVE":  return .incenseAlreadyActive
          case "NONE_IN_INVENTORY":  return .noneInInventory
          case "LOCATION_UNSET":  return .locationUnset
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unknown: return ".unknown"
          case .success: return ".success"
          case .incenseAlreadyActive: return ".incenseAlreadyActive"
          case .noneInInventory: return ".noneInInventory"
          case .locationUnset: return ".locationUnset"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.UseIncenseResponse.Result = Pogoprotos.Networking.Responses.UseIncenseResponse.Result.unknown
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var appliedIncense:Pogoprotos.Inventory.AppliedItem!
    public fileprivate(set) var hasAppliedIncense:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasAppliedIncense {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:appliedIncense)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasAppliedIncense {
          if let varSizeappliedIncense = appliedIncense?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeappliedIncense
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
      return Pogoprotos.Networking.Responses.UseIncenseResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseIncenseResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseIncenseResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UseIncenseResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UseIncenseResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseIncenseResponse) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasAppliedIncense {
        jsonMap["appliedIncense"] = try appliedIncense.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasAppliedIncense {
        output += "\(indent) appliedIncense {\n"
        if let outDescAppliedIncense = appliedIncense {
          output += try outDescAppliedIncense.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasAppliedIncense {
                if let hashValueappliedIncense = appliedIncense?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueappliedIncense
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseIncenseResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseIncenseResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.UseIncenseResponse = Pogoprotos.Networking.Responses.UseIncenseResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseIncenseResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.UseIncenseResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.UseIncenseResponse.Result) -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unknown
           return self
        }
      public var hasAppliedIncense:Bool {
           get {
               return builderResult.hasAppliedIncense
           }
      }
      public var appliedIncense:Pogoprotos.Inventory.AppliedItem! {
           get {
               if appliedIncenseBuilder_ != nil {
                  builderResult.appliedIncense = appliedIncenseBuilder_.getMessage()
               }
               return builderResult.appliedIncense
           }
           set (value) {
               builderResult.hasAppliedIncense = true
               builderResult.appliedIncense = value
           }
      }
      fileprivate var appliedIncenseBuilder_:Pogoprotos.Inventory.AppliedItem.Builder! {
           didSet {
              builderResult.hasAppliedIncense = true
           }
      }
      public func getAppliedIncenseBuilder() -> Pogoprotos.Inventory.AppliedItem.Builder {
        if appliedIncenseBuilder_ == nil {
           appliedIncenseBuilder_ = Pogoprotos.Inventory.AppliedItem.Builder()
           builderResult.appliedIncense = appliedIncenseBuilder_.getMessage()
           if appliedIncense != nil {
              try! appliedIncenseBuilder_.mergeFrom(other: appliedIncense)
           }
        }
        return appliedIncenseBuilder_
      }
      @discardableResult
      public func setAppliedIncense(_ value:Pogoprotos.Inventory.AppliedItem!) -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        self.appliedIncense = value
        return self
      }
      @discardableResult
      public func mergeAppliedIncense(value:Pogoprotos.Inventory.AppliedItem) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        if builderResult.hasAppliedIncense {
          builderResult.appliedIncense = try Pogoprotos.Inventory.AppliedItem.builderWithPrototype(prototype:builderResult.appliedIncense).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.appliedIncense = value
        }
        builderResult.hasAppliedIncense = true
        return self
      }
      @discardableResult
      public func clearAppliedIncense() -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        appliedIncenseBuilder_ = nil
        builderResult.hasAppliedIncense = false
        builderResult.appliedIncense = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseIncenseResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseIncenseResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseIncenseResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseIncenseResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseIncenseResponse) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseIncenseResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasAppliedIncense) {
            try mergeAppliedIncense(value: other.appliedIncense)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.UseIncenseResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Inventory.AppliedItem.Builder = Pogoprotos.Inventory.AppliedItem.Builder()
            if hasAppliedIncense {
              try subBuilder.mergeFrom(other: appliedIncense)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            appliedIncense = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseIncenseResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.UseIncenseResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueAppliedIncense = jsonMap["appliedIncense"] as? Dictionary<String,Any> {
          resultDecodedBuilder.appliedIncense = try Pogoprotos.Inventory.AppliedItem.Builder.decodeToBuilder(jsonMap:jsonValueAppliedIncense).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class UseItemCaptureResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.UseItemCaptureResponse, rhs: Pogoprotos.Networking.Responses.UseItemCaptureResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
      fieldCheck = fieldCheck && (lhs.hasItemCaptureMult == rhs.hasItemCaptureMult) && (!lhs.hasItemCaptureMult || lhs.itemCaptureMult == rhs.itemCaptureMult)
      fieldCheck = fieldCheck && (lhs.hasItemFleeMult == rhs.hasItemFleeMult) && (!lhs.hasItemFleeMult || lhs.itemFleeMult == rhs.itemFleeMult)
      fieldCheck = fieldCheck && (lhs.hasStopMovement == rhs.hasStopMovement) && (!lhs.hasStopMovement || lhs.stopMovement == rhs.stopMovement)
      fieldCheck = fieldCheck && (lhs.hasStopAttack == rhs.hasStopAttack) && (!lhs.hasStopAttack || lhs.stopAttack == rhs.stopAttack)
      fieldCheck = fieldCheck && (lhs.hasTargetMax == rhs.hasTargetMax) && (!lhs.hasTargetMax || lhs.targetMax == rhs.targetMax)
      fieldCheck = fieldCheck && (lhs.hasTargetSlow == rhs.hasTargetSlow) && (!lhs.hasTargetSlow || lhs.targetSlow == rhs.targetSlow)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var success:Bool = false
    public fileprivate(set) var hasSuccess:Bool = false

    public fileprivate(set) var itemCaptureMult:Double = Double(0)
    public fileprivate(set) var hasItemCaptureMult:Bool = false

    public fileprivate(set) var itemFleeMult:Double = Double(0)
    public fileprivate(set) var hasItemFleeMult:Bool = false

    public fileprivate(set) var stopMovement:Bool = false
    public fileprivate(set) var hasStopMovement:Bool = false

    public fileprivate(set) var stopAttack:Bool = false
    public fileprivate(set) var hasStopAttack:Bool = false

    public fileprivate(set) var targetMax:Bool = false
    public fileprivate(set) var hasTargetMax:Bool = false

    public fileprivate(set) var targetSlow:Bool = false
    public fileprivate(set) var hasTargetSlow:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasSuccess {
        try codedOutputStream.writeBool(fieldNumber: 1, value:success)
      }
      if hasItemCaptureMult {
        try codedOutputStream.writeDouble(fieldNumber: 2, value:itemCaptureMult)
      }
      if hasItemFleeMult {
        try codedOutputStream.writeDouble(fieldNumber: 3, value:itemFleeMult)
      }
      if hasStopMovement {
        try codedOutputStream.writeBool(fieldNumber: 4, value:stopMovement)
      }
      if hasStopAttack {
        try codedOutputStream.writeBool(fieldNumber: 5, value:stopAttack)
      }
      if hasTargetMax {
        try codedOutputStream.writeBool(fieldNumber: 6, value:targetMax)
      }
      if hasTargetSlow {
        try codedOutputStream.writeBool(fieldNumber: 7, value:targetSlow)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(fieldNumber: 1)
      }
      if hasItemCaptureMult {
        serialize_size += itemCaptureMult.computeDoubleSize(fieldNumber: 2)
      }
      if hasItemFleeMult {
        serialize_size += itemFleeMult.computeDoubleSize(fieldNumber: 3)
      }
      if hasStopMovement {
        serialize_size += stopMovement.computeBoolSize(fieldNumber: 4)
      }
      if hasStopAttack {
        serialize_size += stopAttack.computeBoolSize(fieldNumber: 5)
      }
      if hasTargetMax {
        serialize_size += targetMax.computeBoolSize(fieldNumber: 6)
      }
      if hasTargetSlow {
        serialize_size += targetSlow.computeBoolSize(fieldNumber: 7)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
      return Pogoprotos.Networking.Responses.UseItemCaptureResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseItemCaptureResponse) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if hasItemCaptureMult {
        jsonMap["itemCaptureMult"] = Double(itemCaptureMult)
      }
      if hasItemFleeMult {
        jsonMap["itemFleeMult"] = Double(itemFleeMult)
      }
      if hasStopMovement {
        jsonMap["stopMovement"] = stopMovement
      }
      if hasStopAttack {
        jsonMap["stopAttack"] = stopAttack
      }
      if hasTargetMax {
        jsonMap["targetMax"] = targetMax
      }
      if hasTargetSlow {
        jsonMap["targetSlow"] = targetSlow
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      if hasItemCaptureMult {
        output += "\(indent) itemCaptureMult: \(itemCaptureMult) \n"
      }
      if hasItemFleeMult {
        output += "\(indent) itemFleeMult: \(itemFleeMult) \n"
      }
      if hasStopMovement {
        output += "\(indent) stopMovement: \(stopMovement) \n"
      }
      if hasStopAttack {
        output += "\(indent) stopAttack: \(stopAttack) \n"
      }
      if hasTargetMax {
        output += "\(indent) targetMax: \(targetMax) \n"
      }
      if hasTargetSlow {
        output += "\(indent) targetSlow: \(targetSlow) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            if hasItemCaptureMult {
               hashCode = (hashCode &* 31) &+ itemCaptureMult.hashValue
            }
            if hasItemFleeMult {
               hashCode = (hashCode &* 31) &+ itemFleeMult.hashValue
            }
            if hasStopMovement {
               hashCode = (hashCode &* 31) &+ stopMovement.hashValue
            }
            if hasStopAttack {
               hashCode = (hashCode &* 31) &+ stopAttack.hashValue
            }
            if hasTargetMax {
               hashCode = (hashCode &* 31) &+ targetMax.hashValue
            }
            if hasTargetSlow {
               hashCode = (hashCode &* 31) &+ targetSlow.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemCaptureResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemCaptureResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.UseItemCaptureResponse = Pogoprotos.Networking.Responses.UseItemCaptureResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      @discardableResult
      public func setSuccess(_ value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.success = value
        return self
      }
      @discardableResult
      public func clearSuccess() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var hasItemCaptureMult:Bool {
           get {
                return builderResult.hasItemCaptureMult
           }
      }
      public var itemCaptureMult:Double {
           get {
                return builderResult.itemCaptureMult
           }
           set (value) {
               builderResult.hasItemCaptureMult = true
               builderResult.itemCaptureMult = value
           }
      }
      @discardableResult
      public func setItemCaptureMult(_ value:Double) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.itemCaptureMult = value
        return self
      }
      @discardableResult
      public func clearItemCaptureMult() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasItemCaptureMult = false
           builderResult.itemCaptureMult = Double(0)
           return self
      }
      public var hasItemFleeMult:Bool {
           get {
                return builderResult.hasItemFleeMult
           }
      }
      public var itemFleeMult:Double {
           get {
                return builderResult.itemFleeMult
           }
           set (value) {
               builderResult.hasItemFleeMult = true
               builderResult.itemFleeMult = value
           }
      }
      @discardableResult
      public func setItemFleeMult(_ value:Double) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.itemFleeMult = value
        return self
      }
      @discardableResult
      public func clearItemFleeMult() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasItemFleeMult = false
           builderResult.itemFleeMult = Double(0)
           return self
      }
      public var hasStopMovement:Bool {
           get {
                return builderResult.hasStopMovement
           }
      }
      public var stopMovement:Bool {
           get {
                return builderResult.stopMovement
           }
           set (value) {
               builderResult.hasStopMovement = true
               builderResult.stopMovement = value
           }
      }
      @discardableResult
      public func setStopMovement(_ value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.stopMovement = value
        return self
      }
      @discardableResult
      public func clearStopMovement() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasStopMovement = false
           builderResult.stopMovement = false
           return self
      }
      public var hasStopAttack:Bool {
           get {
                return builderResult.hasStopAttack
           }
      }
      public var stopAttack:Bool {
           get {
                return builderResult.stopAttack
           }
           set (value) {
               builderResult.hasStopAttack = true
               builderResult.stopAttack = value
           }
      }
      @discardableResult
      public func setStopAttack(_ value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.stopAttack = value
        return self
      }
      @discardableResult
      public func clearStopAttack() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasStopAttack = false
           builderResult.stopAttack = false
           return self
      }
      public var hasTargetMax:Bool {
           get {
                return builderResult.hasTargetMax
           }
      }
      public var targetMax:Bool {
           get {
                return builderResult.targetMax
           }
           set (value) {
               builderResult.hasTargetMax = true
               builderResult.targetMax = value
           }
      }
      @discardableResult
      public func setTargetMax(_ value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.targetMax = value
        return self
      }
      @discardableResult
      public func clearTargetMax() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasTargetMax = false
           builderResult.targetMax = false
           return self
      }
      public var hasTargetSlow:Bool {
           get {
                return builderResult.hasTargetSlow
           }
      }
      public var targetSlow:Bool {
           get {
                return builderResult.targetSlow
           }
           set (value) {
               builderResult.hasTargetSlow = true
               builderResult.targetSlow = value
           }
      }
      @discardableResult
      public func setTargetSlow(_ value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.targetSlow = value
        return self
      }
      @discardableResult
      public func clearTargetSlow() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasTargetSlow = false
           builderResult.targetSlow = false
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseItemCaptureResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseItemCaptureResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseItemCaptureResponse) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseItemCaptureResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if other.hasItemCaptureMult {
             itemCaptureMult = other.itemCaptureMult
        }
        if other.hasItemFleeMult {
             itemFleeMult = other.itemFleeMult
        }
        if other.hasStopMovement {
             stopMovement = other.stopMovement
        }
        if other.hasStopAttack {
             stopAttack = other.stopAttack
        }
        if other.hasTargetMax {
             targetMax = other.targetMax
        }
        if other.hasTargetSlow {
             targetSlow = other.targetSlow
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try codedInputStream.readBool()

          case 17:
            itemCaptureMult = try codedInputStream.readDouble()

          case 25:
            itemFleeMult = try codedInputStream.readDouble()

          case 32:
            stopMovement = try codedInputStream.readBool()

          case 40:
            stopAttack = try codedInputStream.readBool()

          case 48:
            targetMax = try codedInputStream.readBool()

          case 56:
            targetSlow = try codedInputStream.readBool()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValueItemCaptureMult = jsonMap["itemCaptureMult"] as? Double {
          resultDecodedBuilder.itemCaptureMult = Double(jsonValueItemCaptureMult)
        }
        if let jsonValueItemFleeMult = jsonMap["itemFleeMult"] as? Double {
          resultDecodedBuilder.itemFleeMult = Double(jsonValueItemFleeMult)
        }
        if let jsonValueStopMovement = jsonMap["stopMovement"] as? Bool {
          resultDecodedBuilder.stopMovement = jsonValueStopMovement
        }
        if let jsonValueStopAttack = jsonMap["stopAttack"] as? Bool {
          resultDecodedBuilder.stopAttack = jsonValueStopAttack
        }
        if let jsonValueTargetMax = jsonMap["targetMax"] as? Bool {
          resultDecodedBuilder.targetMax = jsonValueTargetMax
        }
        if let jsonValueTargetSlow = jsonMap["targetSlow"] as? Bool {
          resultDecodedBuilder.targetSlow = jsonValueTargetSlow
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class UseItemEggIncubatorResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse, rhs: Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasEggIncubator == rhs.hasEggIncubator) && (!lhs.hasEggIncubator || lhs.eggIncubator == rhs.eggIncubator)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case errorIncubatorNotFound = 2
        case errorPokemonEggNotFound = 3
        case errorPokemonIdNotEgg = 4
        case errorIncubatorAlreadyInUse = 5
        case errorPokemonAlreadyIncubating = 6
        case errorIncubatorNoUsesRemaining = 7
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .errorIncubatorNotFound: return "ERROR_INCUBATOR_NOT_FOUND"
          case .errorPokemonEggNotFound: return "ERROR_POKEMON_EGG_NOT_FOUND"
          case .errorPokemonIdNotEgg: return "ERROR_POKEMON_ID_NOT_EGG"
          case .errorIncubatorAlreadyInUse: return "ERROR_INCUBATOR_ALREADY_IN_USE"
          case .errorPokemonAlreadyIncubating: return "ERROR_POKEMON_ALREADY_INCUBATING"
          case .errorIncubatorNoUsesRemaining: return "ERROR_INCUBATOR_NO_USES_REMAINING"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "ERROR_INCUBATOR_NOT_FOUND":  return .errorIncubatorNotFound
          case "ERROR_POKEMON_EGG_NOT_FOUND":  return .errorPokemonEggNotFound
          case "ERROR_POKEMON_ID_NOT_EGG":  return .errorPokemonIdNotEgg
          case "ERROR_INCUBATOR_ALREADY_IN_USE":  return .errorIncubatorAlreadyInUse
          case "ERROR_POKEMON_ALREADY_INCUBATING":  return .errorPokemonAlreadyIncubating
          case "ERROR_INCUBATOR_NO_USES_REMAINING":  return .errorIncubatorNoUsesRemaining
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .errorIncubatorNotFound: return ".errorIncubatorNotFound"
          case .errorPokemonEggNotFound: return ".errorPokemonEggNotFound"
          case .errorPokemonIdNotEgg: return ".errorPokemonIdNotEgg"
          case .errorIncubatorAlreadyInUse: return ".errorIncubatorAlreadyInUse"
          case .errorPokemonAlreadyIncubating: return ".errorPokemonAlreadyIncubating"
          case .errorIncubatorNoUsesRemaining: return ".errorIncubatorNoUsesRemaining"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Result = Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var eggIncubator:Pogoprotos.Inventory.EggIncubator!
    public fileprivate(set) var hasEggIncubator:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasEggIncubator {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:eggIncubator)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasEggIncubator {
          if let varSizeeggIncubator = eggIncubator?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeeggIncubator
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
      return Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasEggIncubator {
        jsonMap["eggIncubator"] = try eggIncubator.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasEggIncubator {
        output += "\(indent) eggIncubator {\n"
        if let outDescEggIncubator = eggIncubator {
          output += try outDescEggIncubator.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasEggIncubator {
                if let hashValueeggIncubator = eggIncubator?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueeggIncubator
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse = Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Result) -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasEggIncubator:Bool {
           get {
               return builderResult.hasEggIncubator
           }
      }
      public var eggIncubator:Pogoprotos.Inventory.EggIncubator! {
           get {
               if eggIncubatorBuilder_ != nil {
                  builderResult.eggIncubator = eggIncubatorBuilder_.getMessage()
               }
               return builderResult.eggIncubator
           }
           set (value) {
               builderResult.hasEggIncubator = true
               builderResult.eggIncubator = value
           }
      }
      fileprivate var eggIncubatorBuilder_:Pogoprotos.Inventory.EggIncubator.Builder! {
           didSet {
              builderResult.hasEggIncubator = true
           }
      }
      public func getEggIncubatorBuilder() -> Pogoprotos.Inventory.EggIncubator.Builder {
        if eggIncubatorBuilder_ == nil {
           eggIncubatorBuilder_ = Pogoprotos.Inventory.EggIncubator.Builder()
           builderResult.eggIncubator = eggIncubatorBuilder_.getMessage()
           if eggIncubator != nil {
              try! eggIncubatorBuilder_.mergeFrom(other: eggIncubator)
           }
        }
        return eggIncubatorBuilder_
      }
      @discardableResult
      public func setEggIncubator(_ value:Pogoprotos.Inventory.EggIncubator!) -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        self.eggIncubator = value
        return self
      }
      @discardableResult
      public func mergeEggIncubator(value:Pogoprotos.Inventory.EggIncubator) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        if builderResult.hasEggIncubator {
          builderResult.eggIncubator = try Pogoprotos.Inventory.EggIncubator.builderWithPrototype(prototype:builderResult.eggIncubator).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.eggIncubator = value
        }
        builderResult.hasEggIncubator = true
        return self
      }
      @discardableResult
      public func clearEggIncubator() -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        eggIncubatorBuilder_ = nil
        builderResult.hasEggIncubator = false
        builderResult.eggIncubator = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasEggIncubator) {
            try mergeEggIncubator(value: other.eggIncubator)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Inventory.EggIncubator.Builder = Pogoprotos.Inventory.EggIncubator.Builder()
            if hasEggIncubator {
              try subBuilder.mergeFrom(other: eggIncubator)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            eggIncubator = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueEggIncubator = jsonMap["eggIncubator"] as? Dictionary<String,Any> {
          resultDecodedBuilder.eggIncubator = try Pogoprotos.Inventory.EggIncubator.Builder.decodeToBuilder(jsonMap:jsonValueEggIncubator).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class UseItemGymResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.UseItemGymResponse, rhs: Pogoprotos.Networking.Responses.UseItemGymResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasUpdatedGp == rhs.hasUpdatedGp) && (!lhs.hasUpdatedGp || lhs.updatedGp == rhs.updatedGp)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case errorCannotUse = 2
        case errorNotInRange = 3
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .errorCannotUse: return "ERROR_CANNOT_USE"
          case .errorNotInRange: return "ERROR_NOT_IN_RANGE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "ERROR_CANNOT_USE":  return .errorCannotUse
          case "ERROR_NOT_IN_RANGE":  return .errorNotInRange
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .errorCannotUse: return ".errorCannotUse"
          case .errorNotInRange: return ".errorNotInRange"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.UseItemGymResponse.Result = Pogoprotos.Networking.Responses.UseItemGymResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    // Gym Points (?)
    public fileprivate(set) var updatedGp:Int64 = Int64(0)
    public fileprivate(set) var hasUpdatedGp:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasUpdatedGp {
        try codedOutputStream.writeInt64(fieldNumber: 2, value:updatedGp)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasUpdatedGp {
        serialize_size += updatedGp.computeInt64Size(fieldNumber: 2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
      return Pogoprotos.Networking.Responses.UseItemGymResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseItemGymResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseItemGymResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemGymResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemGymResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseItemGymResponse) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasUpdatedGp {
        jsonMap["updatedGp"] = "\(updatedGp)"
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasUpdatedGp {
        output += "\(indent) updatedGp: \(updatedGp) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasUpdatedGp {
               hashCode = (hashCode &* 31) &+ updatedGp.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemGymResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemGymResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.UseItemGymResponse = Pogoprotos.Networking.Responses.UseItemGymResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseItemGymResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.UseItemGymResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.UseItemGymResponse.Result) -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasUpdatedGp:Bool {
           get {
                return builderResult.hasUpdatedGp
           }
      }
      public var updatedGp:Int64 {
           get {
                return builderResult.updatedGp
           }
           set (value) {
               builderResult.hasUpdatedGp = true
               builderResult.updatedGp = value
           }
      }
      @discardableResult
      public func setUpdatedGp(_ value:Int64) -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
        self.updatedGp = value
        return self
      }
      @discardableResult
      public func clearUpdatedGp() -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder{
           builderResult.hasUpdatedGp = false
           builderResult.updatedGp = Int64(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseItemGymResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseItemGymResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseItemGymResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseItemGymResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseItemGymResponse) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseItemGymResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasUpdatedGp {
             updatedGp = other.updatedGp
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.UseItemGymResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 16:
            updatedGp = try codedInputStream.readInt64()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseItemGymResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.UseItemGymResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueUpdatedGp = jsonMap["updatedGp"] as? String {
          resultDecodedBuilder.updatedGp = Int64(jsonValueUpdatedGp)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class UseItemPotionResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.UseItemPotionResponse, rhs: Pogoprotos.Networking.Responses.UseItemPotionResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasStamina == rhs.hasStamina) && (!lhs.hasStamina || lhs.stamina == rhs.stamina)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case errorNoPokemon = 2
        case errorCannotUse = 3
        case errorDeployedToFort = 4
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .errorNoPokemon: return "ERROR_NO_POKEMON"
          case .errorCannotUse: return "ERROR_CANNOT_USE"
          case .errorDeployedToFort: return "ERROR_DEPLOYED_TO_FORT"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "ERROR_NO_POKEMON":  return .errorNoPokemon
          case "ERROR_CANNOT_USE":  return .errorCannotUse
          case "ERROR_DEPLOYED_TO_FORT":  return .errorDeployedToFort
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .errorNoPokemon: return ".errorNoPokemon"
          case .errorCannotUse: return ".errorCannotUse"
          case .errorDeployedToFort: return ".errorDeployedToFort"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.UseItemPotionResponse.Result = Pogoprotos.Networking.Responses.UseItemPotionResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var stamina:Int32 = Int32(0)
    public fileprivate(set) var hasStamina:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasStamina {
        try codedOutputStream.writeInt32(fieldNumber: 2, value:stamina)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasStamina {
        serialize_size += stamina.computeInt32Size(fieldNumber: 2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
      return Pogoprotos.Networking.Responses.UseItemPotionResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseItemPotionResponse) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasStamina {
        jsonMap["stamina"] = Int(stamina)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasStamina {
        output += "\(indent) stamina: \(stamina) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasStamina {
               hashCode = (hashCode &* 31) &+ stamina.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemPotionResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemPotionResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.UseItemPotionResponse = Pogoprotos.Networking.Responses.UseItemPotionResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.UseItemPotionResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.UseItemPotionResponse.Result) -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasStamina:Bool {
           get {
                return builderResult.hasStamina
           }
      }
      public var stamina:Int32 {
           get {
                return builderResult.stamina
           }
           set (value) {
               builderResult.hasStamina = true
               builderResult.stamina = value
           }
      }
      @discardableResult
      public func setStamina(_ value:Int32) -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
        self.stamina = value
        return self
      }
      @discardableResult
      public func clearStamina() -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder{
           builderResult.hasStamina = false
           builderResult.stamina = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseItemPotionResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseItemPotionResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseItemPotionResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseItemPotionResponse) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseItemPotionResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasStamina {
             stamina = other.stamina
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.UseItemPotionResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 16:
            stamina = try codedInputStream.readInt32()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.UseItemPotionResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueStamina = jsonMap["stamina"] as? Int {
          resultDecodedBuilder.stamina = Int32(jsonValueStamina)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class UseItemReviveResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.UseItemReviveResponse, rhs: Pogoprotos.Networking.Responses.UseItemReviveResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasStamina == rhs.hasStamina) && (!lhs.hasStamina || lhs.stamina == rhs.stamina)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case errorNoPokemon = 2
        case errorCannotUse = 3
        case errorDeployedToFort = 4
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .errorNoPokemon: return "ERROR_NO_POKEMON"
          case .errorCannotUse: return "ERROR_CANNOT_USE"
          case .errorDeployedToFort: return "ERROR_DEPLOYED_TO_FORT"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "ERROR_NO_POKEMON":  return .errorNoPokemon
          case "ERROR_CANNOT_USE":  return .errorCannotUse
          case "ERROR_DEPLOYED_TO_FORT":  return .errorDeployedToFort
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .errorNoPokemon: return ".errorNoPokemon"
          case .errorCannotUse: return ".errorCannotUse"
          case .errorDeployedToFort: return ".errorDeployedToFort"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.UseItemReviveResponse.Result = Pogoprotos.Networking.Responses.UseItemReviveResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var stamina:Int32 = Int32(0)
    public fileprivate(set) var hasStamina:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasStamina {
        try codedOutputStream.writeInt32(fieldNumber: 2, value:stamina)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasStamina {
        serialize_size += stamina.computeInt32Size(fieldNumber: 2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
      return Pogoprotos.Networking.Responses.UseItemReviveResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseItemReviveResponse) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasStamina {
        jsonMap["stamina"] = Int(stamina)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasStamina {
        output += "\(indent) stamina: \(stamina) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasStamina {
               hashCode = (hashCode &* 31) &+ stamina.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemReviveResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemReviveResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.UseItemReviveResponse = Pogoprotos.Networking.Responses.UseItemReviveResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.UseItemReviveResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.UseItemReviveResponse.Result) -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasStamina:Bool {
           get {
                return builderResult.hasStamina
           }
      }
      public var stamina:Int32 {
           get {
                return builderResult.stamina
           }
           set (value) {
               builderResult.hasStamina = true
               builderResult.stamina = value
           }
      }
      @discardableResult
      public func setStamina(_ value:Int32) -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
        self.stamina = value
        return self
      }
      @discardableResult
      public func clearStamina() -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder{
           builderResult.hasStamina = false
           builderResult.stamina = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseItemReviveResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseItemReviveResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseItemReviveResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseItemReviveResponse) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseItemReviveResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasStamina {
             stamina = other.stamina
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.UseItemReviveResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 16:
            stamina = try codedInputStream.readInt32()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.UseItemReviveResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueStamina = jsonMap["stamina"] as? Int {
          resultDecodedBuilder.stamina = Int32(jsonValueStamina)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class UseItemXpBoostResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.UseItemXpBoostResponse, rhs: Pogoprotos.Networking.Responses.UseItemXpBoostResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
      fieldCheck = fieldCheck && (lhs.hasAppliedItems == rhs.hasAppliedItems) && (!lhs.hasAppliedItems || lhs.appliedItems == rhs.appliedItems)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }



      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case unset = 0
        case success = 1
        case errorInvalidItemType = 2
        case errorXpBoostAlreadyActive = 3
        case errorNoItemsRemaining = 4
        case errorLocationUnset = 5
        public func toString() -> String {
          switch self {
          case .unset: return "UNSET"
          case .success: return "SUCCESS"
          case .errorInvalidItemType: return "ERROR_INVALID_ITEM_TYPE"
          case .errorXpBoostAlreadyActive: return "ERROR_XP_BOOST_ALREADY_ACTIVE"
          case .errorNoItemsRemaining: return "ERROR_NO_ITEMS_REMAINING"
          case .errorLocationUnset: return "ERROR_LOCATION_UNSET"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Result {
          switch str {
          case "UNSET":  return .unset
          case "SUCCESS":  return .success
          case "ERROR_INVALID_ITEM_TYPE":  return .errorInvalidItemType
          case "ERROR_XP_BOOST_ALREADY_ACTIVE":  return .errorXpBoostAlreadyActive
          case "ERROR_NO_ITEMS_REMAINING":  return .errorNoItemsRemaining
          case "ERROR_LOCATION_UNSET":  return .errorLocationUnset
          default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
          switch self {
          case .unset: return ".unset"
          case .success: return ".success"
          case .errorInvalidItemType: return ".errorInvalidItemType"
          case .errorXpBoostAlreadyActive: return ".errorXpBoostAlreadyActive"
          case .errorNoItemsRemaining: return ".errorNoItemsRemaining"
          case .errorLocationUnset: return ".errorLocationUnset"
          }
        }
      }

      //Enum type declaration end 

    public fileprivate(set) var result:Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Result = Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Result.unset
    public fileprivate(set) var hasResult:Bool = false
    public fileprivate(set) var appliedItems:Pogoprotos.Inventory.AppliedItems!
    public fileprivate(set) var hasAppliedItems:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasResult {
        try codedOutputStream.writeEnum(fieldNumber: 1, value:result.rawValue)
      }
      if hasAppliedItems {
        try codedOutputStream.writeMessage(fieldNumber: 2, value:appliedItems)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(fieldNumber: 1)
      }
      if hasAppliedItems {
          if let varSizeappliedItems = appliedItems?.computeMessageSize(fieldNumber: 2) {
              serialize_size += varSizeappliedItems
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
      return Pogoprotos.Networking.Responses.UseItemXpBoostResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseItemXpBoostResponse) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasAppliedItems {
        jsonMap["appliedItems"] = try appliedItems.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasAppliedItems {
        output += "\(indent) appliedItems {\n"
        if let outDescAppliedItems = appliedItems {
          output += try outDescAppliedItems.getDescription(indent: "\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasAppliedItems {
                if let hashValueappliedItems = appliedItems?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueappliedItems
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemXpBoostResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemXpBoostResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.UseItemXpBoostResponse = Pogoprotos.Networking.Responses.UseItemXpBoostResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
      @discardableResult
        public func setResult(_ value:Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Result) -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
          self.result = value
          return self
        }
      @discardableResult
        public func clearResult() -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .unset
           return self
        }
      public var hasAppliedItems:Bool {
           get {
               return builderResult.hasAppliedItems
           }
      }
      public var appliedItems:Pogoprotos.Inventory.AppliedItems! {
           get {
               if appliedItemsBuilder_ != nil {
                  builderResult.appliedItems = appliedItemsBuilder_.getMessage()
               }
               return builderResult.appliedItems
           }
           set (value) {
               builderResult.hasAppliedItems = true
               builderResult.appliedItems = value
           }
      }
      fileprivate var appliedItemsBuilder_:Pogoprotos.Inventory.AppliedItems.Builder! {
           didSet {
              builderResult.hasAppliedItems = true
           }
      }
      public func getAppliedItemsBuilder() -> Pogoprotos.Inventory.AppliedItems.Builder {
        if appliedItemsBuilder_ == nil {
           appliedItemsBuilder_ = Pogoprotos.Inventory.AppliedItems.Builder()
           builderResult.appliedItems = appliedItemsBuilder_.getMessage()
           if appliedItems != nil {
              try! appliedItemsBuilder_.mergeFrom(other: appliedItems)
           }
        }
        return appliedItemsBuilder_
      }
      @discardableResult
      public func setAppliedItems(_ value:Pogoprotos.Inventory.AppliedItems!) -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        self.appliedItems = value
        return self
      }
      @discardableResult
      public func mergeAppliedItems(value:Pogoprotos.Inventory.AppliedItems) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        if builderResult.hasAppliedItems {
          builderResult.appliedItems = try Pogoprotos.Inventory.AppliedItems.builderWithPrototype(prototype:builderResult.appliedItems).mergeFrom(other: value).buildPartial()
        } else {
          builderResult.appliedItems = value
        }
        builderResult.hasAppliedItems = true
        return self
      }
      @discardableResult
      public func clearAppliedItems() -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        appliedItemsBuilder_ = nil
        builderResult.hasAppliedItems = false
        builderResult.appliedItems = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseItemXpBoostResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseItemXpBoostResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseItemXpBoostResponse) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseItemXpBoostResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasAppliedItems) {
            try mergeAppliedItems(value: other.appliedItems)
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try codedInputStream.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 _ = try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Inventory.AppliedItems.Builder = Pogoprotos.Inventory.AppliedItems.Builder()
            if hasAppliedItems {
              try subBuilder.mergeFrom(other: appliedItems)
            }
            try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
            appliedItems = subBuilder.buildPartial()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Result.fromString(str: jsonValueResult)
        }
        if let jsonValueAppliedItems = jsonMap["appliedItems"] as? Dictionary<String,Any> {
          resultDecodedBuilder.appliedItems = try Pogoprotos.Inventory.AppliedItems.Builder.decodeToBuilder(jsonMap:jsonValueAppliedItems).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

  final public class VerifyChallengeResponse : GeneratedMessage {

    public static func == (lhs: Pogoprotos.Networking.Responses.VerifyChallengeResponse, rhs: Pogoprotos.Networking.Responses.VerifyChallengeResponse) -> Bool {
      if (lhs === rhs) {
        return true
      }
      var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
      fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
      fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
      return fieldCheck
    }

    public fileprivate(set) var success:Bool = false
    public fileprivate(set) var hasSuccess:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
      if hasSuccess {
        try codedOutputStream.writeBool(fieldNumber: 1, value:success)
      }
      try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(fieldNumber: 1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder {
      return Pogoprotos.Networking.Responses.VerifyChallengeResponse.classBuilder() as! Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
      return Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder {
      return try Pogoprotos.Networking.Responses.VerifyChallengeResponse.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.VerifyChallengeResponse) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder {
      return try Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
      guard isInitialized() else {
        throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse {
      return try Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse {
      return try Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      output += unknownFields.getDescription(indent: indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.VerifyChallengeResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.VerifyChallengeResponse"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      fileprivate var builderResult:Pogoprotos.Networking.Responses.VerifyChallengeResponse = Pogoprotos.Networking.Responses.VerifyChallengeResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.VerifyChallengeResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      @discardableResult
      public func setSuccess(_ value:Bool) -> Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder {
        self.success = value
        return self
      }
      @discardableResult
      public func clearSuccess() -> Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      @discardableResult
      override public func clear() -> Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.VerifyChallengeResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder {
        return try Pogoprotos.Networking.Responses.VerifyChallengeResponse.builderWithPrototype(prototype:builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.VerifyChallengeResponse {
        let returnMe:Pogoprotos.Networking.Responses.VerifyChallengeResponse = builderResult
        return returnMe
      }
      @discardableResult
      public func mergeFrom(other:Pogoprotos.Networking.Responses.VerifyChallengeResponse) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder {
        if other == Pogoprotos.Networking.Responses.VerifyChallengeResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        _ = try merge(unknownField: other.unknownFields)
        return self
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder {
           return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
      }
      @discardableResult
      override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
        while (true) {
          let protobufTag = try codedInputStream.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try codedInputStream.readBool()

          default:
            if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      class public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:Data) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder {
        let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
          throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder.decodeToBuilder(jsonMap:jsDataCast)
      }
    }

  }

}
extension Pogoprotos.Networking.Responses.AddFortModifierResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.AddFortModifierResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.AddFortModifierResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse? {
    return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
    return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
    return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
    return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
    return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
    return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
    return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.AttackGymResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.AttackGymResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.AttackGymResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.AttackGymResponse? {
    return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
    return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
    return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
    return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
    return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
    return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
    return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.CatchPokemonResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.CatchPokemonResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.CatchPokemonResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse? {
    return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
    return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
    return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
    return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
    return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
    return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
    return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse? {
    return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
    return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
    return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
    return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
    return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
    return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
    return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.CheckChallengeResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.CheckChallengeResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.CheckChallengeResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse? {
    return try Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse {
    return try Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse {
    return try Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse {
    return try Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse {
    return try Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse {
    return try Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckChallengeResponse {
    return try Pogoprotos.Networking.Responses.CheckChallengeResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse? {
    return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
    return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
    return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
    return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
    return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
    return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
    return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.ClaimCodenameResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.ClaimCodenameResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.ClaimCodenameResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse? {
    return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
    return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
    return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
    return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
    return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
    return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
    return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.CollectDailyBonusResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.CollectDailyBonusResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.CollectDailyBonusResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse? {
    return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
    return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
    return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
    return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
    return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
    return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
    return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse? {
    return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
    return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
    return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
    return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
    return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
    return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
    return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.DiskEncounterResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.DiskEncounterResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.DiskEncounterResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse? {
    return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
    return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
    return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
    return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
    return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
    return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
    return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse? {
    return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
    return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
    return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
    return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
    return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
    return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
    return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate? {
    return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
    return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
    return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
    return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
    return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
    return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
    return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse? {
    return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
    return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
    return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
    return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
    return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
    return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
    return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.DownloadSettingsResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.DownloadSettingsResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.DownloadSettingsResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse? {
    return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
    return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
    return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
    return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
    return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
    return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
    return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.EchoResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.EchoResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.EchoResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.EchoResponse? {
    return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.EchoResponse {
    return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EchoResponse {
    return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.EchoResponse {
    return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EchoResponse {
    return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.EchoResponse {
    return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EchoResponse {
    return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.EncounterResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.EncounterResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.EncounterResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.EncounterResponse? {
    return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
    return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
    return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
    return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
    return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
    return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
    return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse? {
    return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
    return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
    return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
    return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
    return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
    return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
    return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.EquipBadgeResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.EquipBadgeResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.EquipBadgeResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse? {
    return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
    return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
    return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
    return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
    return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
    return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
    return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.EvolvePokemonResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.EvolvePokemonResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.EvolvePokemonResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse? {
    return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
    return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
    return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
    return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
    return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
    return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
    return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.FortDeployPokemonResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.FortDeployPokemonResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.FortDeployPokemonResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse? {
    return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
    return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
    return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
    return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
    return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
    return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
    return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.FortDetailsResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.FortDetailsResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.FortDetailsResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse? {
    return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
    return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
    return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
    return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
    return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
    return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
    return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.FortRecallPokemonResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.FortRecallPokemonResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.FortRecallPokemonResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse? {
    return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
    return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
    return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
    return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
    return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
    return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
    return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.FortSearchResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.FortSearchResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.FortSearchResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.FortSearchResponse? {
    return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
    return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
    return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
    return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
    return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
    return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
    return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.GetAssetDigestResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.GetAssetDigestResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.GetAssetDigestResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse? {
    return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
    return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
    return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
    return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
    return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
    return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
    return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.GetBuddyWalkedResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.GetBuddyWalkedResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.GetBuddyWalkedResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse? {
    return try Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse {
    return try Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse {
    return try Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse {
    return try Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse {
    return try Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse {
    return try Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetBuddyWalkedResponse {
    return try Pogoprotos.Networking.Responses.GetBuddyWalkedResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.GetDownloadUrlsResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.GetDownloadUrlsResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.GetDownloadUrlsResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse? {
    return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
    return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
    return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
    return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
    return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
    return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
    return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.GetGymDetailsResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.GetGymDetailsResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.GetGymDetailsResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse? {
    return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
    return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
    return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
    return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
    return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
    return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
    return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.GetHatchedEggsResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.GetHatchedEggsResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.GetHatchedEggsResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse? {
    return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
    return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
    return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
    return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
    return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
    return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
    return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.GetIncensePokemonResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.GetIncensePokemonResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.GetIncensePokemonResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse? {
    return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
    return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
    return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
    return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
    return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
    return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
    return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.GetInventoryResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.GetInventoryResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.GetInventoryResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse? {
    return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
    return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
    return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
    return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
    return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
    return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
    return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.GetMapObjectsResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.GetMapObjectsResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.GetMapObjectsResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse? {
    return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
    return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
    return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
    return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
    return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
    return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
    return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.GetPlayerProfileResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.GetPlayerProfileResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.GetPlayerProfileResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse? {
    return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
    return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
    return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
    return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
    return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
    return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
    return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.GetPlayerResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.GetPlayerResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.GetPlayerResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse? {
    return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
    return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
    return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
    return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
    return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
    return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
    return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse? {
    return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
    return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
    return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
    return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
    return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
    return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
    return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.IncenseEncounterResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.IncenseEncounterResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.IncenseEncounterResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse? {
    return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
    return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
    return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
    return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
    return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
    return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
    return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.LevelUpRewardsResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.LevelUpRewardsResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.LevelUpRewardsResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse? {
    return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
    return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
    return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
    return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
    return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
    return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
    return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse? {
    return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
    return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
    return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
    return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
    return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
    return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
    return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.NicknamePokemonResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.NicknamePokemonResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.NicknamePokemonResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse? {
    return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
    return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
    return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
    return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
    return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
    return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
    return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.PlayerUpdateResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.PlayerUpdateResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.PlayerUpdateResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse? {
    return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
    return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
    return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
    return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
    return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
    return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
    return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.RecycleInventoryItemResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.RecycleInventoryItemResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.RecycleInventoryItemResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse? {
    return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
    return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
    return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
    return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
    return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
    return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
    return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.ReleasePokemonResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.ReleasePokemonResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.ReleasePokemonResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse? {
    return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
    return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
    return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
    return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
    return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
    return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
    return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.SetAvatarResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.SetAvatarResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.SetAvatarResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse? {
    return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
    return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
    return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
    return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
    return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
    return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
    return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.SetBuddyPokemonResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.SetBuddyPokemonResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.SetBuddyPokemonResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse? {
    return try Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse {
    return try Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse {
    return try Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse {
    return try Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse {
    return try Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse {
    return try Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetBuddyPokemonResponse {
    return try Pogoprotos.Networking.Responses.SetBuddyPokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.SetContactSettingsResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.SetContactSettingsResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.SetContactSettingsResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse? {
    return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
    return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
    return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
    return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
    return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
    return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
    return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.SetFavoritePokemonResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.SetFavoritePokemonResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.SetFavoritePokemonResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse? {
    return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
    return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
    return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
    return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
    return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
    return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
    return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.SetPlayerTeamResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.SetPlayerTeamResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.SetPlayerTeamResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse? {
    return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
    return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
    return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
    return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
    return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
    return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
    return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.SfidaActionLogResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.SfidaActionLogResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.SfidaActionLogResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse? {
    return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
    return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
    return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
    return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
    return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
    return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
    return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.StartGymBattleResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.StartGymBattleResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.StartGymBattleResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse? {
    return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
    return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
    return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
    return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
    return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
    return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
    return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.UpgradePokemonResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.UpgradePokemonResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.UpgradePokemonResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse? {
    return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
    return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
    return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
    return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
    return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
    return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
    return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.UseIncenseResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.UseIncenseResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.UseIncenseResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse? {
    return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
    return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
    return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
    return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
    return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
    return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
    return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.UseItemCaptureResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.UseItemCaptureResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.UseItemCaptureResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse? {
    return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
    return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
    return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
    return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
    return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
    return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
    return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse? {
    return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
    return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
    return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
    return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
    return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
    return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
    return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.UseItemGymResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.UseItemGymResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.UseItemGymResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse? {
    return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
    return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
    return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
    return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
    return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
    return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
    return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.UseItemPotionResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.UseItemPotionResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.UseItemPotionResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse? {
    return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
    return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
    return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
    return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
    return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
    return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
    return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.UseItemReviveResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.UseItemReviveResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.UseItemReviveResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse? {
    return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
    return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
    return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
    return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
    return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
    return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
    return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.UseItemXpBoostResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.UseItemXpBoostResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.UseItemXpBoostResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse? {
    return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
    return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
    return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
    return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
    return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
    return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
    return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}
extension Pogoprotos.Networking.Responses.VerifyChallengeResponse: GeneratedMessageProtocol {
  public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Pogoprotos.Networking.Responses.VerifyChallengeResponse> {
    var mergedArray = Array<Pogoprotos.Networking.Responses.VerifyChallengeResponse>()
    while let value = try parseDelimitedFrom(inputStream: inputStream) {
      mergedArray.append(value)
    }
    return mergedArray
  }
  public class func parseDelimitedFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse? {
    return try Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
  }
  public class func parseFrom(data: Data) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse {
    return try Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder().mergeFrom(data: data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.default.extensionRegistry).build()
  }
  public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse {
    return try Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(inputStream: InputStream) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse {
    return try Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder().mergeFrom(inputStream: inputStream).build()
  }
  public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse {
    return try Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse {
    return try Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder().mergeFrom(codedInputStream: codedInputStream).build()
  }
  public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.VerifyChallengeResponse {
    return try Pogoprotos.Networking.Responses.VerifyChallengeResponse.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
  }
}

// @@protoc_insertion_point(global_scope)
